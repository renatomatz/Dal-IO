%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Modules}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Dal.io}
\date{Jul 19, 2020}
\release{0.0.1}
\author{Renato Mateus Zimmermann}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Quick Links}
\label{\detokenize{index:quick-links}}

\section{User Modules}
\label{\detokenize{modules:user-modules}}\label{\detokenize{modules:modules}}\label{\detokenize{modules::doc}}

\subsection{dalio.external package}
\label{\detokenize{dalio.external:dalio-external-package}}\label{\detokenize{dalio.external::doc}}

\subsubsection{Submodules}
\label{\detokenize{dalio.external:submodules}}

\subsubsection{dalio.external.external module}
\label{\detokenize{dalio.external:module-dalio.external.external}}\label{\detokenize{dalio.external:dalio-external-external-module}}\index{dalio.external.external (module)@\spxentry{dalio.external.external}\spxextra{module}}
Define abstract External class

External instances manage connections between your environment and an
external source. Class instacnes will often be redundant with existing
connection handlers, but at least subclasses will allow for more integrated
connection handling and collection, so that you can have a single connection
object for each external connection.
\index{External (class in dalio.external.external)@\spxentry{External}\spxextra{class in dalio.external.external}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.external.}}\sphinxbfcode{\sphinxupquote{External}}}{\emph{config=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.base.node.\_Node}}

Represents external data input or output

External instances have one external input and one internal output or one
internal input and one external output.
\index{\_connection (dalio.external.external.External attribute)@\spxentry{\_connection}\spxextra{dalio.external.external.External attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External._connection}}\pysigline{\sphinxbfcode{\sphinxupquote{\_connection}}}
connection with outside source of data

\end{fulllineitems}

\index{\_config (dalio.external.external.External attribute)@\spxentry{\_config}\spxextra{dalio.external.external.External attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External._config}}\pysigline{\sphinxbfcode{\sphinxupquote{\_config}}}
authentication settings for outside sources
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{authenticate() (dalio.external.external.External method)@\spxentry{authenticate()}\spxextra{dalio.external.external.External method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External.authenticate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{authenticate}}}{}{}
Establish a connection with the source.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if authenication is successful or if it is already existent
False if the authentication fails.

\end{description}\end{quote}

\end{fulllineitems}

\index{check() (dalio.external.external.External method)@\spxentry{check()}\spxextra{dalio.external.external.External method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{}{}
Check if connection is ready to request data
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Whether data is ready to be requested

\end{description}\end{quote}

\end{fulllineitems}

\index{request() (dalio.external.external.External method)@\spxentry{request()}\spxextra{dalio.external.external.External method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Request data to or from an external source

\end{fulllineitems}

\index{update\_config() (dalio.external.external.External method)@\spxentry{update\_config()}\spxextra{dalio.external.external.External method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.external.External.update_config}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_config}}}{\emph{new\_conf}}{}
Update configuration dict with new data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{new\_conf}} \textendash{} dictionary with new configurations or file containing
configuration settings translatable to a dictionary

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if config is a non\sphinxhyphen{}existent file or not a dict.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.external.file module}
\label{\detokenize{dalio.external:module-dalio.external.file}}\label{\detokenize{dalio.external:dalio-external-file-module}}\index{dalio.external.file (module)@\spxentry{dalio.external.file}\spxextra{module}}
Define File IO classes

Files are external sources of data that can be processed in several ways as
raw data used in a graph.
\index{FileWriter (class in dalio.external.file)@\spxentry{FileWriter}\spxextra{class in dalio.external.file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.FileWriter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.file.}}\sphinxbfcode{\sphinxupquote{FileWriter}}}{\emph{out\_file=\textless{}\_io.TextIOWrapper name=\textquotesingle{}\textless{}stdout\textgreater{}\textquotesingle{} mode=\textquotesingle{}w\textquotesingle{} encoding=\textquotesingle{}UTF\sphinxhyphen{}8\textquotesingle{}\textgreater{}}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.external.External}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.external.External}}}}}

File string writer
\index{\_connection (dalio.external.file.FileWriter attribute)@\spxentry{\_connection}\spxextra{dalio.external.file.FileWriter attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.FileWriter._connection}}\pysigline{\sphinxbfcode{\sphinxupquote{\_connection}}}
any file instance that can be written on

\end{fulllineitems}

\index{check() (dalio.external.file.FileWriter method)@\spxentry{check()}\spxextra{dalio.external.file.FileWriter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.FileWriter.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{}{}
Check if there is an open file as the connection

\end{fulllineitems}

\index{request() (dalio.external.file.FileWriter method)@\spxentry{request()}\spxextra{dalio.external.file.FileWriter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.FileWriter.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Write a request string onto a file

\end{fulllineitems}

\index{set\_connection() (dalio.external.file.FileWriter method)@\spxentry{set\_connection()}\spxextra{dalio.external.file.FileWriter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.FileWriter.set_connection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_connection}}}{\emph{new\_connection}}{}
Set current connection

Set connection to opened file or open a new file given the path to
one.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{new\_connection}} \textendash{} open file instance or path to an existing file.

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{IOError}} \textendash{} if specified path does not exist.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if specified “new\_connection” argument is of an
    invalid type

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PandasInFile (class in dalio.external.file)@\spxentry{PandasInFile}\spxextra{class in dalio.external.file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.PandasInFile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.file.}}\sphinxbfcode{\sphinxupquote{PandasInFile}}}{\emph{in\_file}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.external.External}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.external.External}}}}}

Get data from a file using the pandas package
\index{\_connection (dalio.external.file.PandasInFile attribute)@\spxentry{\_connection}\spxextra{dalio.external.file.PandasInFile attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.PandasInFile._connection}}\pysigline{\sphinxbfcode{\sphinxupquote{\_connection}}}
path to a file that can be read by some pandas
function.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{check() (dalio.external.file.PandasInFile method)@\spxentry{check()}\spxextra{dalio.external.file.PandasInFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.PandasInFile.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{}{}
Check if connection is ready to request data
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Whether data is ready to be requested

\end{description}\end{quote}

\end{fulllineitems}

\index{request() (dalio.external.file.PandasInFile method)@\spxentry{request()}\spxextra{dalio.external.file.PandasInFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.file.PandasInFile.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Get data input from a file according to its extension
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} arguments to the inport function.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.external.image module}
\label{\detokenize{dalio.external:module-dalio.external.image}}\label{\detokenize{dalio.external:dalio-external-image-module}}\index{dalio.external.image (module)@\spxentry{dalio.external.image}\spxextra{module}}
Define classes for image pieces

Images, be it a plot, picture or video are considered external outputs as the
figure itself is not contained in the python session, and must be shown in a
screen or server.
\index{PyPfOptGraph (class in dalio.external.image)@\spxentry{PyPfOptGraph}\spxextra{class in dalio.external.image}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPfOptGraph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.image.}}\sphinxbfcode{\sphinxupquote{PyPfOptGraph}}}{\emph{figsize=None}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.image.PyPlotGraph}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.image.PyPlotGraph}}}}}

Graphs data from the PyPfOpt package
\index{plot() (dalio.external.image.PyPfOptGraph method)@\spxentry{plot()}\spxextra{dalio.external.image.PyPfOptGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPfOptGraph.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{data}, \emph{coords=None}, \emph{kind=None}, \emph{**kwargs}}{}
Graph data from pypfopt
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} plottable data from pypfopt package

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if data is not of a plottable class from pypfopt

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PyPlotGraph (class in dalio.external.image)@\spxentry{PyPlotGraph}\spxextra{class in dalio.external.image}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPlotGraph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.image.}}\sphinxbfcode{\sphinxupquote{PyPlotGraph}}}{\emph{figsize=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.external.image.\_Figure}}

Figure from the matplotlib.pyplot package.
\index{\_connection (dalio.external.image.PyPlotGraph attribute)@\spxentry{\_connection}\spxextra{dalio.external.image.PyPlotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPlotGraph._connection}}\pysigline{\sphinxbfcode{\sphinxupquote{\_connection}}}
graph figure
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
matplotlib.pyplot.Figure

\end{description}\end{quote}

\end{fulllineitems}

\index{\_axes (dalio.external.image.PyPlotGraph attribute)@\spxentry{\_axes}\spxextra{dalio.external.image.PyPlotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPlotGraph._axes}}\pysigline{\sphinxbfcode{\sphinxupquote{\_axes}}}
figure axis
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
matplotlib.axes.\_subplots.AxesSubplot

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (dalio.external.image.PyPlotGraph method)@\spxentry{plot()}\spxextra{dalio.external.image.PyPlotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPlotGraph.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{data}, \emph{kind=None}, \emph{**graph\_opts}}{}
Plot x onto the x\sphinxhyphen{}axis and y onto the y\sphinxhyphen{}axis, if applicable.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{matrix}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{array like}}) \textendash{} either data to be plotted on the x
axis or a tuple of x and y data to be plotted or the x and y
axis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kind}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} kind of graph.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**graph\_opts}} \textendash{} plt plotting arguments for this kind of graph.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{request() (dalio.external.image.PyPlotGraph method)@\spxentry{request()}\spxextra{dalio.external.image.PyPlotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPlotGraph.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Processed request for data.

This adds the SHOW request to the base class implementation

\end{fulllineitems}

\index{reset() (dalio.external.image.PyPlotGraph method)@\spxentry{reset()}\spxextra{dalio.external.image.PyPlotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PyPlotGraph.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Set connection and axes to a single figure and axis

\end{fulllineitems}


\end{fulllineitems}

\index{PySubplotGraph (class in dalio.external.image)@\spxentry{PySubplotGraph}\spxextra{class in dalio.external.image}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.image.}}\sphinxbfcode{\sphinxupquote{PySubplotGraph}}}{\emph{rows}, \emph{cols}, \emph{figsize=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.external.image.\_MultiFigure}}

A matplotlib.pyplot.Figure containing multiple subplots.

This has a set number of axes, rows and columns which can be accessed
individually to have data plotted on. These will often be used inside of
applications that require more than one subplot all contained in the
same instance.
\index{\_rows (dalio.external.image.PySubplotGraph attribute)@\spxentry{\_rows}\spxextra{dalio.external.image.PySubplotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph._rows}}\pysigline{\sphinxbfcode{\sphinxupquote{\_rows}}}
number of rows in the subplot
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_cols (dalio.external.image.PySubplotGraph attribute)@\spxentry{\_cols}\spxextra{dalio.external.image.PySubplotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph._cols}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cols}}}
number of columns in the subplot
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_loc (dalio.external.image.PySubplotGraph attribute)@\spxentry{\_loc}\spxextra{dalio.external.image.PySubplotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph._loc}}\pysigline{\sphinxbfcode{\sphinxupquote{\_loc}}}
array of the figure’s axes
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_loc() (dalio.external.image.PySubplotGraph method)@\spxentry{get\_loc()}\spxextra{dalio.external.image.PySubplotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph.get_loc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_loc}}}{\emph{coords}}{}
Gets a specific axis from the \_loc attribute at given
coordinates

\end{fulllineitems}

\index{make\_manager() (dalio.external.image.PySubplotGraph method)@\spxentry{make\_manager()}\spxextra{dalio.external.image.PySubplotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph.make_manager}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{make\_manager}}}{\emph{coords}}{}
Create a SubPlotManager to manage this instance’s subplots

\end{fulllineitems}

\index{plot() (dalio.external.image.PySubplotGraph method)@\spxentry{plot()}\spxextra{dalio.external.image.PySubplotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{data}, \emph{coords=None}, \emph{kind=None}, \emph{**graph\_opts}}{}
Plot on a specified subplot axis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}) \textendash{} tuple of subplot coordinates to plot data

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if coordinates are out of range.

\end{description}\end{quote}

\end{fulllineitems}

\index{reset() (dalio.external.image.PySubplotGraph method)@\spxentry{reset()}\spxextra{dalio.external.image.PySubplotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.PySubplotGraph.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Resets figure and all axes

\end{fulllineitems}


\end{fulllineitems}

\index{SubplotManager (class in dalio.external.image)@\spxentry{SubplotManager}\spxextra{class in dalio.external.image}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.SubplotManager}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.image.}}\sphinxbfcode{\sphinxupquote{SubplotManager}}}{\emph{subplot}, \emph{coords}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.image.PyPlotGraph}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.image.PyPlotGraph}}}}}

A manager object for treating a subplot axis like a single plot.

Applications will often take in single plots and have their functionality
catered to such. Subplots, while useful, will often be used for specific
applications. A subplot manager allows you to create multiple subplots
and pass each one individually onto applications that take a single
subplot axis and still have access to the underlying figure.
\index{reset() (dalio.external.image.SubplotManager method)@\spxentry{reset()}\spxextra{dalio.external.image.SubplotManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.image.SubplotManager.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Set connection and axes to a single figure and axis

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.external.web module}
\label{\detokenize{dalio.external:module-dalio.external.web}}\label{\detokenize{dalio.external:dalio-external-web-module}}\index{dalio.external.web (module)@\spxentry{dalio.external.web}\spxextra{module}}
Define web external request classes
\index{QuandlAPI (class in dalio.external.web)@\spxentry{QuandlAPI}\spxextra{class in dalio.external.web}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.QuandlAPI}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.web.}}\sphinxbfcode{\sphinxupquote{QuandlAPI}}}{\emph{config=None}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.external.External}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.external.External}}}}}

Set up the Quandl API and request table data from quandl.
\index{\_quandl\_conf (dalio.external.web.QuandlAPI attribute)@\spxentry{\_quandl\_conf}\spxextra{dalio.external.web.QuandlAPI attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.QuandlAPI._quandl_conf}}\pysigline{\sphinxbfcode{\sphinxupquote{\_quandl\_conf}}}
Quandl API config object

\end{fulllineitems}

\index{authenticate() (dalio.external.web.QuandlAPI method)@\spxentry{authenticate()}\spxextra{dalio.external.web.QuandlAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.QuandlAPI.authenticate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{authenticate}}}{}{}
Set the api key if it is available in the config dictionary
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if key was successfully set, False otherwise

\end{description}\end{quote}

\end{fulllineitems}

\index{check() (dalio.external.web.QuandlAPI method)@\spxentry{check()}\spxextra{dalio.external.web.QuandlAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.QuandlAPI.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{}{}
Check if the api key is set

\end{fulllineitems}

\index{request() (dalio.external.web.QuandlAPI method)@\spxentry{request()}\spxextra{dalio.external.web.QuandlAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.QuandlAPI.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Request table data from quandl
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} keyword arguments for quandl request.
query: table to get data from.
filter: dictionary of filters for data. Depends on table.
columns: columns to select.

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{IOError}} \textendash{} if api key is not set.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if filters kwarg is not a dict.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{YahooDR (class in dalio.external.web)@\spxentry{YahooDR}\spxextra{class in dalio.external.web}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.YahooDR}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.web.}}\sphinxbfcode{\sphinxupquote{YahooDR}}}{\emph{config=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.external.web.\_PDR}}

Represents financial data from Yahoo! Finance
\index{request() (dalio.external.web.YahooDR method)@\spxentry{request()}\spxextra{dalio.external.web.YahooDR method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.web.YahooDR.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Get data from specified tickers

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Module contents}
\label{\detokenize{dalio.external:module-dalio.external}}\label{\detokenize{dalio.external:module-contents}}\index{dalio.external (module)@\spxentry{dalio.external}\spxextra{module}}\index{FileWriter (class in dalio.external)@\spxentry{FileWriter}\spxextra{class in dalio.external}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.FileWriter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.}}\sphinxbfcode{\sphinxupquote{FileWriter}}}{\emph{out\_file=\textless{}\_io.TextIOWrapper name=\textquotesingle{}\textless{}stdout\textgreater{}\textquotesingle{} mode=\textquotesingle{}w\textquotesingle{} encoding=\textquotesingle{}UTF\sphinxhyphen{}8\textquotesingle{}\textgreater{}}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.external.External}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.external.External}}}}}

File string writer
\index{\_connection (dalio.external.FileWriter attribute)@\spxentry{\_connection}\spxextra{dalio.external.FileWriter attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.FileWriter._connection}}\pysigline{\sphinxbfcode{\sphinxupquote{\_connection}}}
any file instance that can be written on

\end{fulllineitems}

\index{check() (dalio.external.FileWriter method)@\spxentry{check()}\spxextra{dalio.external.FileWriter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.FileWriter.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{}{}
Check if there is an open file as the connection

\end{fulllineitems}

\index{request() (dalio.external.FileWriter method)@\spxentry{request()}\spxextra{dalio.external.FileWriter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.FileWriter.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Write a request string onto a file

\end{fulllineitems}

\index{set\_connection() (dalio.external.FileWriter method)@\spxentry{set\_connection()}\spxextra{dalio.external.FileWriter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.FileWriter.set_connection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_connection}}}{\emph{new\_connection}}{}
Set current connection

Set connection to opened file or open a new file given the path to
one.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{new\_connection}} \textendash{} open file instance or path to an existing file.

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{IOError}} \textendash{} if specified path does not exist.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if specified “new\_connection” argument is of an
    invalid type

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PandasInFile (class in dalio.external)@\spxentry{PandasInFile}\spxextra{class in dalio.external}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PandasInFile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.}}\sphinxbfcode{\sphinxupquote{PandasInFile}}}{\emph{in\_file}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.external.External}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.external.External}}}}}

Get data from a file using the pandas package
\index{\_connection (dalio.external.PandasInFile attribute)@\spxentry{\_connection}\spxextra{dalio.external.PandasInFile attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PandasInFile._connection}}\pysigline{\sphinxbfcode{\sphinxupquote{\_connection}}}
path to a file that can be read by some pandas
function.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{check() (dalio.external.PandasInFile method)@\spxentry{check()}\spxextra{dalio.external.PandasInFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PandasInFile.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{}{}
Check if connection is ready to request data
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Whether data is ready to be requested

\end{description}\end{quote}

\end{fulllineitems}

\index{request() (dalio.external.PandasInFile method)@\spxentry{request()}\spxextra{dalio.external.PandasInFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PandasInFile.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Get data input from a file according to its extension
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} arguments to the inport function.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PyPlotGraph (class in dalio.external)@\spxentry{PyPlotGraph}\spxextra{class in dalio.external}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PyPlotGraph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.}}\sphinxbfcode{\sphinxupquote{PyPlotGraph}}}{\emph{figsize=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.external.image.\_Figure}}

Figure from the matplotlib.pyplot package.
\index{\_connection (dalio.external.PyPlotGraph attribute)@\spxentry{\_connection}\spxextra{dalio.external.PyPlotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PyPlotGraph._connection}}\pysigline{\sphinxbfcode{\sphinxupquote{\_connection}}}
graph figure
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
matplotlib.pyplot.Figure

\end{description}\end{quote}

\end{fulllineitems}

\index{\_axes (dalio.external.PyPlotGraph attribute)@\spxentry{\_axes}\spxextra{dalio.external.PyPlotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PyPlotGraph._axes}}\pysigline{\sphinxbfcode{\sphinxupquote{\_axes}}}
figure axis
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
matplotlib.axes.\_subplots.AxesSubplot

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (dalio.external.PyPlotGraph method)@\spxentry{plot()}\spxextra{dalio.external.PyPlotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PyPlotGraph.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{data}, \emph{kind=None}, \emph{**graph\_opts}}{}
Plot x onto the x\sphinxhyphen{}axis and y onto the y\sphinxhyphen{}axis, if applicable.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{matrix}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{array like}}) \textendash{} either data to be plotted on the x
axis or a tuple of x and y data to be plotted or the x and y
axis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kind}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} kind of graph.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**graph\_opts}} \textendash{} plt plotting arguments for this kind of graph.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{request() (dalio.external.PyPlotGraph method)@\spxentry{request()}\spxextra{dalio.external.PyPlotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PyPlotGraph.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Processed request for data.

This adds the SHOW request to the base class implementation

\end{fulllineitems}

\index{reset() (dalio.external.PyPlotGraph method)@\spxentry{reset()}\spxextra{dalio.external.PyPlotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PyPlotGraph.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Set connection and axes to a single figure and axis

\end{fulllineitems}


\end{fulllineitems}

\index{PySubplotGraph (class in dalio.external)@\spxentry{PySubplotGraph}\spxextra{class in dalio.external}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PySubplotGraph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.}}\sphinxbfcode{\sphinxupquote{PySubplotGraph}}}{\emph{rows}, \emph{cols}, \emph{figsize=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.external.image.\_MultiFigure}}

A matplotlib.pyplot.Figure containing multiple subplots.

This has a set number of axes, rows and columns which can be accessed
individually to have data plotted on. These will often be used inside of
applications that require more than one subplot all contained in the
same instance.
\index{\_rows (dalio.external.PySubplotGraph attribute)@\spxentry{\_rows}\spxextra{dalio.external.PySubplotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PySubplotGraph._rows}}\pysigline{\sphinxbfcode{\sphinxupquote{\_rows}}}
number of rows in the subplot
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_cols (dalio.external.PySubplotGraph attribute)@\spxentry{\_cols}\spxextra{dalio.external.PySubplotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PySubplotGraph._cols}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cols}}}
number of columns in the subplot
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_loc (dalio.external.PySubplotGraph attribute)@\spxentry{\_loc}\spxextra{dalio.external.PySubplotGraph attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PySubplotGraph._loc}}\pysigline{\sphinxbfcode{\sphinxupquote{\_loc}}}
array of the figure’s axes
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_loc() (dalio.external.PySubplotGraph method)@\spxentry{get\_loc()}\spxextra{dalio.external.PySubplotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PySubplotGraph.get_loc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_loc}}}{\emph{coords}}{}
Gets a specific axis from the \_loc attribute at given
coordinates

\end{fulllineitems}

\index{make\_manager() (dalio.external.PySubplotGraph method)@\spxentry{make\_manager()}\spxextra{dalio.external.PySubplotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PySubplotGraph.make_manager}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{make\_manager}}}{\emph{coords}}{}
Create a SubPlotManager to manage this instance’s subplots

\end{fulllineitems}

\index{plot() (dalio.external.PySubplotGraph method)@\spxentry{plot()}\spxextra{dalio.external.PySubplotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PySubplotGraph.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{data}, \emph{coords=None}, \emph{kind=None}, \emph{**graph\_opts}}{}
Plot on a specified subplot axis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}) \textendash{} tuple of subplot coordinates to plot data

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if coordinates are out of range.

\end{description}\end{quote}

\end{fulllineitems}

\index{reset() (dalio.external.PySubplotGraph method)@\spxentry{reset()}\spxextra{dalio.external.PySubplotGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PySubplotGraph.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Resets figure and all axes

\end{fulllineitems}


\end{fulllineitems}

\index{PyPfOptGraph (class in dalio.external)@\spxentry{PyPfOptGraph}\spxextra{class in dalio.external}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PyPfOptGraph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.}}\sphinxbfcode{\sphinxupquote{PyPfOptGraph}}}{\emph{figsize=None}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.image.PyPlotGraph}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.image.PyPlotGraph}}}}}

Graphs data from the PyPfOpt package
\index{plot() (dalio.external.PyPfOptGraph method)@\spxentry{plot()}\spxextra{dalio.external.PyPfOptGraph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.PyPfOptGraph.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{data}, \emph{coords=None}, \emph{kind=None}, \emph{**kwargs}}{}
Graph data from pypfopt
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} plottable data from pypfopt package

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if data is not of a plottable class from pypfopt

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{YahooDR (class in dalio.external)@\spxentry{YahooDR}\spxextra{class in dalio.external}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.YahooDR}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.}}\sphinxbfcode{\sphinxupquote{YahooDR}}}{\emph{config=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.external.web.\_PDR}}

Represents financial data from Yahoo! Finance
\index{request() (dalio.external.YahooDR method)@\spxentry{request()}\spxextra{dalio.external.YahooDR method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.YahooDR.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Get data from specified tickers

\end{fulllineitems}


\end{fulllineitems}

\index{QuandlAPI (class in dalio.external)@\spxentry{QuandlAPI}\spxextra{class in dalio.external}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.QuandlAPI}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.external.}}\sphinxbfcode{\sphinxupquote{QuandlAPI}}}{\emph{config=None}}{}
Bases: {\hyperref[\detokenize{dalio.external:dalio.external.external.External}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.external.external.External}}}}}

Set up the Quandl API and request table data from quandl.
\index{\_quandl\_conf (dalio.external.QuandlAPI attribute)@\spxentry{\_quandl\_conf}\spxextra{dalio.external.QuandlAPI attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.QuandlAPI._quandl_conf}}\pysigline{\sphinxbfcode{\sphinxupquote{\_quandl\_conf}}}
Quandl API config object

\end{fulllineitems}

\index{authenticate() (dalio.external.QuandlAPI method)@\spxentry{authenticate()}\spxextra{dalio.external.QuandlAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.QuandlAPI.authenticate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{authenticate}}}{}{}
Set the api key if it is available in the config dictionary
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if key was successfully set, False otherwise

\end{description}\end{quote}

\end{fulllineitems}

\index{check() (dalio.external.QuandlAPI method)@\spxentry{check()}\spxextra{dalio.external.QuandlAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.QuandlAPI.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{}{}
Check if the api key is set

\end{fulllineitems}

\index{request() (dalio.external.QuandlAPI method)@\spxentry{request()}\spxextra{dalio.external.QuandlAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.external:dalio.external.QuandlAPI.request}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{request}}}{\emph{**kwargs}}{}
Request table data from quandl
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} keyword arguments for quandl request.
query: table to get data from.
filter: dictionary of filters for data. Depends on table.
columns: columns to select.

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{IOError}} \textendash{} if api key is not set.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if filters kwarg is not a dict.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{dalio.translator package}
\label{\detokenize{dalio.translator:dalio-translator-package}}\label{\detokenize{dalio.translator::doc}}

\subsubsection{Submodules}
\label{\detokenize{dalio.translator:submodules}}

\subsubsection{dalio.translator.file module}
\label{\detokenize{dalio.translator:module-dalio.translator.file}}\label{\detokenize{dalio.translator:dalio-translator-file-module}}\index{dalio.translator.file (module)@\spxentry{dalio.translator.file}\spxextra{module}}
Translator for common file imports

These will often be very specific to the file being imported, but should
strive to still be as flexible as possible. These will often hold the format
translated to constant and try being adaptable with the data to fit it. So
it is more importat to begin with the output and then adapt to the input, not
the other way.
\index{StockStreamFileTranslator (class in dalio.translator.file)@\spxentry{StockStreamFileTranslator}\spxextra{class in dalio.translator.file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.file.StockStreamFileTranslator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.file.}}\sphinxbfcode{\sphinxupquote{StockStreamFileTranslator}}}{\emph{date\_col=None}, \emph{att\_name=None}}{}
Bases: {\hyperref[\detokenize{dalio.translator:dalio.translator.translator.Translator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.translator.translator.Translator}}}}}

Create a DataFrame conforming to the STOCK\_STREAM validator preset.
\begin{description}
\item[{The STOCK\_STREAM preset includes:}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\item {} 
having a time series index,

\item {} 
being a dataframe,

\item {} \begin{description}
\item[{having a multiindex column with levels named ATTRIBUTE and TICKER.}] \leavevmode
Such that an imported excel file will have column names renamed
that or assume a single column name row is of ticker names.

\end{description}

\end{enumerate}

\end{description}
\index{date\_col (dalio.translator.file.StockStreamFileTranslator attribute)@\spxentry{date\_col}\spxextra{dalio.translator.file.StockStreamFileTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.file.StockStreamFileTranslator.date_col}}\pysigline{\sphinxbfcode{\sphinxupquote{date\_col}}}
column name to get date data from.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{att\_name (dalio.translator.file.StockStreamFileTranslator attribute)@\spxentry{att\_name}\spxextra{dalio.translator.file.StockStreamFileTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.file.StockStreamFileTranslator.att_name}}\pysigline{\sphinxbfcode{\sphinxupquote{att\_name}}}
name of the attribute column if imported dataframe
column has only one level.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.translator.file.StockStreamFileTranslator method)@\spxentry{copy()}\spxextra{dalio.translator.file.StockStreamFileTranslator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.file.StockStreamFileTranslator.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.translator.file.StockStreamFileTranslator method)@\spxentry{run()}\spxextra{dalio.translator.file.StockStreamFileTranslator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.file.StockStreamFileTranslator.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Request pandas data from file and format it into a dataframe that
complies with the STOCK\_STREAM validator preset
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} 
Optional request arguments
TICKER: single ticker or iterable of tickers to filter for
\begin{quote}

in data.
\end{quote}


\end{description}\end{quote}

\end{fulllineitems}

\index{translations (dalio.translator.file.StockStreamFileTranslator attribute)@\spxentry{translations}\spxextra{dalio.translator.file.StockStreamFileTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.file.StockStreamFileTranslator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.translator.pdr module}
\label{\detokenize{dalio.translator:module-dalio.translator.pdr}}\label{\detokenize{dalio.translator:dalio-translator-pdr-module}}\index{dalio.translator.pdr (module)@\spxentry{dalio.translator.pdr}\spxextra{module}}
Define translators for data from the pandas\_datareader package
\index{YahooStockTranslator (class in dalio.translator.pdr)@\spxentry{YahooStockTranslator}\spxextra{class in dalio.translator.pdr}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.pdr.YahooStockTranslator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.pdr.}}\sphinxbfcode{\sphinxupquote{YahooStockTranslator}}}
Bases: {\hyperref[\detokenize{dalio.translator:dalio.translator.translator.Translator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.translator.translator.Translator}}}}}

Translate stock data gathered from Yahoo! Finance
\index{run() (dalio.translator.pdr.YahooStockTranslator method)@\spxentry{run()}\spxextra{dalio.translator.pdr.YahooStockTranslator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.pdr.YahooStockTranslator.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Request data subset and translate columns
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} optional run arguments.
TICKER: ticker to get data from.

\end{description}\end{quote}

\end{fulllineitems}

\index{translations (dalio.translator.pdr.YahooStockTranslator attribute)@\spxentry{translations}\spxextra{dalio.translator.pdr.YahooStockTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.pdr.YahooStockTranslator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.translator.quandl module}
\label{\detokenize{dalio.translator:module-dalio.translator.quandl}}\label{\detokenize{dalio.translator:dalio-translator-quandl-module}}\index{dalio.translator.quandl (module)@\spxentry{dalio.translator.quandl}\spxextra{module}}
Define Translator instances for data imported from quandl.

These should be designed with both input and output in mind as quandl inputs
can, for a good extent, known from the table and query, both of which are
known from the time of request. This means that these translators should be
designed to be more specific to the query instead of being flexible.
\index{QuandlSharadarSF1Translator (class in dalio.translator.quandl)@\spxentry{QuandlSharadarSF1Translator}\spxextra{class in dalio.translator.quandl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.quandl.QuandlSharadarSF1Translator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.quandl.}}\sphinxbfcode{\sphinxupquote{QuandlSharadarSF1Translator}}}
Bases: {\hyperref[\detokenize{dalio.translator:dalio.translator.translator.Translator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.translator.translator.Translator}}}}}

Import and translate data from the SHARADAR/SF1 table
\index{run() (dalio.translator.quandl.QuandlSharadarSF1Translator method)@\spxentry{run()}\spxextra{dalio.translator.quandl.QuandlSharadarSF1Translator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.quandl.QuandlSharadarSF1Translator.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get input from quandl’s SHARADAR/SF1 table, and format
according to the STOCK\_STREAM validator preset.

\end{fulllineitems}

\index{translations (dalio.translator.quandl.QuandlSharadarSF1Translator attribute)@\spxentry{translations}\spxextra{dalio.translator.quandl.QuandlSharadarSF1Translator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.quandl.QuandlSharadarSF1Translator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}

\index{QuandlTickerInfoTranslator (class in dalio.translator.quandl)@\spxentry{QuandlTickerInfoTranslator}\spxextra{class in dalio.translator.quandl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.quandl.QuandlTickerInfoTranslator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.quandl.}}\sphinxbfcode{\sphinxupquote{QuandlTickerInfoTranslator}}}
Bases: {\hyperref[\detokenize{dalio.translator:dalio.translator.translator.Translator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.translator.translator.Translator}}}}}

Import and translate data from the SHARADAR/TICKERS table
\index{run() (dalio.translator.quandl.QuandlTickerInfoTranslator method)@\spxentry{run()}\spxextra{dalio.translator.quandl.QuandlTickerInfoTranslator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.quandl.QuandlTickerInfoTranslator.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get input from quandl’s SHARADAR/TICKER table, and format
according to the STOCK\_INFO validator preset.

\end{fulllineitems}

\index{translations (dalio.translator.quandl.QuandlTickerInfoTranslator attribute)@\spxentry{translations}\spxextra{dalio.translator.quandl.QuandlTickerInfoTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.quandl.QuandlTickerInfoTranslator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.translator.translator module}
\label{\detokenize{dalio.translator:module-dalio.translator.translator}}\label{\detokenize{dalio.translator:dalio-translator-translator-module}}\index{dalio.translator.translator (module)@\spxentry{dalio.translator.translator}\spxextra{module}}
Define Translator class

Translators are the root of all data that feeds your graph. Objects of this
take in data from some external source then “translates” it into a format that
can be used universaly by other elements in this package. Please consult the
translation manual to make this as usabel as possible and make extensive use
of the base tools to build translations.
\index{Translator (class in dalio.translator.translator)@\spxentry{Translator}\spxextra{class in dalio.translator.translator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.translator.}}\sphinxbfcode{\sphinxupquote{Translator}}}
Bases: \sphinxcode{\sphinxupquote{dalio.base.transformer.\_Transformer}}
\index{\_source (dalio.translator.translator.Translator attribute)@\spxentry{\_source}\spxextra{dalio.translator.translator.Translator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator._source}}\pysigline{\sphinxbfcode{\sphinxupquote{\_source}}}
Connection used to retrieve raw data from outide source.

\end{fulllineitems}

\index{translations (dalio.translator.translator.Translator attribute)@\spxentry{translations}\spxextra{dalio.translator.translator.Translator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}}
dictionary of translations from vocabulaary used in the
data source to base constants. These should be created from
initialization and kept unmodified. This is to ensure data coming
through a translator is though of before usage to ensure
integrity.

\end{fulllineitems}

\index{copy() (dalio.translator.translator.Translator method)@\spxentry{copy()}\spxextra{dalio.translator.translator.Translator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_input() (dalio.translator.translator.Translator method)@\spxentry{set\_input()}\spxextra{dalio.translator.translator.Translator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator.set_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_input}}}{\emph{new\_input}}{}
See base class

\end{fulllineitems}

\index{translate\_item() (dalio.translator.translator.Translator method)@\spxentry{translate\_item()}\spxextra{dalio.translator.translator.Translator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator.translate_item}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{translate\_item}}}{\emph{item}}{}
Translate all items of an iterable
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{item}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{any}}) \textendash{} item or iterator of items to translate.

\item[{Returns}] \leavevmode
A list with the translated names.

\end{description}\end{quote}

\end{fulllineitems}

\index{translations (dalio.translator.translator.Translator attribute)@\spxentry{translations}\spxextra{dalio.translator.translator.Translator attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{: Dict{[}str, str{]}}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{update\_translations() (dalio.translator.translator.Translator method)@\spxentry{update\_translations()}\spxextra{dalio.translator.translator.Translator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator.update_translations}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_translations}}}{\emph{new\_translations}}{}
Update translations dictionary with new dictrionary

\end{fulllineitems}

\index{with\_input() (dalio.translator.translator.Translator method)@\spxentry{with\_input()}\spxextra{dalio.translator.translator.Translator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.translator.Translator.with_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{with\_input}}}{\emph{new\_input}}{}
See base class

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Module contents}
\label{\detokenize{dalio.translator:module-dalio.translator}}\label{\detokenize{dalio.translator:module-contents}}\index{dalio.translator (module)@\spxentry{dalio.translator}\spxextra{module}}\index{QuandlSharadarSF1Translator (class in dalio.translator)@\spxentry{QuandlSharadarSF1Translator}\spxextra{class in dalio.translator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.QuandlSharadarSF1Translator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.}}\sphinxbfcode{\sphinxupquote{QuandlSharadarSF1Translator}}}
Bases: {\hyperref[\detokenize{dalio.translator:dalio.translator.translator.Translator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.translator.translator.Translator}}}}}

Import and translate data from the SHARADAR/SF1 table
\index{run() (dalio.translator.QuandlSharadarSF1Translator method)@\spxentry{run()}\spxextra{dalio.translator.QuandlSharadarSF1Translator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.QuandlSharadarSF1Translator.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get input from quandl’s SHARADAR/SF1 table, and format
according to the STOCK\_STREAM validator preset.

\end{fulllineitems}

\index{translations (dalio.translator.QuandlSharadarSF1Translator attribute)@\spxentry{translations}\spxextra{dalio.translator.QuandlSharadarSF1Translator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.QuandlSharadarSF1Translator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}

\index{QuandlTickerInfoTranslator (class in dalio.translator)@\spxentry{QuandlTickerInfoTranslator}\spxextra{class in dalio.translator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.QuandlTickerInfoTranslator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.}}\sphinxbfcode{\sphinxupquote{QuandlTickerInfoTranslator}}}
Bases: {\hyperref[\detokenize{dalio.translator:dalio.translator.translator.Translator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.translator.translator.Translator}}}}}

Import and translate data from the SHARADAR/TICKERS table
\index{run() (dalio.translator.QuandlTickerInfoTranslator method)@\spxentry{run()}\spxextra{dalio.translator.QuandlTickerInfoTranslator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.QuandlTickerInfoTranslator.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get input from quandl’s SHARADAR/TICKER table, and format
according to the STOCK\_INFO validator preset.

\end{fulllineitems}

\index{translations (dalio.translator.QuandlTickerInfoTranslator attribute)@\spxentry{translations}\spxextra{dalio.translator.QuandlTickerInfoTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.QuandlTickerInfoTranslator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}

\index{YahooStockTranslator (class in dalio.translator)@\spxentry{YahooStockTranslator}\spxextra{class in dalio.translator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.YahooStockTranslator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.}}\sphinxbfcode{\sphinxupquote{YahooStockTranslator}}}
Bases: {\hyperref[\detokenize{dalio.translator:dalio.translator.translator.Translator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.translator.translator.Translator}}}}}

Translate stock data gathered from Yahoo! Finance
\index{run() (dalio.translator.YahooStockTranslator method)@\spxentry{run()}\spxextra{dalio.translator.YahooStockTranslator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.YahooStockTranslator.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Request data subset and translate columns
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} optional run arguments.
TICKER: ticker to get data from.

\end{description}\end{quote}

\end{fulllineitems}

\index{translations (dalio.translator.YahooStockTranslator attribute)@\spxentry{translations}\spxextra{dalio.translator.YahooStockTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.YahooStockTranslator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}

\index{StockStreamFileTranslator (class in dalio.translator)@\spxentry{StockStreamFileTranslator}\spxextra{class in dalio.translator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.StockStreamFileTranslator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.translator.}}\sphinxbfcode{\sphinxupquote{StockStreamFileTranslator}}}{\emph{date\_col=None}, \emph{att\_name=None}}{}
Bases: {\hyperref[\detokenize{dalio.translator:dalio.translator.translator.Translator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.translator.translator.Translator}}}}}

Create a DataFrame conforming to the STOCK\_STREAM validator preset.
\begin{description}
\item[{The STOCK\_STREAM preset includes:}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\item {} 
having a time series index,

\item {} 
being a dataframe,

\item {} \begin{description}
\item[{having a multiindex column with levels named ATTRIBUTE and TICKER.}] \leavevmode
Such that an imported excel file will have column names renamed
that or assume a single column name row is of ticker names.

\end{description}

\end{enumerate}

\end{description}
\index{date\_col (dalio.translator.StockStreamFileTranslator attribute)@\spxentry{date\_col}\spxextra{dalio.translator.StockStreamFileTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.StockStreamFileTranslator.date_col}}\pysigline{\sphinxbfcode{\sphinxupquote{date\_col}}}
column name to get date data from.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{att\_name (dalio.translator.StockStreamFileTranslator attribute)@\spxentry{att\_name}\spxextra{dalio.translator.StockStreamFileTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.StockStreamFileTranslator.att_name}}\pysigline{\sphinxbfcode{\sphinxupquote{att\_name}}}
name of the attribute column if imported dataframe
column has only one level.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.translator.StockStreamFileTranslator method)@\spxentry{copy()}\spxextra{dalio.translator.StockStreamFileTranslator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.StockStreamFileTranslator.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.translator.StockStreamFileTranslator method)@\spxentry{run()}\spxextra{dalio.translator.StockStreamFileTranslator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.StockStreamFileTranslator.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Request pandas data from file and format it into a dataframe that
complies with the STOCK\_STREAM validator preset
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} 
Optional request arguments
TICKER: single ticker or iterable of tickers to filter for
\begin{quote}

in data.
\end{quote}


\end{description}\end{quote}

\end{fulllineitems}

\index{translations (dalio.translator.StockStreamFileTranslator attribute)@\spxentry{translations}\spxextra{dalio.translator.StockStreamFileTranslator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.translator:dalio.translator.StockStreamFileTranslator.translations}}\pysigline{\sphinxbfcode{\sphinxupquote{translations}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}



\subsection{dalio.pipe package}
\label{\detokenize{dalio.pipe:dalio-pipe-package}}\label{\detokenize{dalio.pipe::doc}}

\subsubsection{Submodules}
\label{\detokenize{dalio.pipe:submodules}}

\subsubsection{dalio.pipe.builders module}
\label{\detokenize{dalio.pipe:module-dalio.pipe.builders}}\label{\detokenize{dalio.pipe:dalio-pipe-builders-module}}\index{dalio.pipe.builders (module)@\spxentry{dalio.pipe.builders}\spxextra{module}}
Builder Pipes
\index{CovShrink (class in dalio.pipe.builders)@\spxentry{CovShrink}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.CovShrink}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{CovShrink}}}{\emph{frequency=252}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.PipeBuilder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.PipeBuilder}}}}}

Perform Covariance Shrinkage on data

Builder with a single piece: shirnkage. Shrinkage defines what kind of
shrinkage to apply on a resultant covariance matrix. If none is set,
covariance will not be shrunk.
\index{frequency (dalio.pipe.builders.CovShrink attribute)@\spxentry{frequency}\spxextra{dalio.pipe.builders.CovShrink attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.CovShrink.frequency}}\pysigline{\sphinxbfcode{\sphinxupquote{frequency}}}
data time period frequency
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{build\_model() (dalio.pipe.builders.CovShrink method)@\spxentry{build\_model()}\spxextra{dalio.pipe.builders.CovShrink method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.CovShrink.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Builds Covariance Srhinkage object and returns selected shrinkage
strategy
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Function fitted on the data.

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_name() (dalio.pipe.builders.CovShrink method)@\spxentry{check\_name()}\spxextra{dalio.pipe.builders.CovShrink method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.CovShrink.check_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_name}}}{\emph{param}, \emph{name}}{}
Check if name and parameter combination is valid.

This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
\_Builder. This also can be called from outside of a \_Builder instance
to check for the validity of settings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{piece}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the key in the piece dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name option to be set to the piece.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.builders.CovShrink method)@\spxentry{copy()}\spxextra{dalio.pipe.builders.CovShrink method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.CovShrink.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{frequency (dalio.pipe.builders.CovShrink attribute)@\spxentry{frequency}\spxextra{dalio.pipe.builders.CovShrink attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{frequency}}\sphinxbfcode{\sphinxupquote{: int}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{transform() (dalio.pipe.builders.CovShrink method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.CovShrink method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.CovShrink.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Build model using data get results.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A covariance matrix

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ExpectedReturns (class in dalio.pipe.builders)@\spxentry{ExpectedReturns}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ExpectedReturns}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{ExpectedReturns}}}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.PipeBuilder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.PipeBuilder}}}}}

Get stock’s time series expected returns.

Builder with a single piece: return\_model. return\_model is what model to
get the expected returns from.
\index{build\_model() (dalio.pipe.builders.ExpectedReturns method)@\spxentry{build\_model()}\spxextra{dalio.pipe.builders.ExpectedReturns method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ExpectedReturns.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Assemble pieces into a model given some data

The data will opten be optional, but several builder models will
require it to be fitted on initialization. Which further shows why
builders are necessary for context\sphinxhyphen{}agnostic graphs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data that might be used to build the model.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} any additional argument used in building

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_name() (dalio.pipe.builders.ExpectedReturns method)@\spxentry{check\_name()}\spxextra{dalio.pipe.builders.ExpectedReturns method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ExpectedReturns.check_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_name}}}{\emph{param}, \emph{name}}{}
Check if name and parameter combination is valid.

This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
\_Builder. This also can be called from outside of a \_Builder instance
to check for the validity of settings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{piece}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the key in the piece dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name option to be set to the piece.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.builders.ExpectedReturns method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.ExpectedReturns method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ExpectedReturns.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Builds model using data and gets expected returns from it

\end{fulllineitems}


\end{fulllineitems}

\index{ExpectedShortfall (class in dalio.pipe.builders)@\spxentry{ExpectedShortfall}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ExpectedShortfall}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{ExpectedShortfall}}}{\emph{quantiles=None}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.builders.ValueAtRisk}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.builders.ValueAtRisk}}}}}

Get expected shortfal for given quantiles

See base class for more in depth explanation.
\index{transform() (dalio.pipe.builders.ExpectedShortfall method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.ExpectedShortfall method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ExpectedShortfall.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Get the value at risk given by an arch model and calculate the
expected shortfall at given quantiles.

\end{fulllineitems}


\end{fulllineitems}

\index{MakeARCH (class in dalio.pipe.builders)@\spxentry{MakeARCH}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.MakeARCH}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{MakeARCH}}}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.PipeBuilder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.PipeBuilder}}}}}

Build arch model and make it based on input data.

This class allows for the creation of arch models by configuring three
pieces: the mean, volatility and distribution. These are set after
initialization through the \_Builder interface.
\index{\_piece (dalio.pipe.builders.MakeARCH attribute)@\spxentry{\_piece}\spxextra{dalio.pipe.builders.MakeARCH attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.MakeARCH._piece}}\pysigline{\sphinxbfcode{\sphinxupquote{\_piece}}}
see \_Builder class.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{assimilate() (dalio.pipe.builders.MakeARCH method)@\spxentry{assimilate()}\spxextra{dalio.pipe.builders.MakeARCH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.MakeARCH.assimilate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{assimilate}}}{\emph{model}}{}
Assimilate core pieces of an existent ARCH Model.

Assimilation means setting this model’s’ pieces in accordance to an
existing model’s pieces. Assimilation is shallow, so only the main
pieces are assimilated, not their parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{model}} (\sphinxstyleliteralemphasis{\sphinxupquote{ARCHModel}}) \textendash{} Existing ARCH Model.

\end{description}\end{quote}

\end{fulllineitems}

\index{build\_model() (dalio.pipe.builders.MakeARCH method)@\spxentry{build\_model()}\spxextra{dalio.pipe.builders.MakeARCH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.MakeARCH.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Build ARCH Model using data, set pieces and their arguments
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A built arch model from the arch package.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.builders.MakeARCH method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.MakeARCH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.MakeARCH.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Build model with sourced data

\end{fulllineitems}


\end{fulllineitems}

\index{OptimumWeights (class in dalio.pipe.builders)@\spxentry{OptimumWeights}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.OptimumWeights}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{OptimumWeights}}}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.PipeBuilder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.PipeBuilder}}}}}

Get optimum portfolio weights from an efficient frontier or CLA.
This is also a builder with one piece: strategy. The strategy piece
refers to the optimization strategy.
\index{build\_model() (dalio.pipe.builders.OptimumWeights method)@\spxentry{build\_model()}\spxextra{dalio.pipe.builders.OptimumWeights method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.OptimumWeights.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Assemble pieces into a model given some data

The data will opten be optional, but several builder models will
require it to be fitted on initialization. Which further shows why
builders are necessary for context\sphinxhyphen{}agnostic graphs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data that might be used to build the model.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} any additional argument used in building

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_name() (dalio.pipe.builders.OptimumWeights method)@\spxentry{check\_name()}\spxextra{dalio.pipe.builders.OptimumWeights method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.OptimumWeights.check_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_name}}}{\emph{param}, \emph{name}}{}
Check if name and parameter combination is valid.

This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
\_Builder. This also can be called from outside of a \_Builder instance
to check for the validity of settings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{piece}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the key in the piece dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name option to be set to the piece.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.builders.OptimumWeights method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.OptimumWeights method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.OptimumWeights.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Get efficient frontier, fit it to model and get weights

\end{fulllineitems}


\end{fulllineitems}

\index{PandasLinearModel (class in dalio.pipe.builders)@\spxentry{PandasLinearModel}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.PandasLinearModel}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{PandasLinearModel}}}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.PipeBuilder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.PipeBuilder}}}}}

Create a linear model from input pandas dataframe, using its index
as the X value.

This builder is made up of a single piece: strategy. This piece sets
which linear model should be used to fit the data.
\index{build\_model() (dalio.pipe.builders.PandasLinearModel method)@\spxentry{build\_model()}\spxextra{dalio.pipe.builders.PandasLinearModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.PandasLinearModel.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Build model by returning the chosen model and initialization
parameters
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Unfitted linear model

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.builders.PandasLinearModel method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.PandasLinearModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.PandasLinearModel.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Set up fitting parameters and fit built model.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Fitted linear model

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StockComps (class in dalio.pipe.builders)@\spxentry{StockComps}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.StockComps}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{StockComps}}}{\emph{strategy=\textquotesingle{}sic\_code\textquotesingle{}}, \emph{max\_ticks=6}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Get a list of a ticker’s comparable stocks

This can utilize any strategy of getting stock comparative companies and
return up to a certain ammount of comps.
\index{\_strategy (dalio.pipe.builders.StockComps attribute)@\spxentry{\_strategy}\spxextra{dalio.pipe.builders.StockComps attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.StockComps._strategy}}\pysigline{\sphinxbfcode{\sphinxupquote{\_strategy}}}
comparisson strategy name or function.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, callable

\end{description}\end{quote}

\end{fulllineitems}

\index{max\_ticks (dalio.pipe.builders.StockComps attribute)@\spxentry{max\_ticks}\spxextra{dalio.pipe.builders.StockComps attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.StockComps.max_ticks}}\pysigline{\sphinxbfcode{\sphinxupquote{max\_ticks}}}
maximum number of tickers to return.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.builders.StockComps method)@\spxentry{copy()}\spxextra{dalio.pipe.builders.StockComps method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.StockComps.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{max\_ticks (dalio.pipe.builders.StockComps attribute)@\spxentry{max\_ticks}\spxextra{dalio.pipe.builders.StockComps attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{max\_ticks}}\sphinxbfcode{\sphinxupquote{: int}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{run() (dalio.pipe.builders.StockComps method)@\spxentry{run()}\spxextra{dalio.pipe.builders.StockComps method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.StockComps.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets ticker argument and passes an empty ticker request to
transform.

Empty ticker requests are supposed to return all tickers available in
a source, so this allows the compariisson to be made in all stocks
from a certain source.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if ticker is more than a single symbol.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.builders.StockComps method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.StockComps method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.StockComps.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Get comps according to the set strategy

\end{fulllineitems}


\end{fulllineitems}

\index{ValueAtRisk (class in dalio.pipe.builders)@\spxentry{ValueAtRisk}\spxextra{class in dalio.pipe.builders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ValueAtRisk}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.builders.}}\sphinxbfcode{\sphinxupquote{ValueAtRisk}}}{\emph{quantiles=None}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Get the value at risk for data based on an ARHC Model

This takes in an ARCH Model maker, not data, which might be unintuitive,
yet necessary, as this allows users to modify the ARCH model generating
these values separately. A useful strategy that allows for this
is using a pipeline with an arch model as its first input and a
ValueAtRisk instance as its second layer. This allows us to treat the
PipeLine as a data input with VaR output and still have control over the
ARCH Model pieces (given you left a local variable for it behind.)
\index{\_quantiles (dalio.pipe.builders.ValueAtRisk attribute)@\spxentry{\_quantiles}\spxextra{dalio.pipe.builders.ValueAtRisk attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ValueAtRisk._quantiles}}\pysigline{\sphinxbfcode{\sphinxupquote{\_quantiles}}}
list of quantiles to check the value at risk for.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.builders.ValueAtRisk method)@\spxentry{copy()}\spxextra{dalio.pipe.builders.ValueAtRisk method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ValueAtRisk.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.builders.ValueAtRisk method)@\spxentry{transform()}\spxextra{dalio.pipe.builders.ValueAtRisk method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.builders.ValueAtRisk.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Get values at risk at each quantile and each results maximum
exedence from the mean.

The maximum exedence columns tells which quantile the loss is placed
on. The word “maximum” might be misleading as it is compared to the
minimum quantile, however, this definition is accurate as the column
essentially answers the question: “what quantile furthest away from
the mean does the data exeed?”

Thank you for the creators of the arch package for the beautiful
visualizations and ideas!
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if ARCH model does not have returns. This is often
    the case for unfitted models. Ensure your graph is complete.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if ARCH model has unsuported distribution parameter.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.pipe.col\_generation module}
\label{\detokenize{dalio.pipe:module-dalio.pipe.col_generation}}\label{\detokenize{dalio.pipe:dalio-pipe-col-generation-module}}\index{dalio.pipe.col\_generation (module)@\spxentry{dalio.pipe.col\_generation}\spxextra{module}}
Implement transformations that generates new colums from exising ones
\index{Bin (class in dalio.pipe.col\_generation)@\spxentry{Bin}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Bin}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{Bin}}}{\emph{bin\_map}, \emph{*args}, \emph{bin\_strat=\textquotesingle{}normal\textquotesingle{}}, \emph{columns=None}, \emph{new\_cols=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.col_generation.Custom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.Custom}}}}}

A pipeline stage that adds a binned version of a column or columns.

If drop is set to True the new columns retain the names of the source
columns; otherwise, the resulting column gain the suffix ‘\_bin’
\index{bin\_map (dalio.pipe.col\_generation.Bin attribute)@\spxentry{bin\_map}\spxextra{dalio.pipe.col\_generation.Bin attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Bin.bin_map}}\pysigline{\sphinxbfcode{\sphinxupquote{bin\_map}}}
implicitly projects a left\sphinxhyphen{}most bin containing
all elements smaller than the left\sphinxhyphen{}most end point and a right\sphinxhyphen{}most
bin containing all elements larger that the right\sphinxhyphen{}most end point.
For example, the list {[}0, 5, 8{]} is interpreted as
the bins (\sphinxhyphen{}\(\infty\), 0), {[}0\sphinxhyphen{}5), {[}5\sphinxhyphen{}8) and {[}8, \(\infty\)).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
array\sphinxhyphen{}like

\end{description}\end{quote}

\end{fulllineitems}

\index{bin\_strat (dalio.pipe.col\_generation.Bin attribute)@\spxentry{bin\_strat}\spxextra{dalio.pipe.col\_generation.Bin attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Bin.bin_strat}}\pysigline{\sphinxbfcode{\sphinxupquote{bin\_strat}}}
binning strategy to use. “normal”
uses the default binning strategy per a list of value separations
or number of bins. “quantile” uses a list of quantiles or a
preset quantile range (4 for quartiles and 10 for deciles).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, default “normal”

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{speed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{Bin}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{speed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   speed speed\PYGZus{}bin}
\PYG{g+go}{1     \PYGZhy{}3        \PYGZlt{}5}
\PYG{g+go}{2      4        \PYGZlt{}5}
\PYG{g+go}{3      5        5≤}
\PYG{g+go}{4      9        5≤}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{Bin}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{speed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   speed speed\PYGZus{}bin}
\PYG{g+go}{1     \PYGZhy{}3        \PYGZlt{}0}
\PYG{g+go}{2      4       0\PYGZhy{}5}
\PYG{g+go}{3      5       5\PYGZhy{}8}
\PYG{g+go}{4      9        8≤}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{BoxCox (class in dalio.pipe.col\_generation)@\spxentry{BoxCox}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.BoxCox}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{BoxCox}}}{\emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{non\_neg=False}, \emph{const\_shift=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.col_generation.Custom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.Custom}}}}}

A pipeline stage that applies the BoxCox transformation on data.
\index{const\_shift (dalio.pipe.col\_generation.BoxCox attribute)@\spxentry{const\_shift}\spxextra{dalio.pipe.col\_generation.BoxCox attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.BoxCox.const_shift}}\pysigline{\sphinxbfcode{\sphinxupquote{const\_shift}}}
If given, each transformed column is
first shifted by this constant. If non\_neg is True then that
transformation is applied first, and only then is the column
shifted by this constant.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, optional

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Change (class in dalio.pipe.col\_generation)@\spxentry{Change}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Change}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{Change}}}{\emph{*args}, \emph{strategy=\textquotesingle{}diff\textquotesingle{}}, \emph{columns=None}, \emph{new\_cols=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.\_ColGeneration}}}}}

Perform item\sphinxhyphen{}by\sphinxhyphen{}item change

This has two main forms, percentage change and absolute change
(difference).
\index{\_strategy (dalio.pipe.col\_generation.Change attribute)@\spxentry{\_strategy}\spxextra{dalio.pipe.col\_generation.Change attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Change._strategy}}\pysigline{\sphinxbfcode{\sphinxupquote{\_strategy}}}
change strategy.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, callable

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.col\_generation.Change method)@\spxentry{copy()}\spxextra{dalio.pipe.col\_generation.Change method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Change.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Custom (class in dalio.pipe.col\_generation)@\spxentry{Custom}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Custom}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{Custom}}}{\emph{func}, \emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{strategy=\textquotesingle{}apply\textquotesingle{}}, \emph{axis=0}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.\_ColGeneration}}}}}

Apply custom function.
\index{strategy (dalio.pipe.col\_generation.Custom attribute)@\spxentry{strategy}\spxextra{dalio.pipe.col\_generation.Custom attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Custom.strategy}}\pysigline{\sphinxbfcode{\sphinxupquote{strategy}}}
strategy for applying value function.
One of {[}“apply”, “transform”, “agg”, “pipe”{]}
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, default “pipe”

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{from} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{pipe} \PYG{k+kn}{import} \PYG{n}{Custom}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2143}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{1321}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1255}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{years}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{avg\PYGZus{}revenue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{total\PYGZus{}rev} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{row}\PYG{p}{:} \PYG{n}{row}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{years}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{n}{row}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{avg\PYGZus{}revenue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{add\PYGZus{}total\PYGZus{}rev} \PYG{o}{=} \PYG{n}{Custom}\PYG{p}{(}\PYG{n}{total\PYGZus{}rev}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{total\PYGZus{}revenue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{add\PYGZus{}total\PYGZus{}rev}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   years  avg\PYGZus{}revenue  total\PYGZus{}revenue}
\PYG{g+go}{1      3         2143           6429}
\PYG{g+go}{2     10         1321          13210}
\PYG{g+go}{3      7         1255           8785}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{halfer}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{new} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{year/2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{row}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{years}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}
\PYG{g+gp}{... }           \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rev/2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{row}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{avg\PYGZus{}revenue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{new}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{half\PYGZus{}cols} \PYG{o}{=} \PYG{n}{Custom}\PYG{p}{(}\PYG{n}{halfer}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{half\PYGZus{}cols}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   years  avg\PYGZus{}revenue   rev/2  year/2}
\PYG{g+go}{1      3         2143  1071.5     1.5}
\PYG{g+go}{2     10         1321   660.5     5.0}
\PYG{g+go}{3      7         1255   627.5     3.5}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{func} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{df}\PYG{p}{:} \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{add\PYGZus{}equal} \PYG{o}{=} \PYG{n}{Custom}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A==B}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{strategy}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pipe}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{add\PYGZus{}equal}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   A  B   A==B}
\PYG{g+go}{1  3  3   True}
\PYG{g+go}{2  2  4  False}
\PYG{g+go}{3  1  5  False}
\end{sphinxVerbatim}
\index{copy() (dalio.pipe.col\_generation.Custom method)@\spxentry{copy()}\spxextra{dalio.pipe.col\_generation.Custom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Custom.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CustomByCols (class in dalio.pipe.col\_generation)@\spxentry{CustomByCols}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.CustomByCols}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{CustomByCols}}}{\emph{func}, \emph{*args}, \emph{strategy=\textquotesingle{}apply\textquotesingle{}}, \emph{columns=None}, \emph{new\_cols=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.col_generation.Custom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.Custom}}}}}

A pipeline stage applying a function to individual columns iteratively.
\index{func (dalio.pipe.col\_generation.CustomByCols attribute)@\spxentry{func}\spxextra{dalio.pipe.col\_generation.CustomByCols attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.CustomByCols.func}}\pysigline{\sphinxbfcode{\sphinxupquote{func}}}
The function to be applied to each element of the
given columns.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
function

\end{description}\end{quote}

\end{fulllineitems}

\index{strategy (dalio.pipe.col\_generation.CustomByCols attribute)@\spxentry{strategy}\spxextra{dalio.pipe.col\_generation.CustomByCols attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.CustomByCols.strategy}}\pysigline{\sphinxbfcode{\sphinxupquote{strategy}}}
Application strategy. Different from Custom class’
strategy parameter (which here is kept at “apply”) as this will
now be done on a series (each column). Extra care should be taken
to ensure resulting column lengths match.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{math}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{3.2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{acd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{7.2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alk}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{12.1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alk}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ph}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lbl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{round\PYGZus{}ph} \PYG{o}{=} \PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ApplyByCols}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ph}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{math}\PYG{o}{.}\PYG{n}{ceil}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{round\PYGZus{}ph}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   ph  lbl}
\PYG{g+go}{1   4  acd}
\PYG{g+go}{2   8  alk}
\PYG{g+go}{3  13  alk}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Index (class in dalio.pipe.col\_generation)@\spxentry{Index}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Index}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{Index}}}{\emph{index\_at}, \emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.\_ColGeneration}}}}}
\index{copy() (dalio.pipe.col\_generation.Index method)@\spxentry{copy()}\spxextra{dalio.pipe.col\_generation.Index method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Index.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Log (class in dalio.pipe.col\_generation)@\spxentry{Log}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Log}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{Log}}}{\emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{non\_neg=False}, \emph{const\_shift=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.col_generation.Custom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.Custom}}}}}

A pipeline stage that log\sphinxhyphen{}transforms numeric data.
\index{non\_neg (dalio.pipe.col\_generation.Log attribute)@\spxentry{non\_neg}\spxextra{dalio.pipe.col\_generation.Log attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Log.non_neg}}\pysigline{\sphinxbfcode{\sphinxupquote{non\_neg}}}
If True, each transformed column is
first shifted by smallest negative value it includes
(non\sphinxhyphen{}negative columns are thus not shifted).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool, default False

\end{description}\end{quote}

\end{fulllineitems}

\index{const\_shift (dalio.pipe.col\_generation.Log attribute)@\spxentry{const\_shift}\spxextra{dalio.pipe.col\_generation.Log attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Log.const_shift}}\pysigline{\sphinxbfcode{\sphinxupquote{const\_shift}}}
If given, each transformed column is
first shifted by this constant. If non\_neg is True then that
transformation is applied first, and only then is the column
shifted by this constant.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, optional

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{3.2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{acd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{7.2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alk}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{12.1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alk}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ph}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lbl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{log\PYGZus{}stage} \PYG{o}{=} \PYG{n}{pdp}\PYG{o}{.}\PYG{n}{Log}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ph}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{log\PYGZus{}stage}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{         ph  lbl}
\PYG{g+go}{1  1.163151  acd}
\PYG{g+go}{2  1.974081  alk}
\PYG{g+go}{3  2.493205  alk}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{MapColVals (class in dalio.pipe.col\_generation)@\spxentry{MapColVals}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.MapColVals}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{MapColVals}}}{\emph{value\_map}, \emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.col_generation.Custom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.Custom}}}}}

A pipeline stage that reintegrates the values of a column by a map.
\index{value\_map (dalio.pipe.col\_generation.MapColVals attribute)@\spxentry{value\_map}\spxextra{dalio.pipe.col\_generation.MapColVals attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.MapColVals.value_map}}\pysigline{\sphinxbfcode{\sphinxupquote{value\_map}}}
A dictionary mapping
existing values to new ones. Values not in the dictionary as keys
will be converted to NaN. If a function is given, it is applied
element\sphinxhyphen{}wise to given columns. If a Series is given, values are
mapped by its index to its values.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict, function or pandas.Series

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UK}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USSR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{US}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Medal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{value\PYGZus{}map} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gold}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Silver}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Bronze}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{MapColVals}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Medal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{value\PYGZus{}map}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{       Medal}
\PYG{g+go}{UK      Gold}
\PYG{g+go}{USSR  Bronze}
\PYG{g+go}{US    Silver}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Period (class in dalio.pipe.col\_generation)@\spxentry{Period}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Period}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{Period}}}{\emph{period}, \emph{*args}, \emph{agg\_func=\textless{}function mean\textgreater{}}, \emph{columns=None}, \emph{new\_cols=None}, \emph{axis=0}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.\_ColGeneration}}}}}

Resample input time series data to a different period
\begin{quote}
\begin{description}
\item[{Attributes:}] \leavevmode
agg\_func (callable): function to aggregate data to one period.

\end{description}
\end{quote}
\begin{description}
\item[{\# Quandl Input}] \leavevmode\begin{quote}

Default set to np.mean.
\end{quote}
\begin{description}
\item[{\_period (str): period to resample data to. Can be either daily,}] \leavevmode
monthly, quarterly or yearly.

\end{description}

\end{description}
\index{agg\_func (dalio.pipe.col\_generation.Period attribute)@\spxentry{agg\_func}\spxextra{dalio.pipe.col\_generation.Period attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Period.agg_func}}\pysigline{\sphinxbfcode{\sphinxupquote{agg\_func}}\sphinxbfcode{\sphinxupquote{: Callable{[}{[}Iterable{]}, Any{]}}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{copy() (dalio.pipe.col\_generation.Period method)@\spxentry{copy()}\spxextra{dalio.pipe.col\_generation.Period method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Period.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Rolling (class in dalio.pipe.col\_generation)@\spxentry{Rolling}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Rolling}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{Rolling}}}{\emph{func}, \emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{rolling\_window=2}, \emph{axis=0}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.\_ColGeneration}}}}}

Apply rolling function
\index{rolling\_window (dalio.pipe.col\_generation.Rolling attribute)@\spxentry{rolling\_window}\spxextra{dalio.pipe.col\_generation.Rolling attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Rolling.rolling_window}}\pysigline{\sphinxbfcode{\sphinxupquote{rolling\_window}}}
rolling window to apply
function. If none, no rolling window is applied.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, defailt None

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.col\_generation.Rolling method)@\spxentry{copy()}\spxextra{dalio.pipe.col\_generation.Rolling method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.Rolling.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StockReturns (class in dalio.pipe.col\_generation)@\spxentry{StockReturns}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.col_generation.StockReturns}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{StockReturns}}}{\emph{columns=None}, \emph{new\_cols=None}, \emph{drop=True}, \emph{reintegrate=False}}{}
Bases: {\hyperref[\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.\_ColGeneration}}}}}

Perform percent change and minor aesthetic changes to data

\end{fulllineitems}



\subsubsection{dalio.pipe.forecast module}
\label{\detokenize{dalio.pipe:module-dalio.pipe.forecast}}\label{\detokenize{dalio.pipe:dalio-pipe-forecast-module}}\index{dalio.pipe.forecast (module)@\spxentry{dalio.pipe.forecast}\spxextra{module}}
Transformations makes forecasts based on data
\index{Forecast (class in dalio.pipe.forecast)@\spxentry{Forecast}\spxextra{class in dalio.pipe.forecast}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.forecast.Forecast}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.forecast.}}\sphinxbfcode{\sphinxupquote{Forecast}}}{\emph{horizon=10}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Generalized forecasting class.

This should be used mostly for subclassing or very generic forecasting
interfaces.
\index{horizon (dalio.pipe.forecast.Forecast attribute)@\spxentry{horizon}\spxextra{dalio.pipe.forecast.Forecast attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.forecast.Forecast.horizon}}\pysigline{\sphinxbfcode{\sphinxupquote{horizon}}}
how many steps ahead to forecast
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{horizon (dalio.pipe.forecast.Forecast attribute)@\spxentry{horizon}\spxextra{dalio.pipe.forecast.Forecast attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{horizon}}\sphinxbfcode{\sphinxupquote{: int}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{transform() (dalio.pipe.forecast.Forecast method)@\spxentry{transform()}\spxextra{dalio.pipe.forecast.Forecast method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.forecast.Forecast.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Return forecast of data

\end{fulllineitems}


\end{fulllineitems}

\index{GARCHForecast (class in dalio.pipe.forecast)@\spxentry{GARCHForecast}\spxextra{class in dalio.pipe.forecast}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.forecast.GARCHForecast}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.forecast.}}\sphinxbfcode{\sphinxupquote{GARCHForecast}}}{\emph{start=None}, \emph{horizon=1}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.forecast.Forecast}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.forecast.Forecast}}}}}

Forecast data based on a fitted GARCH model
\index{\_start (dalio.pipe.forecast.GARCHForecast attribute)@\spxentry{\_start}\spxextra{dalio.pipe.forecast.GARCHForecast attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.forecast.GARCHForecast._start}}\pysigline{\sphinxbfcode{\sphinxupquote{\_start}}}
forecast start time and date.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pd.Timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.forecast.GARCHForecast method)@\spxentry{transform()}\spxextra{dalio.pipe.forecast.GARCHForecast method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.forecast.GARCHForecast.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Make a mean, variance and residual variance forecast.

Forecast will be made for the specified horizon starting at the
specified time. This means that will only get data for the steps
starting at the specified start date and the steps after it.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A DataFrame with the columns MEAN, VARIANCE and RESIDUAL\_VARIANCE
for the time horizon after the start date.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.pipe.pipe module}
\label{\detokenize{dalio.pipe:module-dalio.pipe.pipe}}\label{\detokenize{dalio.pipe:dalio-pipe-pipe-module}}\index{dalio.pipe.pipe (module)@\spxentry{dalio.pipe.pipe}\spxextra{module}}
Defines the Pipe and PipeLine classes

Pipes are perhaps the most common classes in graphs and represent any
transformation with one input and one output. Pipes\textasciigrave{} main functionality
revolves around the .transform() method, which actually applies a
transformation to data retrieved from a source. Pipes must also implement
propper data checks by adding descriptions to their source.
\index{Pipe (class in dalio.pipe.pipe)@\spxentry{Pipe}\spxextra{class in dalio.pipe.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.pipe.}}\sphinxbfcode{\sphinxupquote{Pipe}}}
Bases: \sphinxcode{\sphinxupquote{dalio.base.transformer.\_Transformer}}

Pipes represend data modifications with one internal input and one
internal output.
\index{\_source (dalio.pipe.pipe.Pipe attribute)@\spxentry{\_source}\spxextra{dalio.pipe.pipe.Pipe attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe._source}}\pysigline{\sphinxbfcode{\sphinxupquote{\_source}}}
input data definition
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\_DataDef

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.pipe.Pipe method)@\spxentry{copy()}\spxextra{dalio.pipe.pipe.Pipe method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_input() (dalio.pipe.pipe.Pipe method)@\spxentry{get\_input()}\spxextra{dalio.pipe.pipe.Pipe method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe.get_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_input}}}{}{}
Return the input transformer

\end{fulllineitems}

\index{pipeline() (dalio.pipe.pipe.Pipe method)@\spxentry{pipeline()}\spxextra{dalio.pipe.pipe.Pipe method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe.pipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pipeline}}}{\emph{*args}}{}
Returns a PipeLine instance with self as the input source and any
other Pipe instances as part of its pipeline.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} any additional Pipe to be added to the pipeline, in that
order.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.pipe.pipe.Pipe method)@\spxentry{run()}\spxextra{dalio.pipe.pipe.Pipe method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get data from source, transform it, and return it

This will often be left alone unless there are specific keyword
arguments or checks done in addition to the actual transformation.
Keep in mind this is rare, as keyword arguments are often required
by Translators, and checks are performed by DataDefs.

\end{fulllineitems}

\index{set\_input() (dalio.pipe.pipe.Pipe method)@\spxentry{set\_input()}\spxextra{dalio.pipe.pipe.Pipe method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe.set_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_input}}}{\emph{new\_input}}{}
Set the input data source in place.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{new\_input}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_Transformer}}) \textendash{} new transformer to be set as input to
source connection.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if new\_input is not an instance of \_Transformer.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.pipe.Pipe method)@\spxentry{transform()}\spxextra{dalio.pipe.pipe.Pipe method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}

\index{with\_input() (dalio.pipe.pipe.Pipe method)@\spxentry{with\_input()}\spxextra{dalio.pipe.pipe.Pipe method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe.with_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{with\_input}}}{\emph{new\_input}}{}
Return copy of this transformer with the new data source.

\end{fulllineitems}


\end{fulllineitems}

\index{PipeBuilder (class in dalio.pipe.pipe)@\spxentry{PipeBuilder}\spxextra{class in dalio.pipe.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.PipeBuilder}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.pipe.}}\sphinxbfcode{\sphinxupquote{PipeBuilder}}}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}, \sphinxcode{\sphinxupquote{dalio.base.builder.\_Builder}}

Hybrid builder type for complementing \_Transformer instances.

These specify extra methods implemented by \_Transformer instances.
\index{copy() (dalio.pipe.pipe.PipeBuilder method)@\spxentry{copy()}\spxextra{dalio.pipe.pipe.PipeBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.PipeBuilder.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{with\_piece() (dalio.pipe.pipe.PipeBuilder method)@\spxentry{with\_piece()}\spxextra{dalio.pipe.pipe.PipeBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.PipeBuilder.with_piece}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{with\_piece}}}{\emph{param}, \emph{name}, \emph{*args}, \emph{**kwargs}}{}
Copy self and return with a new piece set

\end{fulllineitems}


\end{fulllineitems}

\index{PipeLine (class in dalio.pipe.pipe)@\spxentry{PipeLine}\spxextra{class in dalio.pipe.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.PipeLine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.pipe.}}\sphinxbfcode{\sphinxupquote{PipeLine}}}{\emph{*args}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Collection of Pipe transformations.

PipeLine instances represent multiple Pipe transformations being
performed consecutively. Pipelines essentially execute multiple
transformations one after the other, and thus do not check for data
integrity in between them; so keep in mind that order matters and only
the first data definition will be enforced.
\index{pipeline (dalio.pipe.pipe.PipeLine attribute)@\spxentry{pipeline}\spxextra{dalio.pipe.pipe.PipeLine attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.PipeLine.pipeline}}\pysigline{\sphinxbfcode{\sphinxupquote{pipeline}}}
list of Pipe instaces this pipeline is composed of
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.pipe.PipeLine method)@\spxentry{copy()}\spxextra{dalio.pipe.pipe.PipeLine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.PipeLine.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Make a copy of this Pipeline

\end{fulllineitems}

\index{extend() (dalio.pipe.pipe.PipeLine method)@\spxentry{extend()}\spxextra{dalio.pipe.pipe.PipeLine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.PipeLine.extend}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extend}}}{\emph{*args}, \emph{deep=False}}{}
Extend existing pipeline with one or more Pipe instances

Keep in mind that this will not mean that

\end{fulllineitems}

\index{transform() (dalio.pipe.pipe.PipeLine method)@\spxentry{transform()}\spxextra{dalio.pipe.pipe.PipeLine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.pipe.PipeLine.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Pass data sourced from first pipe through every Pipe\textasciigrave{}s
.transform() method in order.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data sourced and checked from first source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.pipe.select module}
\label{\detokenize{dalio.pipe:module-dalio.pipe.select}}\label{\detokenize{dalio.pipe:dalio-pipe-select-module}}\index{dalio.pipe.select (module)@\spxentry{dalio.pipe.select}\spxextra{module}}
Defines various ways of getting a subset of data based on some condition
\index{ColDrop (class in dalio.pipe.select)@\spxentry{ColDrop}\spxextra{class in dalio.pipe.select}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ColDrop}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.select.}}\sphinxbfcode{\sphinxupquote{ColDrop}}}{\emph{columns}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColSelection}}

A pipeline stage that drops columns by name.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{columns}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{callable}}) \textendash{} The label, or an iterable of labels, of columns to drop. Alternatively,
columns can be assigned a callable returning bool values for
pandas.Series objects; if this is the case, every column for which it
return True will be dropped.

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{num}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ColDrop}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{num}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{  char}
\PYG{g+go}{1    a}
\PYG{g+go}{2    b}
\end{sphinxVerbatim}
\index{transform() (dalio.pipe.select.ColDrop method)@\spxentry{transform()}\spxextra{dalio.pipe.select.ColDrop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ColDrop.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ColRename (class in dalio.pipe.select)@\spxentry{ColRename}\spxextra{class in dalio.pipe.select}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ColRename}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.select.}}\sphinxbfcode{\sphinxupquote{ColRename}}}{\emph{map\_dict}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

A pipeline stage that renames a column or columns.
\index{rename\_map (dalio.pipe.select.ColRename attribute)@\spxentry{rename\_map}\spxextra{dalio.pipe.select.ColRename attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ColRename.rename_map}}\pysigline{\sphinxbfcode{\sphinxupquote{rename\_map}}}
Maps old column names to new ones.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\begin{description}
\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{num}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ColRename}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{num}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{len}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{initial}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   len initial}
\PYG{g+go}{1    8       a}
\PYG{g+go}{2    5       b}
\end{sphinxVerbatim}

\end{description}
\index{copy() (dalio.pipe.select.ColRename method)@\spxentry{copy()}\spxextra{dalio.pipe.select.ColRename method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ColRename.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.select.ColRename method)@\spxentry{transform()}\spxextra{dalio.pipe.select.ColRename method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ColRename.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ColReorder (class in dalio.pipe.select)@\spxentry{ColReorder}\spxextra{class in dalio.pipe.select}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ColReorder}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.select.}}\sphinxbfcode{\sphinxupquote{ColReorder}}}{\emph{map\_dict}, \emph{level=0}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColSelection}}

A pipeline stage that reorders columns.
\index{positions (dalio.pipe.select.ColReorder attribute)@\spxentry{positions}\spxextra{dalio.pipe.select.ColReorder attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ColReorder.positions}}\pysigline{\sphinxbfcode{\sphinxupquote{positions}}}
A mapping of column names to their desired positions
after reordering Columns not included in the mapping will maintain
their relative positions over the non\sphinxhyphen{}mapped colums.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{columns}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ColReorder}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   b  a  d  c}
\PYG{g+go}{0  4  8  7  3}
\end{sphinxVerbatim}
\index{copy() (dalio.pipe.select.ColReorder method)@\spxentry{copy()}\spxextra{dalio.pipe.select.ColReorder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ColReorder.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.select.ColReorder method)@\spxentry{transform()}\spxextra{dalio.pipe.select.ColReorder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ColReorder.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ColSelect (class in dalio.pipe.select)@\spxentry{ColSelect}\spxextra{class in dalio.pipe.select}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ColSelect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.select.}}\sphinxbfcode{\sphinxupquote{ColSelect}}}{\emph{columns}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColSelection}}

Select columns
\index{transform() (dalio.pipe.select.ColSelect method)@\spxentry{transform()}\spxextra{dalio.pipe.select.ColSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ColSelect.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Selects the specified columns or returns data as is if no column
was specified.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Data of the same format as before but only only containing the
specified columns.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DateSelect (class in dalio.pipe.select)@\spxentry{DateSelect}\spxextra{class in dalio.pipe.select}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.DateSelect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.select.}}\sphinxbfcode{\sphinxupquote{DateSelect}}}{\emph{start=None}, \emph{end=None}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Select a date range.

This is commonly left as a local variable to control date range being
used at a piece of a graph.
\index{\_start (dalio.pipe.select.DateSelect attribute)@\spxentry{\_start}\spxextra{dalio.pipe.select.DateSelect attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.DateSelect._start}}\pysigline{\sphinxbfcode{\sphinxupquote{\_start}}}
start date.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pd.Timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{\_end (dalio.pipe.select.DateSelect attribute)@\spxentry{\_end}\spxextra{dalio.pipe.select.DateSelect attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.DateSelect._end}}\pysigline{\sphinxbfcode{\sphinxupquote{\_end}}}
end date.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pd.Timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.select.DateSelect method)@\spxentry{copy()}\spxextra{dalio.pipe.select.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.DateSelect.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_end() (dalio.pipe.select.DateSelect method)@\spxentry{set\_end()}\spxextra{dalio.pipe.select.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.DateSelect.set_end}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_end}}}{\emph{end}}{}
Set the \_end attribute

\end{fulllineitems}

\index{set\_start() (dalio.pipe.select.DateSelect method)@\spxentry{set\_start()}\spxextra{dalio.pipe.select.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.DateSelect.set_start}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_start}}}{\emph{start}}{}
Set the \_start attribute

\end{fulllineitems}

\index{transform() (dalio.pipe.select.DateSelect method)@\spxentry{transform()}\spxextra{dalio.pipe.select.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.DateSelect.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Slices time series into selected date range.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Time series of the same format as input containing a subset of
the original dates.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DropNa (class in dalio.pipe.select)@\spxentry{DropNa}\spxextra{class in dalio.pipe.select}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.DropNa}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.select.}}\sphinxbfcode{\sphinxupquote{DropNa}}}{\emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

A pipeline stage that drops null values.

Supports all parameter supported by pandas.dropna function.
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{DropNa}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   a     b}
\PYG{g+go}{1  1   4.0}
\PYG{g+go}{3  1  11.0}
\end{sphinxVerbatim}
\index{transform() (dalio.pipe.select.DropNa method)@\spxentry{transform()}\spxextra{dalio.pipe.select.DropNa method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.DropNa.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{FreqDrop (class in dalio.pipe.select)@\spxentry{FreqDrop}\spxextra{class in dalio.pipe.select}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.FreqDrop}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.select.}}\sphinxbfcode{\sphinxupquote{FreqDrop}}}{\emph{values}, \emph{columns=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColValSelection}}

A pipeline stage that drops rows by value frequency.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The minimum frequency required for a value to be kept.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{column}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The name of the colums to check for the given value frequency.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{FreqDrop}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   a   b}
\PYG{g+go}{1  1   4}
\PYG{g+go}{3  1  11}
\end{sphinxVerbatim}
\index{transform() (dalio.pipe.select.FreqDrop method)@\spxentry{transform()}\spxextra{dalio.pipe.select.FreqDrop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.FreqDrop.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{RowDrop (class in dalio.pipe.select)@\spxentry{RowDrop}\spxextra{class in dalio.pipe.select}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.RowDrop}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.select.}}\sphinxbfcode{\sphinxupquote{RowDrop}}}{\emph{conditions}, \emph{columns=None}, \emph{reduce\_strat=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColSelection}}

A pipeline stage that drop rows by callable conditions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{conditions}} (\sphinxstyleliteralemphasis{\sphinxupquote{list\sphinxhyphen{}like}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} The list of conditions that make a row eligible to be dropped. Each
condition must be a callable that take a cell value and return a bool
value. If a list of callables is given, the conditions are checked for
each column value of each row. If a dict mapping column labels to
callables is given, then each condition is only checked for the column
values of the designated column.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{reduce}} (\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}any\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}all\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}xor\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default \textquotesingle{}any\textquotesingle{}}}) \textendash{} Determines how row conditions are reduced. If set to ‘all’, a row must
satisfy all given conditions to be dropped. If set to ‘any’, rows
satisfying at least one of the conditions are dropped. If set to ‘xor’,
rows satisfying exactly one of the conditions will be dropped. Set to
‘any’ by default.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{columns}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The label, or an iterable of labels, of columns. Optional. If given,
input conditions will be applied to the sub\sphinxhyphen{}dataframe made up of
these columns to determine which rows to drop.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{RowDrop}\PYG{p}{(}\PYG{p}{[}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   a   b}
\PYG{g+go}{2  4   5}
\PYG{g+go}{3  5  11}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{RowDrop}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   a   b}
\PYG{g+go}{1  1   4}
\PYG{g+go}{3  5  11}
\end{sphinxVerbatim}
\index{transform() (dalio.pipe.select.RowDrop method)@\spxentry{transform()}\spxextra{dalio.pipe.select.RowDrop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.RowDrop.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ValDrop (class in dalio.pipe.select)@\spxentry{ValDrop}\spxextra{class in dalio.pipe.select}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ValDrop}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.select.}}\sphinxbfcode{\sphinxupquote{ValDrop}}}{\emph{values}, \emph{columns=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColValSelection}}

A pipeline stage that drops rows by value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{values}} (\sphinxstyleliteralemphasis{\sphinxupquote{list\sphinxhyphen{}like}}) \textendash{} A list of the values to drop.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{columns}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list\sphinxhyphen{}like}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default None}}) \textendash{} The name, or an iterable of names, of columns to check for the given
values. If set to None, all columns are checked.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{18}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ValDrop}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{    a   b}
\PYG{g+go}{1   1   4}
\PYG{g+go}{3  18  11}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ValDrop}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{    a   b}
\PYG{g+go}{3  18  11}
\end{sphinxVerbatim}
\index{transform() (dalio.pipe.select.ValDrop method)@\spxentry{transform()}\spxextra{dalio.pipe.select.ValDrop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ValDrop.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ValKeep (class in dalio.pipe.select)@\spxentry{ValKeep}\spxextra{class in dalio.pipe.select}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ValKeep}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.select.}}\sphinxbfcode{\sphinxupquote{ValKeep}}}{\emph{values}, \emph{columns=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColValSelection}}

A pipeline stage that keeps rows by value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{values}} (\sphinxstyleliteralemphasis{\sphinxupquote{list\sphinxhyphen{}like}}) \textendash{} A list of the values to keep.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{columns}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list\sphinxhyphen{}like}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default None}}) \textendash{} The name, or an iterable of names, of columns to check for the given
values. If set to None, all columns are checked.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ValKeep}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   a   b}
\PYG{g+go}{2  4   5}
\PYG{g+go}{3  5  11}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ValKeep}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   a  b}
\PYG{g+go}{2  4  5}
\end{sphinxVerbatim}
\index{transform() (dalio.pipe.select.ValKeep method)@\spxentry{transform()}\spxextra{dalio.pipe.select.ValKeep method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.select.ValKeep.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Module contents}
\label{\detokenize{dalio.pipe:module-dalio.pipe}}\label{\detokenize{dalio.pipe:module-contents}}\index{dalio.pipe (module)@\spxentry{dalio.pipe}\spxextra{module}}\index{PipeLine (class in dalio.pipe)@\spxentry{PipeLine}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.PipeLine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{PipeLine}}}{\emph{*args}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Collection of Pipe transformations.

PipeLine instances represent multiple Pipe transformations being
performed consecutively. Pipelines essentially execute multiple
transformations one after the other, and thus do not check for data
integrity in between them; so keep in mind that order matters and only
the first data definition will be enforced.
\index{pipeline (dalio.pipe.PipeLine attribute)@\spxentry{pipeline}\spxextra{dalio.pipe.PipeLine attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.PipeLine.pipeline}}\pysigline{\sphinxbfcode{\sphinxupquote{pipeline}}}
list of Pipe instaces this pipeline is composed of
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.PipeLine method)@\spxentry{copy()}\spxextra{dalio.pipe.PipeLine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.PipeLine.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Make a copy of this Pipeline

\end{fulllineitems}

\index{extend() (dalio.pipe.PipeLine method)@\spxentry{extend()}\spxextra{dalio.pipe.PipeLine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.PipeLine.extend}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extend}}}{\emph{*args}, \emph{deep=False}}{}
Extend existing pipeline with one or more Pipe instances

Keep in mind that this will not mean that

\end{fulllineitems}

\index{transform() (dalio.pipe.PipeLine method)@\spxentry{transform()}\spxextra{dalio.pipe.PipeLine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.PipeLine.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Pass data sourced from first pipe through every Pipe\textasciigrave{}s
.transform() method in order.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data sourced and checked from first source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Custom (class in dalio.pipe)@\spxentry{Custom}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Custom}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{Custom}}}{\emph{func}, \emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{strategy=\textquotesingle{}apply\textquotesingle{}}, \emph{axis=0}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.\_ColGeneration}}}}}

Apply custom function.
\index{strategy (dalio.pipe.Custom attribute)@\spxentry{strategy}\spxextra{dalio.pipe.Custom attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Custom.strategy}}\pysigline{\sphinxbfcode{\sphinxupquote{strategy}}}
strategy for applying value function.
One of {[}“apply”, “transform”, “agg”, “pipe”{]}
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, default “pipe”

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{from} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{pipe} \PYG{k+kn}{import} \PYG{n}{Custom}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2143}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{1321}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1255}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{years}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{avg\PYGZus{}revenue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{total\PYGZus{}rev} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{row}\PYG{p}{:} \PYG{n}{row}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{years}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{n}{row}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{avg\PYGZus{}revenue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{add\PYGZus{}total\PYGZus{}rev} \PYG{o}{=} \PYG{n}{Custom}\PYG{p}{(}\PYG{n}{total\PYGZus{}rev}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{total\PYGZus{}revenue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{add\PYGZus{}total\PYGZus{}rev}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   years  avg\PYGZus{}revenue  total\PYGZus{}revenue}
\PYG{g+go}{1      3         2143           6429}
\PYG{g+go}{2     10         1321          13210}
\PYG{g+go}{3      7         1255           8785}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{halfer}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{new} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{year/2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{row}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{years}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}
\PYG{g+gp}{... }           \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rev/2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{row}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{avg\PYGZus{}revenue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{new}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{half\PYGZus{}cols} \PYG{o}{=} \PYG{n}{Custom}\PYG{p}{(}\PYG{n}{halfer}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{half\PYGZus{}cols}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   years  avg\PYGZus{}revenue   rev/2  year/2}
\PYG{g+go}{1      3         2143  1071.5     1.5}
\PYG{g+go}{2     10         1321   660.5     5.0}
\PYG{g+go}{3      7         1255   627.5     3.5}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{func} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{df}\PYG{p}{:} \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{add\PYGZus{}equal} \PYG{o}{=} \PYG{n}{Custom}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A==B}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{strategy}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pipe}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{add\PYGZus{}equal}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   A  B   A==B}
\PYG{g+go}{1  3  3   True}
\PYG{g+go}{2  2  4  False}
\PYG{g+go}{3  1  5  False}
\end{sphinxVerbatim}
\index{copy() (dalio.pipe.Custom method)@\spxentry{copy()}\spxextra{dalio.pipe.Custom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Custom.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Rolling (class in dalio.pipe)@\spxentry{Rolling}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Rolling}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{Rolling}}}{\emph{func}, \emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{rolling\_window=2}, \emph{axis=0}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.\_ColGeneration}}}}}

Apply rolling function
\index{rolling\_window (dalio.pipe.Rolling attribute)@\spxentry{rolling\_window}\spxextra{dalio.pipe.Rolling attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Rolling.rolling_window}}\pysigline{\sphinxbfcode{\sphinxupquote{rolling\_window}}}
rolling window to apply
function. If none, no rolling window is applied.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, defailt None

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.Rolling method)@\spxentry{copy()}\spxextra{dalio.pipe.Rolling method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Rolling.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ColSelect (class in dalio.pipe)@\spxentry{ColSelect}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ColSelect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{ColSelect}}}{\emph{columns}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColSelection}}

Select columns
\index{transform() (dalio.pipe.ColSelect method)@\spxentry{transform()}\spxextra{dalio.pipe.ColSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ColSelect.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Selects the specified columns or returns data as is if no column
was specified.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Data of the same format as before but only only containing the
specified columns.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DateSelect (class in dalio.pipe)@\spxentry{DateSelect}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.DateSelect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{DateSelect}}}{\emph{start=None}, \emph{end=None}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Select a date range.

This is commonly left as a local variable to control date range being
used at a piece of a graph.
\index{\_start (dalio.pipe.DateSelect attribute)@\spxentry{\_start}\spxextra{dalio.pipe.DateSelect attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.DateSelect._start}}\pysigline{\sphinxbfcode{\sphinxupquote{\_start}}}
start date.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pd.Timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{\_end (dalio.pipe.DateSelect attribute)@\spxentry{\_end}\spxextra{dalio.pipe.DateSelect attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.DateSelect._end}}\pysigline{\sphinxbfcode{\sphinxupquote{\_end}}}
end date.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pd.Timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.DateSelect method)@\spxentry{copy()}\spxextra{dalio.pipe.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.DateSelect.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_end() (dalio.pipe.DateSelect method)@\spxentry{set\_end()}\spxextra{dalio.pipe.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.DateSelect.set_end}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_end}}}{\emph{end}}{}
Set the \_end attribute

\end{fulllineitems}

\index{set\_start() (dalio.pipe.DateSelect method)@\spxentry{set\_start()}\spxextra{dalio.pipe.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.DateSelect.set_start}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_start}}}{\emph{start}}{}
Set the \_start attribute

\end{fulllineitems}

\index{transform() (dalio.pipe.DateSelect method)@\spxentry{transform()}\spxextra{dalio.pipe.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.DateSelect.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Slices time series into selected date range.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Time series of the same format as input containing a subset of
the original dates.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ColDrop (class in dalio.pipe)@\spxentry{ColDrop}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ColDrop}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{ColDrop}}}{\emph{columns}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColSelection}}

A pipeline stage that drops columns by name.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{columns}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{callable}}) \textendash{} The label, or an iterable of labels, of columns to drop. Alternatively,
columns can be assigned a callable returning bool values for
pandas.Series objects; if this is the case, every column for which it
return True will be dropped.

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{num}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ColDrop}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{num}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{  char}
\PYG{g+go}{1    a}
\PYG{g+go}{2    b}
\end{sphinxVerbatim}
\index{transform() (dalio.pipe.ColDrop method)@\spxentry{transform()}\spxextra{dalio.pipe.ColDrop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ColDrop.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ValDrop (class in dalio.pipe)@\spxentry{ValDrop}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ValDrop}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{ValDrop}}}{\emph{values}, \emph{columns=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColValSelection}}

A pipeline stage that drops rows by value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{values}} (\sphinxstyleliteralemphasis{\sphinxupquote{list\sphinxhyphen{}like}}) \textendash{} A list of the values to drop.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{columns}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list\sphinxhyphen{}like}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default None}}) \textendash{} The name, or an iterable of names, of columns to check for the given
values. If set to None, all columns are checked.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{18}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ValDrop}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{    a   b}
\PYG{g+go}{1   1   4}
\PYG{g+go}{3  18  11}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ValDrop}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{    a   b}
\PYG{g+go}{3  18  11}
\end{sphinxVerbatim}
\index{transform() (dalio.pipe.ValDrop method)@\spxentry{transform()}\spxextra{dalio.pipe.ValDrop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ValDrop.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ValKeep (class in dalio.pipe)@\spxentry{ValKeep}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ValKeep}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{ValKeep}}}{\emph{values}, \emph{columns=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColValSelection}}

A pipeline stage that keeps rows by value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{values}} (\sphinxstyleliteralemphasis{\sphinxupquote{list\sphinxhyphen{}like}}) \textendash{} A list of the values to keep.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{columns}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list\sphinxhyphen{}like}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default None}}) \textendash{} The name, or an iterable of names, of columns to check for the given
values. If set to None, all columns are checked.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ValKeep}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   a   b}
\PYG{g+go}{2  4   5}
\PYG{g+go}{3  5  11}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ValKeep}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   a  b}
\PYG{g+go}{2  4  5}
\end{sphinxVerbatim}
\index{transform() (dalio.pipe.ValKeep method)@\spxentry{transform()}\spxextra{dalio.pipe.ValKeep method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ValKeep.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ColRename (class in dalio.pipe)@\spxentry{ColRename}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ColRename}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{ColRename}}}{\emph{map\_dict}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

A pipeline stage that renames a column or columns.
\index{rename\_map (dalio.pipe.ColRename attribute)@\spxentry{rename\_map}\spxextra{dalio.pipe.ColRename attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ColRename.rename_map}}\pysigline{\sphinxbfcode{\sphinxupquote{rename\_map}}}
Maps old column names to new ones.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\begin{description}
\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{num}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ColRename}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{num}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{len}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{initial}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   len initial}
\PYG{g+go}{1    8       a}
\PYG{g+go}{2    5       b}
\end{sphinxVerbatim}

\end{description}
\index{copy() (dalio.pipe.ColRename method)@\spxentry{copy()}\spxextra{dalio.pipe.ColRename method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ColRename.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.ColRename method)@\spxentry{transform()}\spxextra{dalio.pipe.ColRename method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ColRename.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DropNa (class in dalio.pipe)@\spxentry{DropNa}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.DropNa}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{DropNa}}}{\emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

A pipeline stage that drops null values.

Supports all parameter supported by pandas.dropna function.
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{DropNa}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   a     b}
\PYG{g+go}{1  1   4.0}
\PYG{g+go}{3  1  11.0}
\end{sphinxVerbatim}
\index{transform() (dalio.pipe.DropNa method)@\spxentry{transform()}\spxextra{dalio.pipe.DropNa method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.DropNa.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{FreqDrop (class in dalio.pipe)@\spxentry{FreqDrop}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.FreqDrop}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{FreqDrop}}}{\emph{values}, \emph{columns=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColValSelection}}

A pipeline stage that drops rows by value frequency.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The minimum frequency required for a value to be kept.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{column}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The name of the colums to check for the given value frequency.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{FreqDrop}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   a   b}
\PYG{g+go}{1  1   4}
\PYG{g+go}{3  1  11}
\end{sphinxVerbatim}
\index{transform() (dalio.pipe.FreqDrop method)@\spxentry{transform()}\spxextra{dalio.pipe.FreqDrop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.FreqDrop.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ColReorder (class in dalio.pipe)@\spxentry{ColReorder}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ColReorder}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{ColReorder}}}{\emph{map\_dict}, \emph{level=0}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColSelection}}

A pipeline stage that reorders columns.
\index{positions (dalio.pipe.ColReorder attribute)@\spxentry{positions}\spxextra{dalio.pipe.ColReorder attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ColReorder.positions}}\pysigline{\sphinxbfcode{\sphinxupquote{positions}}}
A mapping of column names to their desired positions
after reordering Columns not included in the mapping will maintain
their relative positions over the non\sphinxhyphen{}mapped colums.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{columns}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ColReorder}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   b  a  d  c}
\PYG{g+go}{0  4  8  7  3}
\end{sphinxVerbatim}
\index{copy() (dalio.pipe.ColReorder method)@\spxentry{copy()}\spxextra{dalio.pipe.ColReorder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ColReorder.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.ColReorder method)@\spxentry{transform()}\spxextra{dalio.pipe.ColReorder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ColReorder.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{RowDrop (class in dalio.pipe)@\spxentry{RowDrop}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.RowDrop}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{RowDrop}}}{\emph{conditions}, \emph{columns=None}, \emph{reduce\_strat=None}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.pipe.select.\_ColSelection}}

A pipeline stage that drop rows by callable conditions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{conditions}} (\sphinxstyleliteralemphasis{\sphinxupquote{list\sphinxhyphen{}like}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} The list of conditions that make a row eligible to be dropped. Each
condition must be a callable that take a cell value and return a bool
value. If a list of callables is given, the conditions are checked for
each column value of each row. If a dict mapping column labels to
callables is given, then each condition is only checked for the column
values of the designated column.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{reduce}} (\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}any\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}all\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}xor\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default \textquotesingle{}any\textquotesingle{}}}) \textendash{} Determines how row conditions are reduced. If set to ‘all’, a row must
satisfy all given conditions to be dropped. If set to ‘any’, rows
satisfying at least one of the conditions are dropped. If set to ‘xor’,
rows satisfying exactly one of the conditions will be dropped. Set to
‘any’ by default.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{columns}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The label, or an iterable of labels, of columns. Optional. If given,
input conditions will be applied to the sub\sphinxhyphen{}dataframe made up of
these columns to determine which rows to drop.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{RowDrop}\PYG{p}{(}\PYG{p}{[}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   a   b}
\PYG{g+go}{2  4   5}
\PYG{g+go}{3  5  11}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{RowDrop}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   a   b}
\PYG{g+go}{1  1   4}
\PYG{g+go}{3  5  11}
\end{sphinxVerbatim}
\index{transform() (dalio.pipe.RowDrop method)@\spxentry{transform()}\spxextra{dalio.pipe.RowDrop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.RowDrop.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply a transformation to data returned from source.

This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data returned by source.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Change (class in dalio.pipe)@\spxentry{Change}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Change}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{Change}}}{\emph{*args}, \emph{strategy=\textquotesingle{}diff\textquotesingle{}}, \emph{columns=None}, \emph{new\_cols=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.\_ColGeneration}}}}}

Perform item\sphinxhyphen{}by\sphinxhyphen{}item change

This has two main forms, percentage change and absolute change
(difference).
\index{\_strategy (dalio.pipe.Change attribute)@\spxentry{\_strategy}\spxextra{dalio.pipe.Change attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Change._strategy}}\pysigline{\sphinxbfcode{\sphinxupquote{\_strategy}}}
change strategy.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, callable

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.Change method)@\spxentry{copy()}\spxextra{dalio.pipe.Change method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Change.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StockReturns (class in dalio.pipe)@\spxentry{StockReturns}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.StockReturns}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{StockReturns}}}{\emph{columns=None}, \emph{new\_cols=None}, \emph{drop=True}, \emph{reintegrate=False}}{}
Bases: {\hyperref[\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.\_ColGeneration}}}}}

Perform percent change and minor aesthetic changes to data

\end{fulllineitems}

\index{Period (class in dalio.pipe)@\spxentry{Period}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Period}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{Period}}}{\emph{period}, \emph{*args}, \emph{agg\_func=\textless{}function mean\textgreater{}}, \emph{columns=None}, \emph{new\_cols=None}, \emph{axis=0}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.\_ColGeneration}}}}}

Resample input time series data to a different period
\begin{quote}
\begin{description}
\item[{Attributes:}] \leavevmode
agg\_func (callable): function to aggregate data to one period.

\end{description}
\end{quote}
\begin{description}
\item[{\# Quandl Input}] \leavevmode\begin{quote}

Default set to np.mean.
\end{quote}
\begin{description}
\item[{\_period (str): period to resample data to. Can be either daily,}] \leavevmode
monthly, quarterly or yearly.

\end{description}

\end{description}
\index{agg\_func (dalio.pipe.Period attribute)@\spxentry{agg\_func}\spxextra{dalio.pipe.Period attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Period.agg_func}}\pysigline{\sphinxbfcode{\sphinxupquote{agg\_func}}\sphinxbfcode{\sphinxupquote{: Callable{[}{[}Iterable{]}, Any{]}}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{copy() (dalio.pipe.Period method)@\spxentry{copy()}\spxextra{dalio.pipe.Period method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Period.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Index (class in dalio.pipe)@\spxentry{Index}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Index}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{Index}}}{\emph{index\_at}, \emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.\_ColGeneration}}}}}
\index{copy() (dalio.pipe.Index method)@\spxentry{copy()}\spxextra{dalio.pipe.Index method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Index.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Bin (class in dalio.pipe)@\spxentry{Bin}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Bin}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{Bin}}}{\emph{bin\_map}, \emph{*args}, \emph{bin\_strat=\textquotesingle{}normal\textquotesingle{}}, \emph{columns=None}, \emph{new\_cols=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.col_generation.Custom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.Custom}}}}}

A pipeline stage that adds a binned version of a column or columns.

If drop is set to True the new columns retain the names of the source
columns; otherwise, the resulting column gain the suffix ‘\_bin’
\index{bin\_map (dalio.pipe.Bin attribute)@\spxentry{bin\_map}\spxextra{dalio.pipe.Bin attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Bin.bin_map}}\pysigline{\sphinxbfcode{\sphinxupquote{bin\_map}}}
implicitly projects a left\sphinxhyphen{}most bin containing
all elements smaller than the left\sphinxhyphen{}most end point and a right\sphinxhyphen{}most
bin containing all elements larger that the right\sphinxhyphen{}most end point.
For example, the list {[}0, 5, 8{]} is interpreted as
the bins (\sphinxhyphen{}\(\infty\), 0), {[}0\sphinxhyphen{}5), {[}5\sphinxhyphen{}8) and {[}8, \(\infty\)).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
array\sphinxhyphen{}like

\end{description}\end{quote}

\end{fulllineitems}

\index{bin\_strat (dalio.pipe.Bin attribute)@\spxentry{bin\_strat}\spxextra{dalio.pipe.Bin attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Bin.bin_strat}}\pysigline{\sphinxbfcode{\sphinxupquote{bin\_strat}}}
binning strategy to use. “normal”
uses the default binning strategy per a list of value separations
or number of bins. “quantile” uses a list of quantiles or a
preset quantile range (4 for quartiles and 10 for deciles).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, default “normal”

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{speed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{Bin}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{speed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   speed speed\PYGZus{}bin}
\PYG{g+go}{1     \PYGZhy{}3        \PYGZlt{}5}
\PYG{g+go}{2      4        \PYGZlt{}5}
\PYG{g+go}{3      5        5≤}
\PYG{g+go}{4      9        5≤}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{Bin}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{speed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   speed speed\PYGZus{}bin}
\PYG{g+go}{1     \PYGZhy{}3        \PYGZlt{}0}
\PYG{g+go}{2      4       0\PYGZhy{}5}
\PYG{g+go}{3      5       5\PYGZhy{}8}
\PYG{g+go}{4      9        8≤}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{MapColVals (class in dalio.pipe)@\spxentry{MapColVals}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.MapColVals}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{MapColVals}}}{\emph{value\_map}, \emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.col_generation.Custom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.Custom}}}}}

A pipeline stage that reintegrates the values of a column by a map.
\index{value\_map (dalio.pipe.MapColVals attribute)@\spxentry{value\_map}\spxextra{dalio.pipe.MapColVals attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.MapColVals.value_map}}\pysigline{\sphinxbfcode{\sphinxupquote{value\_map}}}
A dictionary mapping
existing values to new ones. Values not in the dictionary as keys
will be converted to NaN. If a function is given, it is applied
element\sphinxhyphen{}wise to given columns. If a Series is given, values are
mapped by its index to its values.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict, function or pandas.Series

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UK}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USSR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{US}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Medal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{value\PYGZus{}map} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gold}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Silver}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Bronze}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdp}\PYG{o}{.}\PYG{n}{MapColVals}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Medal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{value\PYGZus{}map}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{       Medal}
\PYG{g+go}{UK      Gold}
\PYG{g+go}{USSR  Bronze}
\PYG{g+go}{US    Silver}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{CustomByCols (class in dalio.pipe)@\spxentry{CustomByCols}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.CustomByCols}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{CustomByCols}}}{\emph{func}, \emph{*args}, \emph{strategy=\textquotesingle{}apply\textquotesingle{}}, \emph{columns=None}, \emph{new\_cols=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.col_generation.Custom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.Custom}}}}}

A pipeline stage applying a function to individual columns iteratively.
\index{func (dalio.pipe.CustomByCols attribute)@\spxentry{func}\spxextra{dalio.pipe.CustomByCols attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.CustomByCols.func}}\pysigline{\sphinxbfcode{\sphinxupquote{func}}}
The function to be applied to each element of the
given columns.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
function

\end{description}\end{quote}

\end{fulllineitems}

\index{strategy (dalio.pipe.CustomByCols attribute)@\spxentry{strategy}\spxextra{dalio.pipe.CustomByCols attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.CustomByCols.strategy}}\pysigline{\sphinxbfcode{\sphinxupquote{strategy}}}
Application strategy. Different from Custom class’
strategy parameter (which here is kept at “apply”) as this will
now be done on a series (each column). Extra care should be taken
to ensure resulting column lengths match.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{math}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{3.2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{acd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{7.2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alk}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{12.1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alk}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ph}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lbl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{round\PYGZus{}ph} \PYG{o}{=} \PYG{n}{pdp}\PYG{o}{.}\PYG{n}{ApplyByCols}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ph}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{math}\PYG{o}{.}\PYG{n}{ceil}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{round\PYGZus{}ph}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   ph  lbl}
\PYG{g+go}{1   4  acd}
\PYG{g+go}{2   8  alk}
\PYG{g+go}{3  13  alk}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Log (class in dalio.pipe)@\spxentry{Log}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Log}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{Log}}}{\emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{non\_neg=False}, \emph{const\_shift=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.col_generation.Custom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.Custom}}}}}

A pipeline stage that log\sphinxhyphen{}transforms numeric data.
\index{non\_neg (dalio.pipe.Log attribute)@\spxentry{non\_neg}\spxextra{dalio.pipe.Log attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Log.non_neg}}\pysigline{\sphinxbfcode{\sphinxupquote{non\_neg}}}
If True, each transformed column is
first shifted by smallest negative value it includes
(non\sphinxhyphen{}negative columns are thus not shifted).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool, default False

\end{description}\end{quote}

\end{fulllineitems}

\index{const\_shift (dalio.pipe.Log attribute)@\spxentry{const\_shift}\spxextra{dalio.pipe.Log attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.Log.const_shift}}\pysigline{\sphinxbfcode{\sphinxupquote{const\_shift}}}
If given, each transformed column is
first shifted by this constant. If non\_neg is True then that
transformation is applied first, and only then is the column
shifted by this constant.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, optional

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{3.2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{acd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{7.2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alk}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{12.1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alk}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ph}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lbl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{log\PYGZus{}stage} \PYG{o}{=} \PYG{n}{pdp}\PYG{o}{.}\PYG{n}{Log}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ph}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{log\PYGZus{}stage}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{         ph  lbl}
\PYG{g+go}{1  1.163151  acd}
\PYG{g+go}{2  1.974081  alk}
\PYG{g+go}{3  2.493205  alk}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{BoxCox (class in dalio.pipe)@\spxentry{BoxCox}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.BoxCox}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{BoxCox}}}{\emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{non\_neg=False}, \emph{const\_shift=None}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.col_generation.Custom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.Custom}}}}}

A pipeline stage that applies the BoxCox transformation on data.
\index{const\_shift (dalio.pipe.BoxCox attribute)@\spxentry{const\_shift}\spxextra{dalio.pipe.BoxCox attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.BoxCox.const_shift}}\pysigline{\sphinxbfcode{\sphinxupquote{const\_shift}}}
If given, each transformed column is
first shifted by this constant. If non\_neg is True then that
transformation is applied first, and only then is the column
shifted by this constant.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, optional

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StockComps (class in dalio.pipe)@\spxentry{StockComps}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.StockComps}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{StockComps}}}{\emph{strategy=\textquotesingle{}sic\_code\textquotesingle{}}, \emph{max\_ticks=6}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Get a list of a ticker’s comparable stocks

This can utilize any strategy of getting stock comparative companies and
return up to a certain ammount of comps.
\index{\_strategy (dalio.pipe.StockComps attribute)@\spxentry{\_strategy}\spxextra{dalio.pipe.StockComps attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.StockComps._strategy}}\pysigline{\sphinxbfcode{\sphinxupquote{\_strategy}}}
comparisson strategy name or function.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, callable

\end{description}\end{quote}

\end{fulllineitems}

\index{max\_ticks (dalio.pipe.StockComps attribute)@\spxentry{max\_ticks}\spxextra{dalio.pipe.StockComps attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.StockComps.max_ticks}}\pysigline{\sphinxbfcode{\sphinxupquote{max\_ticks}}}
maximum number of tickers to return.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.StockComps method)@\spxentry{copy()}\spxextra{dalio.pipe.StockComps method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.StockComps.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{max\_ticks (dalio.pipe.StockComps attribute)@\spxentry{max\_ticks}\spxextra{dalio.pipe.StockComps attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{max\_ticks}}\sphinxbfcode{\sphinxupquote{: int}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{run() (dalio.pipe.StockComps method)@\spxentry{run()}\spxextra{dalio.pipe.StockComps method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.StockComps.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets ticker argument and passes an empty ticker request to
transform.

Empty ticker requests are supposed to return all tickers available in
a source, so this allows the compariisson to be made in all stocks
from a certain source.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if ticker is more than a single symbol.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.StockComps method)@\spxentry{transform()}\spxextra{dalio.pipe.StockComps method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.StockComps.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Get comps according to the set strategy

\end{fulllineitems}


\end{fulllineitems}

\index{CovShrink (class in dalio.pipe)@\spxentry{CovShrink}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.CovShrink}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{CovShrink}}}{\emph{frequency=252}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.PipeBuilder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.PipeBuilder}}}}}

Perform Covariance Shrinkage on data

Builder with a single piece: shirnkage. Shrinkage defines what kind of
shrinkage to apply on a resultant covariance matrix. If none is set,
covariance will not be shrunk.
\index{frequency (dalio.pipe.CovShrink attribute)@\spxentry{frequency}\spxextra{dalio.pipe.CovShrink attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.CovShrink.frequency}}\pysigline{\sphinxbfcode{\sphinxupquote{frequency}}}
data time period frequency
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{build\_model() (dalio.pipe.CovShrink method)@\spxentry{build\_model()}\spxextra{dalio.pipe.CovShrink method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.CovShrink.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Builds Covariance Srhinkage object and returns selected shrinkage
strategy
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Function fitted on the data.

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_name() (dalio.pipe.CovShrink method)@\spxentry{check\_name()}\spxextra{dalio.pipe.CovShrink method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.CovShrink.check_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_name}}}{\emph{param}, \emph{name}}{}
Check if name and parameter combination is valid.

This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
\_Builder. This also can be called from outside of a \_Builder instance
to check for the validity of settings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{piece}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the key in the piece dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name option to be set to the piece.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.CovShrink method)@\spxentry{copy()}\spxextra{dalio.pipe.CovShrink method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.CovShrink.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{frequency (dalio.pipe.CovShrink attribute)@\spxentry{frequency}\spxextra{dalio.pipe.CovShrink attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{frequency}}\sphinxbfcode{\sphinxupquote{: int}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{transform() (dalio.pipe.CovShrink method)@\spxentry{transform()}\spxextra{dalio.pipe.CovShrink method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.CovShrink.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Build model using data get results.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A covariance matrix

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ExpectedReturns (class in dalio.pipe)@\spxentry{ExpectedReturns}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ExpectedReturns}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{ExpectedReturns}}}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.PipeBuilder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.PipeBuilder}}}}}

Get stock’s time series expected returns.

Builder with a single piece: return\_model. return\_model is what model to
get the expected returns from.
\index{build\_model() (dalio.pipe.ExpectedReturns method)@\spxentry{build\_model()}\spxextra{dalio.pipe.ExpectedReturns method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ExpectedReturns.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Assemble pieces into a model given some data

The data will opten be optional, but several builder models will
require it to be fitted on initialization. Which further shows why
builders are necessary for context\sphinxhyphen{}agnostic graphs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data that might be used to build the model.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} any additional argument used in building

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_name() (dalio.pipe.ExpectedReturns method)@\spxentry{check\_name()}\spxextra{dalio.pipe.ExpectedReturns method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ExpectedReturns.check_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_name}}}{\emph{param}, \emph{name}}{}
Check if name and parameter combination is valid.

This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
\_Builder. This also can be called from outside of a \_Builder instance
to check for the validity of settings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{piece}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the key in the piece dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name option to be set to the piece.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.ExpectedReturns method)@\spxentry{transform()}\spxextra{dalio.pipe.ExpectedReturns method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ExpectedReturns.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Builds model using data and gets expected returns from it

\end{fulllineitems}


\end{fulllineitems}

\index{MakeARCH (class in dalio.pipe)@\spxentry{MakeARCH}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.MakeARCH}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{MakeARCH}}}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.PipeBuilder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.PipeBuilder}}}}}

Build arch model and make it based on input data.

This class allows for the creation of arch models by configuring three
pieces: the mean, volatility and distribution. These are set after
initialization through the \_Builder interface.
\index{\_piece (dalio.pipe.MakeARCH attribute)@\spxentry{\_piece}\spxextra{dalio.pipe.MakeARCH attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.MakeARCH._piece}}\pysigline{\sphinxbfcode{\sphinxupquote{\_piece}}}
see \_Builder class.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{assimilate() (dalio.pipe.MakeARCH method)@\spxentry{assimilate()}\spxextra{dalio.pipe.MakeARCH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.MakeARCH.assimilate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{assimilate}}}{\emph{model}}{}
Assimilate core pieces of an existent ARCH Model.

Assimilation means setting this model’s’ pieces in accordance to an
existing model’s pieces. Assimilation is shallow, so only the main
pieces are assimilated, not their parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{model}} (\sphinxstyleliteralemphasis{\sphinxupquote{ARCHModel}}) \textendash{} Existing ARCH Model.

\end{description}\end{quote}

\end{fulllineitems}

\index{build\_model() (dalio.pipe.MakeARCH method)@\spxentry{build\_model()}\spxextra{dalio.pipe.MakeARCH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.MakeARCH.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Build ARCH Model using data, set pieces and their arguments
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A built arch model from the arch package.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.MakeARCH method)@\spxentry{transform()}\spxextra{dalio.pipe.MakeARCH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.MakeARCH.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Build model with sourced data

\end{fulllineitems}


\end{fulllineitems}

\index{ValueAtRisk (class in dalio.pipe)@\spxentry{ValueAtRisk}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ValueAtRisk}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{ValueAtRisk}}}{\emph{quantiles=None}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.Pipe}}}}}

Get the value at risk for data based on an ARHC Model

This takes in an ARCH Model maker, not data, which might be unintuitive,
yet necessary, as this allows users to modify the ARCH model generating
these values separately. A useful strategy that allows for this
is using a pipeline with an arch model as its first input and a
ValueAtRisk instance as its second layer. This allows us to treat the
PipeLine as a data input with VaR output and still have control over the
ARCH Model pieces (given you left a local variable for it behind.)
\index{\_quantiles (dalio.pipe.ValueAtRisk attribute)@\spxentry{\_quantiles}\spxextra{dalio.pipe.ValueAtRisk attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ValueAtRisk._quantiles}}\pysigline{\sphinxbfcode{\sphinxupquote{\_quantiles}}}
list of quantiles to check the value at risk for.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.pipe.ValueAtRisk method)@\spxentry{copy()}\spxextra{dalio.pipe.ValueAtRisk method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ValueAtRisk.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.ValueAtRisk method)@\spxentry{transform()}\spxextra{dalio.pipe.ValueAtRisk method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ValueAtRisk.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Get values at risk at each quantile and each results maximum
exedence from the mean.

The maximum exedence columns tells which quantile the loss is placed
on. The word “maximum” might be misleading as it is compared to the
minimum quantile, however, this definition is accurate as the column
essentially answers the question: “what quantile furthest away from
the mean does the data exeed?”

Thank you for the creators of the arch package for the beautiful
visualizations and ideas!
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if ARCH model does not have returns. This is often
    the case for unfitted models. Ensure your graph is complete.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if ARCH model has unsuported distribution parameter.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ExpectedShortfall (class in dalio.pipe)@\spxentry{ExpectedShortfall}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ExpectedShortfall}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{ExpectedShortfall}}}{\emph{quantiles=None}}{}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.builders.ValueAtRisk}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.builders.ValueAtRisk}}}}}

Get expected shortfal for given quantiles

See base class for more in depth explanation.
\index{transform() (dalio.pipe.ExpectedShortfall method)@\spxentry{transform()}\spxextra{dalio.pipe.ExpectedShortfall method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.ExpectedShortfall.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Get the value at risk given by an arch model and calculate the
expected shortfall at given quantiles.

\end{fulllineitems}


\end{fulllineitems}

\index{PandasLinearModel (class in dalio.pipe)@\spxentry{PandasLinearModel}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.PandasLinearModel}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{PandasLinearModel}}}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.PipeBuilder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.PipeBuilder}}}}}

Create a linear model from input pandas dataframe, using its index
as the X value.

This builder is made up of a single piece: strategy. This piece sets
which linear model should be used to fit the data.
\index{build\_model() (dalio.pipe.PandasLinearModel method)@\spxentry{build\_model()}\spxextra{dalio.pipe.PandasLinearModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.PandasLinearModel.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Build model by returning the chosen model and initialization
parameters
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Unfitted linear model

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.PandasLinearModel method)@\spxentry{transform()}\spxextra{dalio.pipe.PandasLinearModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.PandasLinearModel.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Set up fitting parameters and fit built model.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Fitted linear model

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{OptimumWeights (class in dalio.pipe)@\spxentry{OptimumWeights}\spxextra{class in dalio.pipe}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.OptimumWeights}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.}}\sphinxbfcode{\sphinxupquote{OptimumWeights}}}
Bases: {\hyperref[\detokenize{dalio.pipe:dalio.pipe.pipe.PipeBuilder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.pipe.pipe.PipeBuilder}}}}}

Get optimum portfolio weights from an efficient frontier or CLA.
This is also a builder with one piece: strategy. The strategy piece
refers to the optimization strategy.
\index{build\_model() (dalio.pipe.OptimumWeights method)@\spxentry{build\_model()}\spxextra{dalio.pipe.OptimumWeights method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.OptimumWeights.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Assemble pieces into a model given some data

The data will opten be optional, but several builder models will
require it to be fitted on initialization. Which further shows why
builders are necessary for context\sphinxhyphen{}agnostic graphs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data that might be used to build the model.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} any additional argument used in building

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_name() (dalio.pipe.OptimumWeights method)@\spxentry{check\_name()}\spxextra{dalio.pipe.OptimumWeights method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.OptimumWeights.check_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_name}}}{\emph{param}, \emph{name}}{}
Check if name and parameter combination is valid.

This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
\_Builder. This also can be called from outside of a \_Builder instance
to check for the validity of settings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{piece}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the key in the piece dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name option to be set to the piece.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (dalio.pipe.OptimumWeights method)@\spxentry{transform()}\spxextra{dalio.pipe.OptimumWeights method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.pipe:dalio.pipe.OptimumWeights.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Get efficient frontier, fit it to model and get weights

\end{fulllineitems}


\end{fulllineitems}



\subsection{dalio.model package}
\label{\detokenize{dalio.model:dalio-model-package}}\label{\detokenize{dalio.model::doc}}

\subsubsection{Submodules}
\label{\detokenize{dalio.model:submodules}}

\subsubsection{dalio.model.basic module}
\label{\detokenize{dalio.model:module-dalio.model.basic}}\label{\detokenize{dalio.model:dalio-model-basic-module}}\index{dalio.model.basic (module)@\spxentry{dalio.model.basic}\spxextra{module}}
Define basic models
\index{Join (class in dalio.model.basic)@\spxentry{Join}\spxextra{class in dalio.model.basic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.basic.Join}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.basic.}}\sphinxbfcode{\sphinxupquote{Join}}}{\emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}

Join two dataframes on index.

This model has two sources: left and right.
\index{\_kwargs (dalio.model.basic.Join attribute)@\spxentry{\_kwargs}\spxextra{dalio.model.basic.Join attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.basic.Join._kwargs}}\pysigline{\sphinxbfcode{\sphinxupquote{\_kwargs}}}
optional keyword arguments for pd.join
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.model.basic.Join method)@\spxentry{run()}\spxextra{dalio.model.basic.Join method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.basic.Join.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get left and right side data and join

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.model.financial module}
\label{\detokenize{dalio.model:module-dalio.model.financial}}\label{\detokenize{dalio.model:dalio-model-financial-module}}\index{dalio.model.financial (module)@\spxentry{dalio.model.financial}\spxextra{module}}
Define comps analysis models
\index{CompsData (class in dalio.model.financial)@\spxentry{CompsData}\spxextra{class in dalio.model.financial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.CompsData}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.financial.}}\sphinxbfcode{\sphinxupquote{CompsData}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}

Get a ticker’s comps and their data.

This model has two sources: comps\_in and data\_in. comps\_in gets a
ticker’s comparative stocks. data\_in sources ticker data given a “TICKER”
keyword argument.
\index{run() (dalio.model.financial.CompsData method)@\spxentry{run()}\spxextra{dalio.model.financial.CompsData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.CompsData.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Run model.

This will be the bulk of subclass functionality. It is where all
data is sourced and processed.

\end{fulllineitems}


\end{fulllineitems}

\index{CompsFinancials (class in dalio.model.financial)@\spxentry{CompsFinancials}\spxextra{class in dalio.model.financial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.CompsFinancials}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.financial.}}\sphinxbfcode{\sphinxupquote{CompsFinancials}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.financial.CompsData}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.financial.CompsData}}}}}

Subclass to CompsData for getting stock price information

\end{fulllineitems}

\index{CompsInfo (class in dalio.model.financial)@\spxentry{CompsInfo}\spxextra{class in dalio.model.financial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.CompsInfo}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.financial.}}\sphinxbfcode{\sphinxupquote{CompsInfo}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.financial.CompsData}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.financial.CompsData}}}}}

Subclass to CompsData for getting comps stock information

\end{fulllineitems}

\index{MakeCriticalLine (class in dalio.model.financial)@\spxentry{MakeCriticalLine}\spxextra{class in dalio.model.financial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeCriticalLine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.financial.}}\sphinxbfcode{\sphinxupquote{MakeCriticalLine}}}{\emph{weight\_bounds=(\sphinxhyphen{}1}, \emph{1)}}{}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}

Fit a critical line algorithm
This model takes in two sources: sample\_covariance and expected\_returns.
These are self\sphinxhyphen{}explanatory. The model calculates the algorithm for a set
of weight bounds.
.. attribute:: weight\_bounds
\begin{quote}

lower and upper bound for portfolio weights.
\begin{quote}\begin{description}
\item[{type}] \leavevmode
tuple

\end{description}\end{quote}
\end{quote}
\index{run() (dalio.model.financial.MakeCriticalLine method)@\spxentry{run()}\spxextra{dalio.model.financial.MakeCriticalLine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeCriticalLine.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get source data and create critical line algorithm

\end{fulllineitems}

\index{weight\_bounds (dalio.model.financial.MakeCriticalLine attribute)@\spxentry{weight\_bounds}\spxextra{dalio.model.financial.MakeCriticalLine attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeCriticalLine.weight_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{weight\_bounds}}\sphinxbfcode{\sphinxupquote{: Tuple{[}int{]}}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}

\index{MakeEfficientFrontier (class in dalio.model.financial)@\spxentry{MakeEfficientFrontier}\spxextra{class in dalio.model.financial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.financial.}}\sphinxbfcode{\sphinxupquote{MakeEfficientFrontier}}}{\emph{weight\_bounds=(0}, \emph{1)}, \emph{gamma=0}}{}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.financial.MakeCriticalLine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.financial.MakeCriticalLine}}}}}

Make an efficient frontier algorithm.
:param gamma: gamma optimization parameter.
:type gamma: int
\index{add\_constraint() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{add\_constraint()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.add_constraint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_constraint}}}{\emph{new\_constraint}}{}
Wrapper to PyPortfolioOpt BaseConvexOptimizer function
Add a new constraint to the optimisation problem. This constraint must
be linear and must be either an equality or simple inequality.
:param new\_constraint: the constraint to be added
:type new\_constraint: callable
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{AttributeError}} \textendash{} if new objective is not callable.

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_objective() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{add\_objective()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.add_objective}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_objective}}}{\emph{new\_objective}, \emph{*args}, \emph{**kwargs}}{}
Wrapper to PyPortfolioOpt BaseConvexOptimizer function
Add a new term into the objective function. This term must be convex,
and built from cvxpy atomic functions.
:param new\_objective: the objective to be added
:type new\_objective: cp.Expression
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if the new objective is not supported.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{AttributeError}} \textendash{} if new objective is not callable.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_sector\_definitions() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{add\_sector\_definitions()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.add_sector_definitions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_sector\_definitions}}}{\emph{sector\_defs=None}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{add\_sector\_weight\_constraint() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{add\_sector\_weight\_constraint()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.add_sector_weight_constraint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_sector\_weight\_constraint}}}{\emph{sector=None}, \emph{constraint=\textquotesingle{}is\textquotesingle{}}, \emph{weight=0.5}}{}
\end{fulllineitems}

\index{add\_stock\_weight\_constraint() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{add\_stock\_weight\_constraint()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.add_stock_weight_constraint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_stock\_weight\_constraint}}}{\emph{ticker=None}, \emph{comparisson=\textquotesingle{}is\textquotesingle{}}, \emph{weight=0.5}}{}
Wrapper to add\_constraint method. Adds constraing on a named
ticker.
This is a much more intuitive interface to add constraints, as these
will often be stocks of an unknown order in a dataframe.
:param ticker: stock ticker or location to be constrained.
:type ticker: str, int
:param comparisson: constraing comparisson.
:type comparisson: str
:param weight: weight to constrain.
:type weight: float
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if any of the arguments are of an invalid type

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{copy()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Copy superclass, objectives and constraints.

\end{fulllineitems}

\index{gamma (dalio.model.financial.MakeEfficientFrontier attribute)@\spxentry{gamma}\spxextra{dalio.model.financial.MakeEfficientFrontier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.gamma}}\pysigline{\sphinxbfcode{\sphinxupquote{gamma}}\sphinxbfcode{\sphinxupquote{: int}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{run() (dalio.model.financial.MakeEfficientFrontier method)@\spxentry{run()}\spxextra{dalio.model.financial.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Make efficient frontier.
Create efficient frontier given a set of weight constraints.

\end{fulllineitems}

\index{weight\_bounds (dalio.model.financial.MakeEfficientFrontier attribute)@\spxentry{weight\_bounds}\spxextra{dalio.model.financial.MakeEfficientFrontier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.MakeEfficientFrontier.weight_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{weight\_bounds}}\sphinxbfcode{\sphinxupquote{: Tuple{[}int{]}}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}

\index{OptimumPortfolio (class in dalio.model.financial)@\spxentry{OptimumPortfolio}\spxextra{class in dalio.model.financial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.OptimumPortfolio}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.financial.}}\sphinxbfcode{\sphinxupquote{OptimumPortfolio}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}

Create optimum portfolio of stocks given dictionary of weights.
This model has two sources: weights\_in and data\_in. The weights\_in source
gets optimum weights for a set of tickers. The data\_in source gets price
data for these same tickers.
\index{run() (dalio.model.financial.OptimumPortfolio method)@\spxentry{run()}\spxextra{dalio.model.financial.OptimumPortfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.financial.OptimumPortfolio.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets weights and uses them to create portfolio prices if weights
were kept constant.

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.model.model module}
\label{\detokenize{dalio.model:module-dalio.model.model}}\label{\detokenize{dalio.model:dalio-model-model-module}}\index{dalio.model.model (module)@\spxentry{dalio.model.model}\spxextra{module}}
Define Model class

Models are transformers that take in multiple inputs and has a single output.
Model instance can be much more flexible with additional options for differen
strategies of data processing and collection.
\index{Model (class in dalio.model.model)@\spxentry{Model}\spxextra{class in dalio.model.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.model.Model}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.model.}}\sphinxbfcode{\sphinxupquote{Model}}}
Bases: \sphinxcode{\sphinxupquote{dalio.base.transformer.\_Transformer}}

Models represent data modification with multiple internal inputs and a
single internal output.
\index{\_source (dalio.model.model.Model attribute)@\spxentry{\_source}\spxextra{dalio.model.model.Model attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.model.Model._source}}\pysigline{\sphinxbfcode{\sphinxupquote{\_source}}}
dictionary of input data definitions

\end{fulllineitems}

\index{copy() (dalio.model.model.Model method)@\spxentry{copy()}\spxextra{dalio.model.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.model.Model.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.model.model.Model method)@\spxentry{run()}\spxextra{dalio.model.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.model.Model.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Run model.

This will be the bulk of subclass functionality. It is where all
data is sourced and processed.

\end{fulllineitems}

\index{set\_input() (dalio.model.model.Model method)@\spxentry{set\_input()}\spxextra{dalio.model.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.model.Model.set_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_input}}}{\emph{source\_name}, \emph{new\_input}}{}
Set a new connection to a data definition in dictionary entry
matching the key name.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} initialized item in sources dict.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_input}} \textendash{} new source connection.

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{Raise:}] \leavevmode
KeyError: if input name is not present in sources dict.

\end{description}

\end{fulllineitems}

\index{with\_input() (dalio.model.model.Model method)@\spxentry{with\_input()}\spxextra{dalio.model.model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.model.Model.with_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{with\_input}}}{\emph{source\_name}, \emph{new\_input}}{}
Return a copy of this model with the specified data definition
connection changed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} initialized item in sources dict.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_input}} \textendash{} new source connection.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.model.statistical module}
\label{\detokenize{dalio.model:module-dalio.model.statistical}}\label{\detokenize{dalio.model:dalio-model-statistical-module}}\index{dalio.model.statistical (module)@\spxentry{dalio.model.statistical}\spxextra{module}}
Define statistical models
\index{XYLinearModel (class in dalio.model.statistical)@\spxentry{XYLinearModel}\spxextra{class in dalio.model.statistical}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.statistical.XYLinearModel}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.statistical.}}\sphinxbfcode{\sphinxupquote{XYLinearModel}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}, \sphinxcode{\sphinxupquote{dalio.base.builder.\_Builder}}

Generalized Linear model for arrays from two sources.

This Model has two sources, x and y.

This Builder has one piece. the linear model strategy.
\index{build\_model() (dalio.model.statistical.XYLinearModel method)@\spxentry{build\_model()}\spxextra{dalio.model.statistical.XYLinearModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.statistical.XYLinearModel.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Build model by returning the chosen model and initialization
parameters
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Unfitted linear model

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.model.statistical.XYLinearModel method)@\spxentry{copy()}\spxextra{dalio.model.statistical.XYLinearModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.statistical.XYLinearModel.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.model.statistical.XYLinearModel method)@\spxentry{run()}\spxextra{dalio.model.statistical.XYLinearModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.statistical.XYLinearModel.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get data from both sources, transform them into np.arrays and
fit the built model

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Module contents}
\label{\detokenize{dalio.model:module-dalio.model}}\label{\detokenize{dalio.model:module-contents}}\index{dalio.model (module)@\spxentry{dalio.model}\spxextra{module}}\index{Join (class in dalio.model)@\spxentry{Join}\spxextra{class in dalio.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.Join}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.}}\sphinxbfcode{\sphinxupquote{Join}}}{\emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}

Join two dataframes on index.

This model has two sources: left and right.
\index{\_kwargs (dalio.model.Join attribute)@\spxentry{\_kwargs}\spxextra{dalio.model.Join attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.Join._kwargs}}\pysigline{\sphinxbfcode{\sphinxupquote{\_kwargs}}}
optional keyword arguments for pd.join
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.model.Join method)@\spxentry{run()}\spxextra{dalio.model.Join method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.Join.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get left and right side data and join

\end{fulllineitems}


\end{fulllineitems}

\index{CompsData (class in dalio.model)@\spxentry{CompsData}\spxextra{class in dalio.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.CompsData}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.}}\sphinxbfcode{\sphinxupquote{CompsData}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}

Get a ticker’s comps and their data.

This model has two sources: comps\_in and data\_in. comps\_in gets a
ticker’s comparative stocks. data\_in sources ticker data given a “TICKER”
keyword argument.
\index{run() (dalio.model.CompsData method)@\spxentry{run()}\spxextra{dalio.model.CompsData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.CompsData.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Run model.

This will be the bulk of subclass functionality. It is where all
data is sourced and processed.

\end{fulllineitems}


\end{fulllineitems}

\index{CompsFinancials (class in dalio.model)@\spxentry{CompsFinancials}\spxextra{class in dalio.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.CompsFinancials}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.}}\sphinxbfcode{\sphinxupquote{CompsFinancials}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.financial.CompsData}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.financial.CompsData}}}}}

Subclass to CompsData for getting stock price information

\end{fulllineitems}

\index{CompsInfo (class in dalio.model)@\spxentry{CompsInfo}\spxextra{class in dalio.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.CompsInfo}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.}}\sphinxbfcode{\sphinxupquote{CompsInfo}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.financial.CompsData}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.financial.CompsData}}}}}

Subclass to CompsData for getting comps stock information

\end{fulllineitems}

\index{MakeCriticalLine (class in dalio.model)@\spxentry{MakeCriticalLine}\spxextra{class in dalio.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.MakeCriticalLine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.}}\sphinxbfcode{\sphinxupquote{MakeCriticalLine}}}{\emph{weight\_bounds=(\sphinxhyphen{}1}, \emph{1)}}{}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}

Fit a critical line algorithm
This model takes in two sources: sample\_covariance and expected\_returns.
These are self\sphinxhyphen{}explanatory. The model calculates the algorithm for a set
of weight bounds.
.. attribute:: weight\_bounds
\begin{quote}

lower and upper bound for portfolio weights.
\begin{quote}\begin{description}
\item[{type}] \leavevmode
tuple

\end{description}\end{quote}
\end{quote}
\index{run() (dalio.model.MakeCriticalLine method)@\spxentry{run()}\spxextra{dalio.model.MakeCriticalLine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.MakeCriticalLine.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get source data and create critical line algorithm

\end{fulllineitems}

\index{weight\_bounds (dalio.model.MakeCriticalLine attribute)@\spxentry{weight\_bounds}\spxextra{dalio.model.MakeCriticalLine attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.MakeCriticalLine.weight_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{weight\_bounds}}\sphinxbfcode{\sphinxupquote{: Tuple{[}int{]}}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}

\index{MakeEfficientFrontier (class in dalio.model)@\spxentry{MakeEfficientFrontier}\spxextra{class in dalio.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.MakeEfficientFrontier}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.}}\sphinxbfcode{\sphinxupquote{MakeEfficientFrontier}}}{\emph{weight\_bounds=(0}, \emph{1)}, \emph{gamma=0}}{}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.financial.MakeCriticalLine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.financial.MakeCriticalLine}}}}}

Make an efficient frontier algorithm.
:param gamma: gamma optimization parameter.
:type gamma: int
\index{add\_constraint() (dalio.model.MakeEfficientFrontier method)@\spxentry{add\_constraint()}\spxextra{dalio.model.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.MakeEfficientFrontier.add_constraint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_constraint}}}{\emph{new\_constraint}}{}
Wrapper to PyPortfolioOpt BaseConvexOptimizer function
Add a new constraint to the optimisation problem. This constraint must
be linear and must be either an equality or simple inequality.
:param new\_constraint: the constraint to be added
:type new\_constraint: callable
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{AttributeError}} \textendash{} if new objective is not callable.

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_objective() (dalio.model.MakeEfficientFrontier method)@\spxentry{add\_objective()}\spxextra{dalio.model.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.MakeEfficientFrontier.add_objective}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_objective}}}{\emph{new\_objective}, \emph{*args}, \emph{**kwargs}}{}
Wrapper to PyPortfolioOpt BaseConvexOptimizer function
Add a new term into the objective function. This term must be convex,
and built from cvxpy atomic functions.
:param new\_objective: the objective to be added
:type new\_objective: cp.Expression
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if the new objective is not supported.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{AttributeError}} \textendash{} if new objective is not callable.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_sector\_definitions() (dalio.model.MakeEfficientFrontier method)@\spxentry{add\_sector\_definitions()}\spxextra{dalio.model.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.MakeEfficientFrontier.add_sector_definitions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_sector\_definitions}}}{\emph{sector\_defs=None}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{add\_sector\_weight\_constraint() (dalio.model.MakeEfficientFrontier method)@\spxentry{add\_sector\_weight\_constraint()}\spxextra{dalio.model.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.MakeEfficientFrontier.add_sector_weight_constraint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_sector\_weight\_constraint}}}{\emph{sector=None}, \emph{constraint=\textquotesingle{}is\textquotesingle{}}, \emph{weight=0.5}}{}
\end{fulllineitems}

\index{add\_stock\_weight\_constraint() (dalio.model.MakeEfficientFrontier method)@\spxentry{add\_stock\_weight\_constraint()}\spxextra{dalio.model.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.MakeEfficientFrontier.add_stock_weight_constraint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_stock\_weight\_constraint}}}{\emph{ticker=None}, \emph{comparisson=\textquotesingle{}is\textquotesingle{}}, \emph{weight=0.5}}{}
Wrapper to add\_constraint method. Adds constraing on a named
ticker.
This is a much more intuitive interface to add constraints, as these
will often be stocks of an unknown order in a dataframe.
:param ticker: stock ticker or location to be constrained.
:type ticker: str, int
:param comparisson: constraing comparisson.
:type comparisson: str
:param weight: weight to constrain.
:type weight: float
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if any of the arguments are of an invalid type

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.model.MakeEfficientFrontier method)@\spxentry{copy()}\spxextra{dalio.model.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.MakeEfficientFrontier.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Copy superclass, objectives and constraints.

\end{fulllineitems}

\index{gamma (dalio.model.MakeEfficientFrontier attribute)@\spxentry{gamma}\spxextra{dalio.model.MakeEfficientFrontier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.MakeEfficientFrontier.gamma}}\pysigline{\sphinxbfcode{\sphinxupquote{gamma}}\sphinxbfcode{\sphinxupquote{: int}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{run() (dalio.model.MakeEfficientFrontier method)@\spxentry{run()}\spxextra{dalio.model.MakeEfficientFrontier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.MakeEfficientFrontier.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Make efficient frontier.
Create efficient frontier given a set of weight constraints.

\end{fulllineitems}

\index{weight\_bounds (dalio.model.MakeEfficientFrontier attribute)@\spxentry{weight\_bounds}\spxextra{dalio.model.MakeEfficientFrontier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.MakeEfficientFrontier.weight_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{weight\_bounds}}\sphinxbfcode{\sphinxupquote{: Tuple{[}int{]}}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}


\end{fulllineitems}

\index{OptimumPortfolio (class in dalio.model)@\spxentry{OptimumPortfolio}\spxextra{class in dalio.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.OptimumPortfolio}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.}}\sphinxbfcode{\sphinxupquote{OptimumPortfolio}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}

Create optimum portfolio of stocks given dictionary of weights.
This model has two sources: weights\_in and data\_in. The weights\_in source
gets optimum weights for a set of tickers. The data\_in source gets price
data for these same tickers.
\index{run() (dalio.model.OptimumPortfolio method)@\spxentry{run()}\spxextra{dalio.model.OptimumPortfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.OptimumPortfolio.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets weights and uses them to create portfolio prices if weights
were kept constant.

\end{fulllineitems}


\end{fulllineitems}

\index{XYLinearModel (class in dalio.model)@\spxentry{XYLinearModel}\spxextra{class in dalio.model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.XYLinearModel}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.model.}}\sphinxbfcode{\sphinxupquote{XYLinearModel}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}, \sphinxcode{\sphinxupquote{dalio.base.builder.\_Builder}}

Generalized Linear model for arrays from two sources.

This Model has two sources, x and y.

This Builder has one piece. the linear model strategy.
\index{build\_model() (dalio.model.XYLinearModel method)@\spxentry{build\_model()}\spxextra{dalio.model.XYLinearModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.XYLinearModel.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Build model by returning the chosen model and initialization
parameters
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Unfitted linear model

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.model.XYLinearModel method)@\spxentry{copy()}\spxextra{dalio.model.XYLinearModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.XYLinearModel.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.model.XYLinearModel method)@\spxentry{run()}\spxextra{dalio.model.XYLinearModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.model:dalio.model.XYLinearModel.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get data from both sources, transform them into np.arrays and
fit the built model

\end{fulllineitems}


\end{fulllineitems}



\subsection{dalio.application package}
\label{\detokenize{dalio.application:dalio-application-package}}\label{\detokenize{dalio.application::doc}}

\subsubsection{Submodules}
\label{\detokenize{dalio.application:submodules}}

\subsubsection{dalio.application.application module}
\label{\detokenize{dalio.application:module-dalio.application.application}}\label{\detokenize{dalio.application:dalio-application-application-module}}\index{dalio.application.application (module)@\spxentry{dalio.application.application}\spxextra{module}}
Define the Application class

While Models are normally the last stage of the processing chain, it
still has a single output, which might have limited value in itself.
Applications are tools used for the interpretation of some input and
outisde outputs. These can have a broad range of uses, from graphing to
real\sphinxhyphen{}time trading. The main functionality is in the .run() method, which
gets input data and interprets it as needed.
\index{Application (class in dalio.application.application)@\spxentry{Application}\spxextra{class in dalio.application.application}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.application.Application}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.application.}}\sphinxbfcode{\sphinxupquote{Application}}}
Bases: {\hyperref[\detokenize{dalio.model:dalio.model.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.model.model.Model}}}}}

Represent final representation of graph data through external entities.

Applications are transformations with one or more internal inputs and one
or more external outputs.
\index{\_out (dalio.application.application.Application attribute)@\spxentry{\_out}\spxextra{dalio.application.application.Application attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.application.Application._out}}\pysigline{\sphinxbfcode{\sphinxupquote{\_out}}}
dictionary of outisde output connections
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (dalio.application.application.Application method)@\spxentry{copy()}\spxextra{dalio.application.application.Application method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.application.Application.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Makes a copy of transformer, copying its attributes to a new
instance.

This copy should essentially create a new transformation node, not an
entire new graph, so the \_source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Positional arguments to be passed to initialize copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keyword arguments to be passed to initialize copy

\end{itemize}

\item[{Returns}] \leavevmode
A copy of this \_Transformer instance with copies of necessary
attributes and empty input.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.application.application.Application method)@\spxentry{run()}\spxextra{dalio.application.application.Application method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.application.Application.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Run application.

This will be the bulk of subclass functionality. It is where all
data is sourced, processed and output.

\end{fulllineitems}

\index{set\_output() (dalio.application.application.Application method)@\spxentry{set\_output()}\spxextra{dalio.application.application.Application method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.application.Application.set_output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_output}}}{\emph{output\_name}, \emph{new\_output}}{}
Set a new output to data definition in dictionary entry
matching the name
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the name of the output from the output dict.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_output}} \textendash{} new External source to be set as the output.

\end{itemize}

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} if name is not in the output dict.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if the new output is not an instance of External.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{with\_output() (dalio.application.application.Application method)@\spxentry{with\_output()}\spxextra{dalio.application.application.Application method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.application.Application.with_output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{with\_output}}}{\emph{output\_name}, \emph{new\_output}}{}
Return a copy of this model with the specified data definition
output changed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the name of the output from the output dict.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_output}} \textendash{} new External source to be set as the output.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.application.graphers module}
\label{\detokenize{dalio.application:module-dalio.application.graphers}}\label{\detokenize{dalio.application:dalio-application-graphers-module}}\index{dalio.application.graphers (module)@\spxentry{dalio.application.graphers}\spxextra{module}}
Applications based on graphing input data
\index{ForecastGrapher (class in dalio.application.graphers)@\spxentry{ForecastGrapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.ForecastGrapher}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{ForecastGrapher}}}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.Grapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.Grapher}}}}}

Application to graph data and a forecast horizon

This Application has two sources data\_in and forecast\_in. The data\sphinxhyphen{}in
source is explained in Grapher. The forecast\_in source gets a forecast
data to be graphed.
\index{run() (dalio.application.graphers.ForecastGrapher method)@\spxentry{run()}\spxextra{dalio.application.graphers.ForecastGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.ForecastGrapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get data, its forecast and plot both

\end{fulllineitems}


\end{fulllineitems}

\index{Grapher (class in dalio.application.graphers)@\spxentry{Grapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.Grapher}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{Grapher}}}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.application.Application}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.application.Application}}}}}

Base grapher class.

Does basic graphing, assuming data does not require any processing before
being passed onto an external grapher.

This Application has one source: data\_in. The data\_in source gets
internal data to be graphed.

This Application has one output: data\_out. The data\_out output represents
an external graph.
\index{reset\_out() (dalio.application.graphers.Grapher method)@\spxentry{reset\_out()}\spxextra{dalio.application.graphers.Grapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.Grapher.reset_out}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset\_out}}}{}{}
Reset the output graph. Figure instances should implement the
.reset() method.

\end{fulllineitems}

\index{run() (dalio.application.graphers.Grapher method)@\spxentry{run()}\spxextra{dalio.application.graphers.Grapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.Grapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets data input and plots it

\end{fulllineitems}


\end{fulllineitems}

\index{LMGrapher (class in dalio.application.graphers)@\spxentry{LMGrapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.LMGrapher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{LMGrapher}}}{\emph{x=None}, \emph{y=None}, \emph{legend=None}}{}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.PandasXYGrapher}}}}}

Application to graph data and a linear model fitted to it.

This Application has two sources data\_in and linear\_model. The data\sphinxhyphen{}in
source is explained in Grapher. The linear\_model source is a fitted
linear model with intercept and coefficient data.
\index{\_legend (dalio.application.graphers.LMGrapher attribute)@\spxentry{\_legend}\spxextra{dalio.application.graphers.LMGrapher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.LMGrapher._legend}}\pysigline{\sphinxbfcode{\sphinxupquote{\_legend}}}
legend position on graph.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, None

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.application.graphers.LMGrapher method)@\spxentry{run()}\spxextra{dalio.application.graphers.LMGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.LMGrapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get data, its fitted coefficients and intercepts and graph them.

\end{fulllineitems}


\end{fulllineitems}

\index{MultiGrapher (class in dalio.application.graphers)@\spxentry{MultiGrapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.MultiGrapher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{MultiGrapher}}}{\emph{rows}, \emph{cols}}{}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.application.Application}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.application.Application}}}}}, \sphinxcode{\sphinxupquote{dalio.base.builder.\_Builder}}

Grapher for multiple inputs taking in the same keyword arguments.

This is useful to greate subplots of the same data processed in
different ways. Sources are the data inputs and pieces are their kinds,
args and kwargs.

This applicaiton can N sources and pieces, where N is the total number of
graphs.
\index{build\_model() (dalio.application.graphers.MultiGrapher method)@\spxentry{build\_model()}\spxextra{dalio.application.graphers.MultiGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.MultiGrapher.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Return data unprocessed

\end{fulllineitems}

\index{run() (dalio.application.graphers.MultiGrapher method)@\spxentry{run()}\spxextra{dalio.application.graphers.MultiGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.MultiGrapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets data input from each source and plots it using the set
information in each piece

\end{fulllineitems}


\end{fulllineitems}

\index{PandasMultiGrapher (class in dalio.application.graphers)@\spxentry{PandasMultiGrapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasMultiGrapher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{PandasMultiGrapher}}}{\emph{rows}, \emph{cols}}{}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.MultiGrapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.MultiGrapher}}}}}

Multigrapher with column selection mechanisms

In this MultiGrapher, you can select any x, y and z columns as piece
kwargs and they will be interpreted during the run. Keep in mind that
this allows for any combination of these layered one on top of each other
regardless of name. If you specify an “x” and a “z”, the “z” column will
be treated like a “y” column.

There are also no interpretations of what
is to be graphed, and thus all wanted columns should be specified.

There is one case for indexes, where the x\_index, y\_index or z\_index
keyword arguments can be set to True.
\index{build\_model() (dalio.application.graphers.PandasMultiGrapher method)@\spxentry{build\_model()}\spxextra{dalio.application.graphers.PandasMultiGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasMultiGrapher.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Process data columns

\end{fulllineitems}


\end{fulllineitems}

\index{PandasTSGrapher (class in dalio.application.graphers)@\spxentry{PandasTSGrapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasTSGrapher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{PandasTSGrapher}}}{\emph{y=None}, \emph{legend=None}}{}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.PandasXYGrapher}}}}}

Graphs a pandas time series

Same functionality as parent class with stricter inputs.

\end{fulllineitems}

\index{PandasXYGrapher (class in dalio.application.graphers)@\spxentry{PandasXYGrapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{PandasXYGrapher}}}{\emph{x=None}, \emph{y=None}, \emph{legend=None}}{}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.Grapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.Grapher}}}}}

Graph data from a pandas dataframe with option of selecting columns
used as axis
\index{\_x (dalio.application.graphers.PandasXYGrapher attribute)@\spxentry{\_x}\spxextra{dalio.application.graphers.PandasXYGrapher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher._x}}\pysigline{\sphinxbfcode{\sphinxupquote{\_x}}}
name of column to be used for x\sphinxhyphen{}axis.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_y (dalio.application.graphers.PandasXYGrapher attribute)@\spxentry{\_y}\spxextra{dalio.application.graphers.PandasXYGrapher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher._y}}\pysigline{\sphinxbfcode{\sphinxupquote{\_y}}}
name of column to be used for y\sphinxhyphen{}axis.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_legend (dalio.application.graphers.PandasXYGrapher attribute)@\spxentry{\_legend}\spxextra{dalio.application.graphers.PandasXYGrapher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher._legend}}\pysigline{\sphinxbfcode{\sphinxupquote{\_legend}}}
legend position. None by default
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, None

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.application.graphers.PandasXYGrapher method)@\spxentry{run()}\spxextra{dalio.application.graphers.PandasXYGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get data, separate columns and feed it to data output graph

\end{fulllineitems}


\end{fulllineitems}

\index{VaRGrapher (class in dalio.application.graphers)@\spxentry{VaRGrapher}\spxextra{class in dalio.application.graphers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.VaRGrapher}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.graphers.}}\sphinxbfcode{\sphinxupquote{VaRGrapher}}}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.Grapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.Grapher}}}}}

Application to visualize Value at Risk
\index{run() (dalio.application.graphers.VaRGrapher method)@\spxentry{run()}\spxextra{dalio.application.graphers.VaRGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.graphers.VaRGrapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get value at risk data, plot returns, value at risk lines and
exceptions at their maximum exedence.

Thank you for the creators of the arch package for the amazing
visulaization idea!

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.application.printers module}
\label{\detokenize{dalio.application:module-dalio.application.printers}}\label{\detokenize{dalio.application:dalio-application-printers-module}}\index{dalio.application.printers (module)@\spxentry{dalio.application.printers}\spxextra{module}}
Print data onto an external output
\index{FilePrinter (class in dalio.application.printers)@\spxentry{FilePrinter}\spxextra{class in dalio.application.printers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.printers.FilePrinter}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.printers.}}\sphinxbfcode{\sphinxupquote{FilePrinter}}}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.application.Application}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.application.Application}}}}}

Application to print data onto a file

This application has one source: data\_in. The data\_in source is the data
to be printed.

This application has one output: data\_out. The data\_out output is the
external output to print the data to.
\index{run() (dalio.application.printers.FilePrinter method)@\spxentry{run()}\spxextra{dalio.application.printers.FilePrinter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.printers.FilePrinter.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets data and prints it

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Module contents}
\label{\detokenize{dalio.application:module-dalio.application}}\label{\detokenize{dalio.application:module-contents}}\index{dalio.application (module)@\spxentry{dalio.application}\spxextra{module}}\index{FilePrinter (class in dalio.application)@\spxentry{FilePrinter}\spxextra{class in dalio.application}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.FilePrinter}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.}}\sphinxbfcode{\sphinxupquote{FilePrinter}}}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.application.Application}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.application.Application}}}}}

Application to print data onto a file

This application has one source: data\_in. The data\_in source is the data
to be printed.

This application has one output: data\_out. The data\_out output is the
external output to print the data to.
\index{run() (dalio.application.FilePrinter method)@\spxentry{run()}\spxextra{dalio.application.FilePrinter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.FilePrinter.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets data and prints it

\end{fulllineitems}


\end{fulllineitems}

\index{Grapher (class in dalio.application)@\spxentry{Grapher}\spxextra{class in dalio.application}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.Grapher}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.}}\sphinxbfcode{\sphinxupquote{Grapher}}}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.application.Application}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.application.Application}}}}}

Base grapher class.

Does basic graphing, assuming data does not require any processing before
being passed onto an external grapher.

This Application has one source: data\_in. The data\_in source gets
internal data to be graphed.

This Application has one output: data\_out. The data\_out output represents
an external graph.
\index{reset\_out() (dalio.application.Grapher method)@\spxentry{reset\_out()}\spxextra{dalio.application.Grapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.Grapher.reset_out}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset\_out}}}{}{}
Reset the output graph. Figure instances should implement the
.reset() method.

\end{fulllineitems}

\index{run() (dalio.application.Grapher method)@\spxentry{run()}\spxextra{dalio.application.Grapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.Grapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets data input and plots it

\end{fulllineitems}


\end{fulllineitems}

\index{MultiGrapher (class in dalio.application)@\spxentry{MultiGrapher}\spxextra{class in dalio.application}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.MultiGrapher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.}}\sphinxbfcode{\sphinxupquote{MultiGrapher}}}{\emph{rows}, \emph{cols}}{}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.application.Application}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.application.Application}}}}}, \sphinxcode{\sphinxupquote{dalio.base.builder.\_Builder}}

Grapher for multiple inputs taking in the same keyword arguments.

This is useful to greate subplots of the same data processed in
different ways. Sources are the data inputs and pieces are their kinds,
args and kwargs.

This applicaiton can N sources and pieces, where N is the total number of
graphs.
\index{build\_model() (dalio.application.MultiGrapher method)@\spxentry{build\_model()}\spxextra{dalio.application.MultiGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.MultiGrapher.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Return data unprocessed

\end{fulllineitems}

\index{run() (dalio.application.MultiGrapher method)@\spxentry{run()}\spxextra{dalio.application.MultiGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.MultiGrapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Gets data input from each source and plots it using the set
information in each piece

\end{fulllineitems}


\end{fulllineitems}

\index{PandasXYGrapher (class in dalio.application)@\spxentry{PandasXYGrapher}\spxextra{class in dalio.application}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.PandasXYGrapher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.}}\sphinxbfcode{\sphinxupquote{PandasXYGrapher}}}{\emph{x=None}, \emph{y=None}, \emph{legend=None}}{}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.Grapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.Grapher}}}}}

Graph data from a pandas dataframe with option of selecting columns
used as axis
\index{\_x (dalio.application.PandasXYGrapher attribute)@\spxentry{\_x}\spxextra{dalio.application.PandasXYGrapher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.PandasXYGrapher._x}}\pysigline{\sphinxbfcode{\sphinxupquote{\_x}}}
name of column to be used for x\sphinxhyphen{}axis.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_y (dalio.application.PandasXYGrapher attribute)@\spxentry{\_y}\spxextra{dalio.application.PandasXYGrapher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.PandasXYGrapher._y}}\pysigline{\sphinxbfcode{\sphinxupquote{\_y}}}
name of column to be used for y\sphinxhyphen{}axis.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_legend (dalio.application.PandasXYGrapher attribute)@\spxentry{\_legend}\spxextra{dalio.application.PandasXYGrapher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.PandasXYGrapher._legend}}\pysigline{\sphinxbfcode{\sphinxupquote{\_legend}}}
legend position. None by default
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, None

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.application.PandasXYGrapher method)@\spxentry{run()}\spxextra{dalio.application.PandasXYGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.PandasXYGrapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get data, separate columns and feed it to data output graph

\end{fulllineitems}


\end{fulllineitems}

\index{PandasTSGrapher (class in dalio.application)@\spxentry{PandasTSGrapher}\spxextra{class in dalio.application}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.PandasTSGrapher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.}}\sphinxbfcode{\sphinxupquote{PandasTSGrapher}}}{\emph{y=None}, \emph{legend=None}}{}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.PandasXYGrapher}}}}}

Graphs a pandas time series

Same functionality as parent class with stricter inputs.

\end{fulllineitems}

\index{PandasMultiGrapher (class in dalio.application)@\spxentry{PandasMultiGrapher}\spxextra{class in dalio.application}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.PandasMultiGrapher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.}}\sphinxbfcode{\sphinxupquote{PandasMultiGrapher}}}{\emph{rows}, \emph{cols}}{}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.MultiGrapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.MultiGrapher}}}}}

Multigrapher with column selection mechanisms

In this MultiGrapher, you can select any x, y and z columns as piece
kwargs and they will be interpreted during the run. Keep in mind that
this allows for any combination of these layered one on top of each other
regardless of name. If you specify an “x” and a “z”, the “z” column will
be treated like a “y” column.

There are also no interpretations of what
is to be graphed, and thus all wanted columns should be specified.

There is one case for indexes, where the x\_index, y\_index or z\_index
keyword arguments can be set to True.
\index{build\_model() (dalio.application.PandasMultiGrapher method)@\spxentry{build\_model()}\spxextra{dalio.application.PandasMultiGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.PandasMultiGrapher.build_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build\_model}}}{\emph{data}, \emph{**kwargs}}{}
Process data columns

\end{fulllineitems}


\end{fulllineitems}

\index{VaRGrapher (class in dalio.application)@\spxentry{VaRGrapher}\spxextra{class in dalio.application}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.VaRGrapher}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.}}\sphinxbfcode{\sphinxupquote{VaRGrapher}}}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.Grapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.Grapher}}}}}

Application to visualize Value at Risk
\index{run() (dalio.application.VaRGrapher method)@\spxentry{run()}\spxextra{dalio.application.VaRGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.VaRGrapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get value at risk data, plot returns, value at risk lines and
exceptions at their maximum exedence.

Thank you for the creators of the arch package for the amazing
visulaization idea!

\end{fulllineitems}


\end{fulllineitems}

\index{LMGrapher (class in dalio.application)@\spxentry{LMGrapher}\spxextra{class in dalio.application}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.LMGrapher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.application.}}\sphinxbfcode{\sphinxupquote{LMGrapher}}}{\emph{x=None}, \emph{y=None}, \emph{legend=None}}{}
Bases: {\hyperref[\detokenize{dalio.application:dalio.application.graphers.PandasXYGrapher}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.application.graphers.PandasXYGrapher}}}}}

Application to graph data and a linear model fitted to it.

This Application has two sources data\_in and linear\_model. The data\sphinxhyphen{}in
source is explained in Grapher. The linear\_model source is a fitted
linear model with intercept and coefficient data.
\index{\_legend (dalio.application.LMGrapher attribute)@\spxentry{\_legend}\spxextra{dalio.application.LMGrapher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.LMGrapher._legend}}\pysigline{\sphinxbfcode{\sphinxupquote{\_legend}}}
legend position on graph.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, None

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (dalio.application.LMGrapher method)@\spxentry{run()}\spxextra{dalio.application.LMGrapher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.application:dalio.application.LMGrapher.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Get data, its fitted coefficients and intercepts and graph them.

\end{fulllineitems}


\end{fulllineitems}



\section{Developer Modules}
\label{\detokenize{modules:developer-modules}}

\subsection{dalio.ops module}
\label{\detokenize{dalio.ops:module-dalio.ops}}\label{\detokenize{dalio.ops:dalio-ops-module}}\label{\detokenize{dalio.ops::doc}}\index{dalio.ops (module)@\spxentry{dalio.ops}\spxextra{module}}
Define various operations
\index{get\_comps\_by\_sic() (in module dalio.ops)@\spxentry{get\_comps\_by\_sic()}\spxextra{in module dalio.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.ops:dalio.ops.get_comps_by_sic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.ops.}}\sphinxbfcode{\sphinxupquote{get\_comps\_by\_sic}}}{\emph{data}, \emph{ticker}, \emph{max\_ticks=None}}{}
Get an equity’s comps based on market cap and sic code similarity

This has the major flaw of getting too many comps for common industries.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} data containing all possible comparisson
candidates.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ticker}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} ticker of main stock.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_ticks}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} maximum number of tickers to return.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} if stock is not present in data.

\end{description}\end{quote}

\end{fulllineitems}

\index{index\_cols() (in module dalio.ops)@\spxentry{index\_cols()}\spxextra{in module dalio.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.ops:dalio.ops.index_cols}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.ops.}}\sphinxbfcode{\sphinxupquote{index\_cols}}}{\emph{df}, \emph{i=100}}{}
Index columns at some value

\end{fulllineitems}

\index{risk\_metrics() (in module dalio.ops)@\spxentry{risk\_metrics()}\spxextra{in module dalio.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.ops:dalio.ops.risk_metrics}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.ops.}}\sphinxbfcode{\sphinxupquote{risk\_metrics}}}{\emph{data}, \emph{lam}, \emph{ignore\_first=True}}{}
Apply the basic RiskMetrics (EWMA) continuous volatility measure to a
a dataframe
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lam}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} lambda parameter

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ignore\_first}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to ignore the first row. This is often
the case after a change pipe.

\end{itemize}

\item[{Returns}] \leavevmode
A copy of data with the continuous volatility of each value

\end{description}\end{quote}

\end{fulllineitems}



\subsection{dalio.base package}
\label{\detokenize{dalio.base:dalio-base-package}}\label{\detokenize{dalio.base::doc}}

\subsubsection{Submodules}
\label{\detokenize{dalio.base:submodules}}

\subsubsection{dalio.base.builder module}
\label{\detokenize{dalio.base:module-dalio.base.builder}}\label{\detokenize{dalio.base:dalio-base-builder-module}}\index{dalio.base.builder (module)@\spxentry{dalio.base.builder}\spxextra{module}}
Define extra utility classes used throughout the package

These classes implement certain interfaces used in specific cases and are not
constrained an object’s parent class.


\subsubsection{dalio.base.constants module}
\label{\detokenize{dalio.base:module-dalio.base.constants}}\label{\detokenize{dalio.base:dalio-base-constants-module}}\index{dalio.base.constants (module)@\spxentry{dalio.base.constants}\spxextra{module}}
Define constant terms

In order to maintain name integrity throughout graphs, constants are used
instead of any string name for variables that were created or will be usued in
any \_Transformer instance before or after the current one. These are often
column names for pandas DataFrames, though can be anything that is or will be
used to identify data throughout the graph.


\subsubsection{dalio.base.datadef module}
\label{\detokenize{dalio.base:module-dalio.base.datadef}}\label{\detokenize{dalio.base:dalio-base-datadef-module}}\index{dalio.base.datadef (module)@\spxentry{dalio.base.datadef}\spxextra{module}}
Defines DataDef base class

DataDef instances describe data inputs throughout the graph and ensure the
integrity of data continuously. These are composed of various validators that
serve both to describe approved data and check for whether data passes a test.


\subsubsection{dalio.base.memory module}
\label{\detokenize{dalio.base:module-dalio.base.memory}}\label{\detokenize{dalio.base:dalio-base-memory-module}}\index{dalio.base.memory (module)@\spxentry{dalio.base.memory}\spxextra{module}}
Defines memory transformers
\index{LazyRunner (class in dalio.base.memory)@\spxentry{LazyRunner}\spxextra{class in dalio.base.memory}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.base.memory.}}\sphinxbfcode{\sphinxupquote{LazyRunner}}}{\emph{mem\_type}, \emph{args=None}, \emph{kwargs=None}, \emph{buff=1}, \emph{update=False}}{}
Bases: \sphinxcode{\sphinxupquote{dalio.base.transformer.\_Transformer}}

Memory manager created to set memory input of an object after
executing a transformer with given kwargs.

This is useful when you want to store data sourced from a transformer but
doesn’t know which kwarg requests will be used. This object waits for
a run request to source data from a transformer and set the source of
one or more memory objects (in order) when data does arrive, and reutilize
it if data is requested with the same kwargs.

For every new and valid evaluation, a new Memory instance is created and
saved as a value in the \_memory dictionary. Failed memory storage will
result in no new Memory instance being created. This is done instead of
simply setting inputs to Memory instances created upon initialization in
order to reduce the memory usage of LazyRunner instances.

KEEP IN MIND that this does not check if the actual input is the same to
relay the data, only the kwargs (for speed’s sake). This creates the risk
that inputs or transformer attributes are changed (keeping kwarg requests
the same) and the old data is retrieved. Use the pop() or clear() methods
to solve this.

KEEP IN MIND there is a risk of having very different inputs being
retrieved (from different external sources or date filters, for example)
only based on kwarg requests. This is only relevant if \_buff \textgreater{} 1.
\index{\_source (dalio.base.memory.LazyRunner attribute)@\spxentry{\_source}\spxextra{dalio.base.memory.LazyRunner attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner._source}}\pysigline{\sphinxbfcode{\sphinxupquote{\_source}}}
transformer to source data from. No data
definitions are used as this should be performed by the memory
type uppon setting an input.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\_Transformer

\end{description}\end{quote}

\end{fulllineitems}

\index{\_mem\_type (dalio.base.memory.LazyRunner attribute)@\spxentry{\_mem\_type}\spxextra{dalio.base.memory.LazyRunner attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner._mem_type}}\pysigline{\sphinxbfcode{\sphinxupquote{\_mem\_type}}}
type object for generating new memory instances.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
type

\end{description}\end{quote}

\end{fulllineitems}

\index{\_args (dalio.base.memory.LazyRunner attribute)@\spxentry{\_args}\spxextra{dalio.base.memory.LazyRunner attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner._args}}\pysigline{\sphinxbfcode{\sphinxupquote{\_args}}}
tuple of arguments for new \_mem\_type instance
initialization
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{\_kwargs (dalio.base.memory.LazyRunner attribute)@\spxentry{\_kwargs}\spxextra{dalio.base.memory.LazyRunner attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner._kwargs}}\pysigline{\sphinxbfcode{\sphinxupquote{\_kwargs}}}
dict of keyword arguments for new \_mem\_type instance
initialization
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_memory (dalio.base.memory.LazyRunner attribute)@\spxentry{\_memory}\spxextra{dalio.base.memory.LazyRunner attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner._memory}}\pysigline{\sphinxbfcode{\sphinxupquote{\_memory}}}
deque containing one Memory instance for
every unique kwargs ran with a (kwarg, Memory) tuple structure.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
deque

\end{description}\end{quote}

\end{fulllineitems}

\index{\_buff (dalio.base.memory.LazyRunner attribute)@\spxentry{\_buff}\spxextra{dalio.base.memory.LazyRunner attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner._buff}}\pysigline{\sphinxbfcode{\sphinxupquote{\_buff}}}
Maximum number of Memory instances to be stored
at any point. Positive numbers will be this limit, \sphinxhyphen{}1 represent no
buffer limits. This option should be used with caution, as it can
be highly memory\sphinxhyphen{}inneficient. Subclasses can create new methods of
managing this limit.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, \sphinxhyphen{}1 or \textgreater{}0

\end{description}\end{quote}

\end{fulllineitems}

\index{\_update (dalio.base.memory.LazyRunner attribute)@\spxentry{\_update}\spxextra{dalio.base.memory.LazyRunner attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner._update}}\pysigline{\sphinxbfcode{\sphinxupquote{\_update}}}
Whether \_memory dict should be updated if a new
set of kwargs is ran after reaching maximum capacity (as defined
by the \_buff attribute). If set to True, the last element of the
\_memory dict will be substituted.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{clear() (dalio.base.memory.LazyRunner method)@\spxentry{clear()}\spxextra{dalio.base.memory.LazyRunner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner.clear}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear}}}{}{}
Clear memory

\end{fulllineitems}

\index{copy() (dalio.base.memory.LazyRunner method)@\spxentry{copy()}\spxextra{dalio.base.memory.LazyRunner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Return a copy of this instance with a shallow memory dict copy

\end{fulllineitems}

\index{run() (dalio.base.memory.LazyRunner method)@\spxentry{run()}\spxextra{dalio.base.memory.LazyRunner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Compare kwargs with existing keys, update or set \_memory in
accordance to \_update and \_buff attributes.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{BufferError}} \textendash{} if new kwargs, buffer is full and update set to False

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_buff() (dalio.base.memory.LazyRunner method)@\spxentry{set\_buff()}\spxextra{dalio.base.memory.LazyRunner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner.set_buff}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_buff}}}{\emph{buff}}{}
Set the \_buff attribute

\end{fulllineitems}

\index{set\_input() (dalio.base.memory.LazyRunner method)@\spxentry{set\_input()}\spxextra{dalio.base.memory.LazyRunner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner.set_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_input}}}{\emph{new\_input}}{}
Set the input data source.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{new\_input}} (\sphinxstyleliteralemphasis{\sphinxupquote{\_Transformer}}) \textendash{} new transformer to be set as input.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if new\_input is not an instance of \_Transformer.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_update() (dalio.base.memory.LazyRunner method)@\spxentry{set\_update()}\spxextra{dalio.base.memory.LazyRunner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner.set_update}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_update}}}{\emph{update}}{}
Set the \_update attribute

\end{fulllineitems}

\index{with\_input() (dalio.base.memory.LazyRunner method)@\spxentry{with\_input()}\spxextra{dalio.base.memory.LazyRunner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LazyRunner.with_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{with\_input}}}{\emph{new\_input}}{}
Return copy of this transformer with the new input connection.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Copy of self with new input.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{LocalMemory (class in dalio.base.memory)@\spxentry{LocalMemory}\spxextra{class in dalio.base.memory}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LocalMemory}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.base.memory.}}\sphinxbfcode{\sphinxupquote{LocalMemory}}}
Bases: {\hyperref[\detokenize{dalio.base:dalio.base.memory.Memory}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.base.memory.Memory}}}}}

Stores memory in the local session
\index{clear() (dalio.base.memory.LocalMemory method)@\spxentry{clear()}\spxextra{dalio.base.memory.LocalMemory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LocalMemory.clear}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear}}}{}{}
Clear memory

\end{fulllineitems}

\index{run() (dalio.base.memory.LocalMemory method)@\spxentry{run()}\spxextra{dalio.base.memory.LocalMemory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LocalMemory.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Return data stored in source variable

If data can be coppied, it will. This might not be memory efficient,
but it makes behaviour from the Memory.\_source attribute more
consistent with external memory sources.

\end{fulllineitems}

\index{set\_input() (dalio.base.memory.LocalMemory method)@\spxentry{set\_input()}\spxextra{dalio.base.memory.LocalMemory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.LocalMemory.set_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_input}}}{\emph{new\_input}}{}
Store input data into source variable

\end{fulllineitems}


\end{fulllineitems}

\index{Memory (class in dalio.base.memory)@\spxentry{Memory}\spxextra{class in dalio.base.memory}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.Memory}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.base.memory.}}\sphinxbfcode{\sphinxupquote{Memory}}}
Bases: \sphinxcode{\sphinxupquote{dalio.base.transformer.\_Transformer}}

Implement mechanics to store and retrieve input data.

This is a pseudo\sphinxhyphen{}transformer, as it is supposed to behave like on on the
surface (implementing all needed methods) but not actually performing any
actual transformation.

This is used in pipes that heavily reutilize the same external data source
using the same kwarg requests. Implementations store and retrieive data
through different methods and locations, and might implement certain
requirements that must be met by input data in order for it to be stored.
\index{\_def (dalio.base.memory.Memory attribute)@\spxentry{\_def}\spxextra{dalio.base.memory.Memory attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.Memory._def}}\pysigline{\sphinxbfcode{\sphinxupquote{\_def}}}
Connection\sphinxhyphen{}less data definition that checks for
required characteristics of of input data.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\_DataDef

\end{description}\end{quote}

\end{fulllineitems}

\index{\_source (dalio.base.memory.Memory attribute)@\spxentry{\_source}\spxextra{dalio.base.memory.Memory attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.Memory._source}}\pysigline{\sphinxbfcode{\sphinxupquote{\_source}}}
Memory source. Implementations will often have
additional attributes to manage this source.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
any

\end{description}\end{quote}

\end{fulllineitems}

\index{clear() (dalio.base.memory.Memory method)@\spxentry{clear()}\spxextra{dalio.base.memory.Memory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.Memory.clear}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear}}}{}{}
Clear memory

\end{fulllineitems}

\index{copy() (dalio.base.memory.Memory method)@\spxentry{copy()}\spxextra{dalio.base.memory.Memory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.Memory.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{*args}, \emph{**kwargs}}{}
Create new instance and memory source

\end{fulllineitems}

\index{run() (dalio.base.memory.Memory method)@\spxentry{run()}\spxextra{dalio.base.memory.Memory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.Memory.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{**kwargs}}{}
Check if location is set and return stored data accordingly

\end{fulllineitems}

\index{set\_input() (dalio.base.memory.Memory method)@\spxentry{set\_input()}\spxextra{dalio.base.memory.Memory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.Memory.set_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_input}}}{\emph{new\_input}}{}
Store input data

\end{fulllineitems}

\index{with\_input() (dalio.base.memory.Memory method)@\spxentry{with\_input()}\spxextra{dalio.base.memory.Memory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.base:dalio.base.memory.Memory.with_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{with\_input}}}{\emph{new\_input}}{}
Return copy of this transformer with the new input connection.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Copy of self with new input.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.base.node module}
\label{\detokenize{dalio.base:module-dalio.base.node}}\label{\detokenize{dalio.base:dalio-base-node-module}}\index{dalio.base.node (module)@\spxentry{dalio.base.node}\spxextra{module}}
Defines Node abstract class

Nodes are the key building blocks of your model as they represent any data
that passes thorugh it. These are usued in subsequent classes to describe and
manage data.


\subsubsection{dalio.base.transformer module}
\label{\detokenize{dalio.base:module-dalio.base.transformer}}\label{\detokenize{dalio.base:dalio-base-transformer-module}}\index{dalio.base.transformer (module)@\spxentry{dalio.base.transformer}\spxextra{module}}
Define Transformer class

Transformers are a base class that represents any kind of data modification.
These interact with DataOrigin instances as they are key to their input and
output integrity. A set\_source() method sets the source of the input, the
.run() method cannot be executed if the input”s source is not set.


\subsubsection{Module contents}
\label{\detokenize{dalio.base:module-dalio.base}}\label{\detokenize{dalio.base:module-contents}}\index{dalio.base (module)@\spxentry{dalio.base}\spxextra{module}}
import classes


\subsection{dalio.validator package}
\label{\detokenize{dalio.validator:dalio-validator-package}}\label{\detokenize{dalio.validator::doc}}

\subsubsection{Submodules}
\label{\detokenize{dalio.validator:submodules}}

\subsubsection{dalio.validator.array\_val module}
\label{\detokenize{dalio.validator:module-dalio.validator.array_val}}\label{\detokenize{dalio.validator:dalio-validator-array-val-module}}\index{dalio.validator.array\_val (module)@\spxentry{dalio.validator.array\_val}\spxextra{module}}
Definte validators applied to array\sphinxhyphen{}like inputs
\index{HAS\_DIMS (class in dalio.validator.array\_val)@\spxentry{HAS\_DIMS}\spxextra{class in dalio.validator.array\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.array_val.HAS_DIMS}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.array\_val.}}\sphinxbfcode{\sphinxupquote{HAS\_DIMS}}}{\emph{dims}, \emph{comparisson=\textquotesingle{}==\textquotesingle{}}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.validator.Validator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.validator.Validator}}}}}

Check if an array has a number of dimensions
\index{\_dims (dalio.validator.array\_val.HAS\_DIMS attribute)@\spxentry{\_dims}\spxextra{dalio.validator.array\_val.HAS\_DIMS attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.array_val.HAS_DIMS._dims}}\pysigline{\sphinxbfcode{\sphinxupquote{\_dims}}}
number of dimensions
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_comparisson (dalio.validator.array\_val.HAS\_DIMS attribute)@\spxentry{\_comparisson}\spxextra{dalio.validator.array\_val.HAS\_DIMS attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.array_val.HAS_DIMS._comparisson}}\pysigline{\sphinxbfcode{\sphinxupquote{\_comparisson}}}
which comparisson to perform
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (dalio.validator.array\_val.HAS\_DIMS method)@\spxentry{validate()}\spxextra{dalio.validator.array\_val.HAS\_DIMS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.array_val.HAS_DIMS.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validate data

Check if data fits a certain description.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A description of any errors in the data according to this
specific validation condition, and None if data is valid.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.validator.base\_val module}
\label{\detokenize{dalio.validator:module-dalio.validator.base_val}}\label{\detokenize{dalio.validator:dalio-validator-base-val-module}}\index{dalio.validator.base\_val (module)@\spxentry{dalio.validator.base\_val}\spxextra{module}}
Define Validators used for general python objects
\index{ELEMS\_TYPE (class in dalio.validator.base\_val)@\spxentry{ELEMS\_TYPE}\spxextra{class in dalio.validator.base\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.ELEMS_TYPE}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.base\_val.}}\sphinxbfcode{\sphinxupquote{ELEMS\_TYPE}}}{\emph{t}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.base_val.HAS_ATTR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.base\_val.HAS\_ATTR}}}}}

Checks if all elements of an iterator is of a certain type.
\index{\_t (dalio.validator.base\_val.ELEMS\_TYPE attribute)@\spxentry{\_t}\spxextra{dalio.validator.base\_val.ELEMS\_TYPE attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.ELEMS_TYPE._t}}\pysigline{\sphinxbfcode{\sphinxupquote{\_t}}}
type to check iterator’s elements for
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
type, tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (dalio.validator.base\_val.ELEMS\_TYPE method)@\spxentry{validate()}\spxextra{dalio.validator.base\_val.ELEMS\_TYPE method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.ELEMS_TYPE.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if it is an iterable with all elements of type
self.\_t

\end{fulllineitems}


\end{fulllineitems}

\index{HAS\_ATTR (class in dalio.validator.base\_val)@\spxentry{HAS\_ATTR}\spxextra{class in dalio.validator.base\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.HAS_ATTR}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.base\_val.}}\sphinxbfcode{\sphinxupquote{HAS\_ATTR}}}{\emph{attr}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.validator.Validator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.validator.Validator}}}}}

Checks if data has an attribute
\index{\_attr (dalio.validator.base\_val.HAS\_ATTR attribute)@\spxentry{\_attr}\spxextra{dalio.validator.base\_val.HAS\_ATTR attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.HAS_ATTR._attr}}\pysigline{\sphinxbfcode{\sphinxupquote{\_attr}}}
attribute to check for
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{validate() (dalio.validator.base\_val.HAS\_ATTR method)@\spxentry{validate()}\spxextra{dalio.validator.base\_val.HAS\_ATTR method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.HAS_ATTR.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if it contains attribute self.\_attr

\end{fulllineitems}


\end{fulllineitems}

\index{IS\_TYPE (class in dalio.validator.base\_val)@\spxentry{IS\_TYPE}\spxextra{class in dalio.validator.base\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.IS_TYPE}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.base\_val.}}\sphinxbfcode{\sphinxupquote{IS\_TYPE}}}{\emph{t}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.validator.Validator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.validator.Validator}}}}}

Checks if data is of a certain type
\begin{description}
\item[{Attribute:}] \leavevmode
t (type): type of data to check for

\end{description}
\index{validate() (dalio.validator.base\_val.IS\_TYPE method)@\spxentry{validate()}\spxextra{dalio.validator.base\_val.IS\_TYPE method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.base_val.IS_TYPE.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if it is of type self.\_t

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.validator.pandas\_val module}
\label{\detokenize{dalio.validator:module-dalio.validator.pandas_val}}\label{\detokenize{dalio.validator:dalio-validator-pandas-val-module}}\index{dalio.validator.pandas\_val (module)@\spxentry{dalio.validator.pandas\_val}\spxextra{module}}\index{HAS\_COLS (class in dalio.validator.pandas\_val)@\spxentry{HAS\_COLS}\spxextra{class in dalio.validator.pandas\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_COLS}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.}}\sphinxbfcode{\sphinxupquote{HAS\_COLS}}}{\emph{cols}, \emph{level=None}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.pandas_val.IS_PD_DF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.IS\_PD\_DF}}}}}

Checks if data has certain column names
\index{\_cols (dalio.validator.pandas\_val.HAS\_COLS attribute)@\spxentry{\_cols}\spxextra{dalio.validator.pandas\_val.HAS\_COLS attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_COLS._cols}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cols}}}
list of column names to check

\end{fulllineitems}

\index{validate() (dalio.validator.pandas\_val.HAS\_COLS method)@\spxentry{validate()}\spxextra{dalio.validator.pandas\_val.HAS\_COLS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_COLS.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if all the columns in self.\_cols is present in the
dataframe

\end{fulllineitems}


\end{fulllineitems}

\index{HAS\_INDEX\_NAMES (class in dalio.validator.pandas\_val)@\spxentry{HAS\_INDEX\_NAMES}\spxextra{class in dalio.validator.pandas\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_INDEX_NAMES}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.}}\sphinxbfcode{\sphinxupquote{HAS\_INDEX\_NAMES}}}{\emph{names}, \emph{axis=0}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.pandas_val.IS_PD_DF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.IS\_PD\_DF}}}}}

Checks if an axis has specified names
\index{\_names (dalio.validator.pandas\_val.HAS\_INDEX\_NAMES attribute)@\spxentry{\_names}\spxextra{dalio.validator.pandas\_val.HAS\_INDEX\_NAMES attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_INDEX_NAMES._names}}\pysigline{\sphinxbfcode{\sphinxupquote{\_names}}}
names to check for

\end{fulllineitems}

\index{\_axis (dalio.validator.pandas\_val.HAS\_INDEX\_NAMES attribute)@\spxentry{\_axis}\spxextra{dalio.validator.pandas\_val.HAS\_INDEX\_NAMES attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_INDEX_NAMES._axis}}\pysigline{\sphinxbfcode{\sphinxupquote{\_axis}}}
axis to check for names

\end{fulllineitems}

\index{validate() (dalio.validator.pandas\_val.HAS\_INDEX\_NAMES method)@\spxentry{validate()}\spxextra{dalio.validator.pandas\_val.HAS\_INDEX\_NAMES method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_INDEX_NAMES.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if specified axis has the specified names

\end{fulllineitems}


\end{fulllineitems}

\index{HAS\_IN\_COLS (class in dalio.validator.pandas\_val)@\spxentry{HAS\_IN\_COLS}\spxextra{class in dalio.validator.pandas\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_IN_COLS}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.}}\sphinxbfcode{\sphinxupquote{HAS\_IN\_COLS}}}{\emph{items}, \emph{cols=None}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_COLS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.HAS\_COLS}}}}}

Check if certain items are present in certain columns
\index{\_cols (dalio.validator.pandas\_val.HAS\_IN\_COLS attribute)@\spxentry{\_cols}\spxextra{dalio.validator.pandas\_val.HAS\_IN\_COLS attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_IN_COLS._cols}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cols}}}
See base class

\end{fulllineitems}

\index{\_items (dalio.validator.pandas\_val.HAS\_IN\_COLS attribute)@\spxentry{\_items}\spxextra{dalio.validator.pandas\_val.HAS\_IN\_COLS attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_IN_COLS._items}}\pysigline{\sphinxbfcode{\sphinxupquote{\_items}}}
items that must be present in each of the specified columns

\end{fulllineitems}

\index{validate() (dalio.validator.pandas\_val.HAS\_IN\_COLS method)@\spxentry{validate()}\spxextra{dalio.validator.pandas\_val.HAS\_IN\_COLS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_IN_COLS.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if items in self.\_items are not present in specified
columns. Specified columns are all columns if self.\_cols is None.

\end{fulllineitems}


\end{fulllineitems}

\index{HAS\_LEVELS (class in dalio.validator.pandas\_val)@\spxentry{HAS\_LEVELS}\spxextra{class in dalio.validator.pandas\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_LEVELS}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.}}\sphinxbfcode{\sphinxupquote{HAS\_LEVELS}}}{\emph{levels}, \emph{axis=0}, \emph{comparisson=\textquotesingle{}\textless{}=\textquotesingle{}}}{}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.pandas_val.IS_PD_DF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.IS\_PD\_DF}}}}}
\index{validate() (dalio.validator.pandas\_val.HAS\_LEVELS method)@\spxentry{validate()}\spxextra{dalio.validator.pandas\_val.HAS\_LEVELS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.HAS_LEVELS.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if it is of type self.\_t

\end{fulllineitems}


\end{fulllineitems}

\index{IS\_PD\_DF (class in dalio.validator.pandas\_val)@\spxentry{IS\_PD\_DF}\spxextra{class in dalio.validator.pandas\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.IS_PD_DF}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.}}\sphinxbfcode{\sphinxupquote{IS\_PD\_DF}}}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.base_val.IS_TYPE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.base\_val.IS\_TYPE}}}}}

Checks if data is a pandas dataframe


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{See~base~class}}}
\end{fulllineitems}


\end{fulllineitems}

\index{IS\_PD\_TS (class in dalio.validator.pandas\_val)@\spxentry{IS\_PD\_TS}\spxextra{class in dalio.validator.pandas\_val}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.IS_PD_TS}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.pandas\_val.}}\sphinxbfcode{\sphinxupquote{IS\_PD\_TS}}}
Bases: {\hyperref[\detokenize{dalio.validator:dalio.validator.base_val.IS_TYPE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dalio.validator.base\_val.IS\_TYPE}}}}}

Checks if data is a pandas time series
\index{validate() (dalio.validator.pandas\_val.IS\_PD\_TS method)@\spxentry{validate()}\spxextra{dalio.validator.pandas\_val.IS\_PD\_TS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.pandas_val.IS_PD_TS.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validates data if it’s index is of type pandas.DateTimeIndex

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{dalio.validator.presets module}
\label{\detokenize{dalio.validator:module-dalio.validator.presets}}\label{\detokenize{dalio.validator:dalio-validator-presets-module}}\index{dalio.validator.presets (module)@\spxentry{dalio.validator.presets}\spxextra{module}}
Define Validator collection presets

These are useful to describe very specific data characteristics commonly used
in some analysis.


\subsubsection{dalio.validator.validator module}
\label{\detokenize{dalio.validator:module-dalio.validator.validator}}\label{\detokenize{dalio.validator:dalio-validator-validator-module}}\index{dalio.validator.validator (module)@\spxentry{dalio.validator.validator}\spxextra{module}}
Define Validator class

Validators are the building blocks of data integrity in the graph. As
modularity is key, validators ensure that the data that enters a node is what
it is mean to be or that errors are targeted to make debugging easier.
\index{Validator (class in dalio.validator.validator)@\spxentry{Validator}\spxextra{class in dalio.validator.validator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.validator.validator.}}\sphinxbfcode{\sphinxupquote{Validator}}}{\emph{fatal=True}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Check for some characteristic of a piece of data

Validators can have any attribute needed, but functionality is stored
in u the .validate function, which returns any errors in the data.
\index{fatal (dalio.validator.validator.Validator attribute)@\spxentry{fatal}\spxextra{dalio.validator.validator.Validator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator.fatal}}\pysigline{\sphinxbfcode{\sphinxupquote{fatal}}}
Whether if invalid data is fatal. Decides whether
invalid data can still be passed on (with a warning) or if it is
grounds to stop the execution of the graph. False by default.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{test\_desc (dalio.validator.validator.Validator attribute)@\spxentry{test\_desc}\spxextra{dalio.validator.validator.Validator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator.test_desc}}\pysigline{\sphinxbfcode{\sphinxupquote{test\_desc}}}
Description of tests performed on data
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{fatal (dalio.validator.validator.Validator attribute)@\spxentry{fatal}\spxextra{dalio.validator.validator.Validator attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{fatal}}\sphinxbfcode{\sphinxupquote{: bool}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{fatal\_off() (dalio.validator.validator.Validator method)@\spxentry{fatal\_off()}\spxextra{dalio.validator.validator.Validator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator.fatal_off}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fatal\_off}}}{}{}
Turn fatal off and return self

\end{fulllineitems}

\index{fatal\_on() (dalio.validator.validator.Validator method)@\spxentry{fatal\_on()}\spxextra{dalio.validator.validator.Validator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator.fatal_on}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fatal\_on}}}{}{}
Turn fatal on and return self

\end{fulllineitems}

\index{is\_on (dalio.validator.validator.Validator attribute)@\spxentry{is\_on}\spxextra{dalio.validator.validator.Validator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator.is_on}}\pysigline{\sphinxbfcode{\sphinxupquote{is\_on}}\sphinxbfcode{\sphinxupquote{: bool}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{test\_desc (dalio.validator.validator.Validator attribute)@\spxentry{test\_desc}\spxextra{dalio.validator.validator.Validator attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{test\_desc}}\sphinxbfcode{\sphinxupquote{: str}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{validate() (dalio.validator.validator.Validator method)@\spxentry{validate()}\spxextra{dalio.validator.validator.Validator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.validator:dalio.validator.validator.Validator.validate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{validate}}}{\emph{data}}{}
Validate data

Check if data fits a certain description.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A description of any errors in the data according to this
specific validation condition, and None if data is valid.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Module contents}
\label{\detokenize{dalio.validator:module-dalio.validator}}\label{\detokenize{dalio.validator:module-contents}}\index{dalio.validator (module)@\spxentry{dalio.validator}\spxextra{module}}

\subsection{dalio.util package}
\label{\detokenize{dalio.util:dalio-util-package}}\label{\detokenize{dalio.util::doc}}

\subsubsection{Submodules}
\label{\detokenize{dalio.util:submodules}}

\subsubsection{dalio.util.level\_utils module}
\label{\detokenize{dalio.util:module-dalio.util.level_utils}}\label{\detokenize{dalio.util:dalio-util-level-utils-module}}\index{dalio.util.level\_utils (module)@\spxentry{dalio.util.level\_utils}\spxextra{module}}
Utilities for dealing with DataFrame index or column levels
\index{add\_suffix() (in module dalio.util.level\_utils)@\spxentry{add\_suffix()}\spxextra{in module dalio.util.level\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.level_utils.add_suffix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.level\_utils.}}\sphinxbfcode{\sphinxupquote{add\_suffix}}}{\emph{all\_cols}, \emph{cols}, \emph{suffix}}{}
Add suffix to appropriate level in a given column index.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{all\_cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.Index}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.MultiIndex}}) \textendash{} all columns from an index. This
is only relevent when the columns at hand are a multindex, as each
tuple element will contain elements from all levels (not only the
selected ones)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} selected columns

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{suffix}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the suffix to add to the selected columns.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{drop\_cols() (in module dalio.util.level\_utils)@\spxentry{drop\_cols()}\spxextra{in module dalio.util.level\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.level_utils.drop_cols}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.level\_utils.}}\sphinxbfcode{\sphinxupquote{drop\_cols}}}{\emph{df}, \emph{cols}}{}
Drop selected columns from levels
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe to have columns dropped.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{hashable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} column selection

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_cols() (in module dalio.util.level\_utils)@\spxentry{extract\_cols()}\spxextra{in module dalio.util.level\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.level_utils.extract_cols}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.level\_utils.}}\sphinxbfcode{\sphinxupquote{extract\_cols}}}{\emph{df}, \emph{cols}}{}
Extract columns from a dataframe
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe containing the columns

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{hashable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} single column, list of columnst
or dict with the level as keys and column(s) as values.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} if columns are not in dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_level\_names\_dict() (in module dalio.util.level\_utils)@\spxentry{extract\_level\_names\_dict()}\spxextra{in module dalio.util.level\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.level_utils.extract_level_names_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.level\_utils.}}\sphinxbfcode{\sphinxupquote{extract\_level\_names\_dict}}}{\emph{df}}{}
Extract all column names in a dataframe as (level: {\color{red}\bfseries{}names\_} dicitonar7
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe whose columns will be extracted

\end{description}\end{quote}

\end{fulllineitems}

\index{filter\_levels() (in module dalio.util.level\_utils)@\spxentry{filter\_levels()}\spxextra{in module dalio.util.level\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.level_utils.filter_levels}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.level\_utils.}}\sphinxbfcode{\sphinxupquote{filter\_levels}}}{\emph{levels}, \emph{filters}}{}
Filter columns in levels to either be equal to specified
columns or a filtering function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{levels}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} all column names in a (level: names) dict

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filters}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{callable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} either columns to place on
a specified level or filter functions to select columns there.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_slice\_from\_dict() (in module dalio.util.level\_utils)@\spxentry{get\_slice\_from\_dict()}\spxextra{in module dalio.util.level\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.level_utils.get_slice_from_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.level\_utils.}}\sphinxbfcode{\sphinxupquote{get\_slice\_from\_dict}}}{\emph{df}, \emph{cols}}{}
Get a tuple of slices that locate the specified (level: column)
combination.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe with multiindex

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} (level: column) dictionary

\end{itemize}

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if any of the level keys are not integers

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} if any level key is out of bounds or if columns are not in
    the dataframe

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{insert\_cols() (in module dalio.util.level\_utils)@\spxentry{insert\_cols()}\spxextra{in module dalio.util.level\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.level_utils.insert_cols}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.level\_utils.}}\sphinxbfcode{\sphinxupquote{insert\_cols}}}{\emph{df}, \emph{new\_data}, \emph{cols}}{}
Insert new data into specified existing columns
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe to insert data into.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_data}} (\sphinxstyleliteralemphasis{\sphinxupquote{any}}) \textendash{} new data to be inserted

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{hashable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} existing columns in data.

\end{itemize}

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} if columns are not in dataframe

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} if new data doesn’t fit cols dimensions

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{mi\_join() (in module dalio.util.level\_utils)@\spxentry{mi\_join()}\spxextra{in module dalio.util.level\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.level_utils.mi_join}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.level\_utils.}}\sphinxbfcode{\sphinxupquote{mi\_join}}}{\emph{df1}, \emph{df2}, \emph{*args}, \emph{**kwargs}}{}
Join two dataframes and sort their columns
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df2}} (\sphinxstyleliteralemphasis{\sphinxupquote{df1}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} dataframes to join

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} (\sphinxstyleliteralemphasis{\sphinxupquote{*args}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} 
arguments for join function (called from df1)


\end{itemize}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError if number of levels don\textquotesingle{}t match}} \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{dalio.util.plotting\_utils module}
\label{\detokenize{dalio.util:module-dalio.util.plotting_utils}}\label{\detokenize{dalio.util:dalio-util-plotting-utils-module}}\index{dalio.util.plotting\_utils (module)@\spxentry{dalio.util.plotting\_utils}\spxextra{module}}
Plotting utilities

Thank you for the creators of pypfopt for the wonderful code!
\index{plot\_covariance() (in module dalio.util.plotting\_utils)@\spxentry{plot\_covariance()}\spxextra{in module dalio.util.plotting\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plotting_utils.plot_covariance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.plotting\_utils.}}\sphinxbfcode{\sphinxupquote{plot\_covariance}}}{\emph{cov\_matrix}, \emph{plot\_correlation=False}, \emph{show\_tickers=True}, \emph{ax=None}}{}
Generate a basic plot of the covariance (or correlation) matrix,
given a covariance matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cov\_matrix}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} covariance matrix

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plot\_correlation}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to plot the correlation matrix
instead, defaults to False. Optional.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_tickers}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to use tickers as labels (not
recommended for large portfolios). Optional. Defaults to True.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_dendrogram() (in module dalio.util.plotting\_utils)@\spxentry{plot\_dendrogram()}\spxextra{in module dalio.util.plotting\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plotting_utils.plot_dendrogram}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.plotting\_utils.}}\sphinxbfcode{\sphinxupquote{plot\_dendrogram}}}{\emph{hrp}, \emph{show\_tickers=True}, \emph{ax=None}, \emph{**kwargs}}{}
Plot the clusters in the form of a dendrogram.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hrp}} \textendash{} HRPpt object that has already been optimized.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_tickers}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to use tickers as labels (not
recommended for large portfolios). Optional. Defaults to True.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} optional parameters for main graph.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_efficient\_frontier() (in module dalio.util.plotting\_utils)@\spxentry{plot\_efficient\_frontier()}\spxextra{in module dalio.util.plotting\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plotting_utils.plot_efficient_frontier}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.plotting\_utils.}}\sphinxbfcode{\sphinxupquote{plot\_efficient\_frontier}}}{\emph{cla}, \emph{points=100}, \emph{visible=25}, \emph{show\_assets=True}, \emph{ax=None}, \emph{**kwargs}}{}
Plot the efficient frontier based on a CLA object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of points to plot. Optional. Defaults to 100

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_assets}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether we should plot the asset risks/returns
also. Optional. Defaults to True.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} optional parameters for main graph.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_weights() (in module dalio.util.plotting\_utils)@\spxentry{plot\_weights()}\spxextra{in module dalio.util.plotting\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plotting_utils.plot_weights}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.plotting\_utils.}}\sphinxbfcode{\sphinxupquote{plot\_weights}}}{\emph{weights}, \emph{ax=None}, \emph{**kwargs}}{}
Plot the portfolio weights as a horizontal bar chart
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} the weights outputted by any PyPortfolioOpt
optimiser.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} optional parameters for main graph.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{dalio.util.processing\_utils module}
\label{\detokenize{dalio.util:module-dalio.util.processing_utils}}\label{\detokenize{dalio.util:dalio-util-processing-utils-module}}\index{dalio.util.processing\_utils (module)@\spxentry{dalio.util.processing\_utils}\spxextra{module}}
Data processing utilities
\index{list\_str() (in module dalio.util.processing\_utils)@\spxentry{list\_str()}\spxextra{in module dalio.util.processing\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.processing_utils.list_str}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.processing\_utils.}}\sphinxbfcode{\sphinxupquote{list\_str}}}{\emph{listi}}{}
\end{fulllineitems}

\index{process\_cols() (in module dalio.util.processing\_utils)@\spxentry{process\_cols()}\spxextra{in module dalio.util.processing\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.processing_utils.process_cols}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.processing\_utils.}}\sphinxbfcode{\sphinxupquote{process\_cols}}}{\emph{cols}}{}
Standardize input columns

\end{fulllineitems}

\index{process\_date() (in module dalio.util.processing\_utils)@\spxentry{process\_date()}\spxextra{in module dalio.util.processing\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.processing_utils.process_date}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.processing\_utils.}}\sphinxbfcode{\sphinxupquote{process\_date}}}{\emph{date}}{}
Standardize input date
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the type of the date parameter cannot be converted to
    a pandas timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{process\_new\_colnames() (in module dalio.util.processing\_utils)@\spxentry{process\_new\_colnames()}\spxextra{in module dalio.util.processing\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.processing_utils.process_new_colnames}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.processing\_utils.}}\sphinxbfcode{\sphinxupquote{process\_new\_colnames}}}{\emph{cols}, \emph{new\_cols}}{}
Get new column names based on the column parameter

\end{fulllineitems}

\index{process\_new\_df() (in module dalio.util.processing\_utils)@\spxentry{process\_new\_df()}\spxextra{in module dalio.util.processing\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.processing_utils.process_new_df}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.processing\_utils.}}\sphinxbfcode{\sphinxupquote{process\_new\_df}}}{\emph{df1}, \emph{df2}, \emph{cols}, \emph{new\_cols}}{}
Process new dataframe given columns and new column names
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df1}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} first dataframe.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df2}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe to join or get columns from

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}) \textendash{} iterable of columns being targetted.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}) \textendash{} iterable of new column names.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{dalio.util.transformation\_utils module}
\label{\detokenize{dalio.util:module-dalio.util.transformation_utils}}\label{\detokenize{dalio.util:dalio-util-transformation-utils-module}}\index{dalio.util.transformation\_utils (module)@\spxentry{dalio.util.transformation\_utils}\spxextra{module}}\index{out\_of\_place\_col\_insert() (in module dalio.util.transformation\_utils)@\spxentry{out\_of\_place\_col\_insert()}\spxextra{in module dalio.util.transformation\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.transformation_utils.out_of_place_col_insert}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.transformation\_utils.}}\sphinxbfcode{\sphinxupquote{out\_of\_place\_col\_insert}}}{\emph{df}, \emph{series}, \emph{loc}, \emph{column\_name=None}}{}
Returns a new dataframe with given column inserted at given location.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} The dataframe into which to insert the column.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{series}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.Series}}) \textendash{} The pandas series to be inserted.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{loc}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The location into which to insert the new column.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{column\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default None}}) \textendash{} The name to assign the new column. If None, the given series name
attribute is attempted; if the given series is missing the name
attribute a ValueError exception will be raised.

\end{itemize}

\item[{Returns}] \leavevmode
The resulting dataframe.

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{columns}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ser} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{out\PYGZus{}of\PYGZus{}place\PYGZus{}col\PYGZus{}insert}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,} \PYG{n}{ser}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{   a  n  g}
\PYG{g+go}{0  1  7  a}
\PYG{g+go}{1  4  5  b}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsubsection{dalio.util.translation\_utils module}
\label{\detokenize{dalio.util:module-dalio.util.translation_utils}}\label{\detokenize{dalio.util:dalio-util-translation-utils-module}}\index{dalio.util.translation\_utils (module)@\spxentry{dalio.util.translation\_utils}\spxextra{module}}
Translation utilities
\index{get\_numeric\_column\_names() (in module dalio.util.translation\_utils)@\spxentry{get\_numeric\_column\_names()}\spxextra{in module dalio.util.translation\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.translation_utils.get_numeric_column_names}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.translation\_utils.}}\sphinxbfcode{\sphinxupquote{get\_numeric\_column\_names}}}{\emph{df}}{}
Return the names of all columns of numeric type.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} The dataframe to get numeric column names for.

\item[{Returns}] \leavevmode
The names of all columns of numeric type.

\item[{Return type}] \leavevmode
list of str

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{3.2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{acd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{7.2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alk}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mf}{12.1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alk}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rank}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ph}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lbl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{get\PYGZus{}numeric\PYGZus{}column\PYGZus{}names}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}ph\PYGZsq{}, \PYGZsq{}rank\PYGZsq{}]}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{translate\_df() (in module dalio.util.translation\_utils)@\spxentry{translate\_df()}\spxextra{in module dalio.util.translation\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.translation_utils.translate_df}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.translation\_utils.}}\sphinxbfcode{\sphinxupquote{translate\_df}}}{\emph{translator}, \emph{df}, \emph{inplace=False}}{}
Translate dataframe column and index names in accordance to translator
dictionary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{translator}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} dictionary of \{original: translated\} key value
pairs.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe to have rows and columns translated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inplace}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to perform operation inplace or return a
translated copy. Optional. Defaults to False.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Module contents}
\label{\detokenize{dalio.util:module-dalio.util}}\label{\detokenize{dalio.util:module-contents}}\index{dalio.util (module)@\spxentry{dalio.util}\spxextra{module}}\index{extract\_level\_names\_dict() (in module dalio.util)@\spxentry{extract\_level\_names\_dict()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.extract_level_names_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{extract\_level\_names\_dict}}}{\emph{df}}{}
Extract all column names in a dataframe as (level: {\color{red}\bfseries{}names\_} dicitonar7
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe whose columns will be extracted

\end{description}\end{quote}

\end{fulllineitems}

\index{filter\_levels() (in module dalio.util)@\spxentry{filter\_levels()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.filter_levels}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{filter\_levels}}}{\emph{levels}, \emph{filters}}{}
Filter columns in levels to either be equal to specified
columns or a filtering function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{levels}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} all column names in a (level: names) dict

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filters}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{callable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} either columns to place on
a specified level or filter functions to select columns there.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_cols() (in module dalio.util)@\spxentry{extract\_cols()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.extract_cols}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{extract\_cols}}}{\emph{df}, \emph{cols}}{}
Extract columns from a dataframe
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe containing the columns

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{hashable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} single column, list of columnst
or dict with the level as keys and column(s) as values.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} if columns are not in dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{insert\_cols() (in module dalio.util)@\spxentry{insert\_cols()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.insert_cols}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{insert\_cols}}}{\emph{df}, \emph{new\_data}, \emph{cols}}{}
Insert new data into specified existing columns
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe to insert data into.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_data}} (\sphinxstyleliteralemphasis{\sphinxupquote{any}}) \textendash{} new data to be inserted

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{hashable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} existing columns in data.

\end{itemize}

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} if columns are not in dataframe

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} if new data doesn’t fit cols dimensions

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{drop\_cols() (in module dalio.util)@\spxentry{drop\_cols()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.drop_cols}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{drop\_cols}}}{\emph{df}, \emph{cols}}{}
Drop selected columns from levels
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe to have columns dropped.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{hashable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} column selection

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_slice\_from\_dict() (in module dalio.util)@\spxentry{get\_slice\_from\_dict()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.get_slice_from_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{get\_slice\_from\_dict}}}{\emph{df}, \emph{cols}}{}
Get a tuple of slices that locate the specified (level: column)
combination.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe with multiindex

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} (level: column) dictionary

\end{itemize}

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if any of the level keys are not integers

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} if any level key is out of bounds or if columns are not in
    the dataframe

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{mi\_join() (in module dalio.util)@\spxentry{mi\_join()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.mi_join}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{mi\_join}}}{\emph{df1}, \emph{df2}, \emph{*args}, \emph{**kwargs}}{}
Join two dataframes and sort their columns
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df2}} (\sphinxstyleliteralemphasis{\sphinxupquote{df1}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} dataframes to join

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} (\sphinxstyleliteralemphasis{\sphinxupquote{*args}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} 
arguments for join function (called from df1)


\end{itemize}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError if number of levels don\textquotesingle{}t match}} \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_suffix() (in module dalio.util)@\spxentry{add\_suffix()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.add_suffix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{add\_suffix}}}{\emph{all\_cols}, \emph{cols}, \emph{suffix}}{}
Add suffix to appropriate level in a given column index.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{all\_cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.Index}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{pd.MultiIndex}}) \textendash{} all columns from an index. This
is only relevent when the columns at hand are a multindex, as each
tuple element will contain elements from all levels (not only the
selected ones)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} selected columns

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{suffix}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the suffix to add to the selected columns.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{out\_of\_place\_col\_insert() (in module dalio.util)@\spxentry{out\_of\_place\_col\_insert()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.out_of_place_col_insert}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{out\_of\_place\_col\_insert}}}{\emph{df}, \emph{series}, \emph{loc}, \emph{column\_name=None}}{}
Returns a new dataframe with given column inserted at given location.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} The dataframe into which to insert the column.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{series}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.Series}}) \textendash{} The pandas series to be inserted.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{loc}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The location into which to insert the new column.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{column\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{default None}}) \textendash{} The name to assign the new column. If None, the given series name
attribute is attempted; if the given series is missing the name
attribute a ValueError exception will be raised.

\end{itemize}

\item[{Returns}] \leavevmode
The resulting dataframe.

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{columns}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ser} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{out\PYGZus{}of\PYGZus{}place\PYGZus{}col\PYGZus{}insert}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,} \PYG{n}{ser}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{   a  n  g}
\PYG{g+go}{0  1  7  a}
\PYG{g+go}{1  4  5  b}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{translate\_df() (in module dalio.util)@\spxentry{translate\_df()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.translate_df}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{translate\_df}}}{\emph{translator}, \emph{df}, \emph{inplace=False}}{}
Translate dataframe column and index names in accordance to translator
dictionary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{translator}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} dictionary of \{original: translated\} key value
pairs.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe to have rows and columns translated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inplace}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to perform operation inplace or return a
translated copy. Optional. Defaults to False.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_numeric\_column\_names() (in module dalio.util)@\spxentry{get\_numeric\_column\_names()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.get_numeric_column_names}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{get\_numeric\_column\_names}}}{\emph{df}}{}
Return the names of all columns of numeric type.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} The dataframe to get numeric column names for.

\item[{Returns}] \leavevmode
The names of all columns of numeric type.

\item[{Return type}] \leavevmode
list of str

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{import} \PYG{n+nn}{pdpipe} \PYG{k}{as} \PYG{n+nn}{pdp}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{3.2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{acd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{7.2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alk}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mf}{12.1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alk}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rank}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ph}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lbl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{get\PYGZus{}numeric\PYGZus{}column\PYGZus{}names}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}ph\PYGZsq{}, \PYGZsq{}rank\PYGZsq{}]}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{process\_cols() (in module dalio.util)@\spxentry{process\_cols()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.process_cols}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{process\_cols}}}{\emph{cols}}{}
Standardize input columns

\end{fulllineitems}

\index{process\_new\_colnames() (in module dalio.util)@\spxentry{process\_new\_colnames()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.process_new_colnames}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{process\_new\_colnames}}}{\emph{cols}, \emph{new\_cols}}{}
Get new column names based on the column parameter

\end{fulllineitems}

\index{process\_date() (in module dalio.util)@\spxentry{process\_date()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.process_date}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{process\_date}}}{\emph{date}}{}
Standardize input date
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the type of the date parameter cannot be converted to
    a pandas timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{process\_new\_df() (in module dalio.util)@\spxentry{process\_new\_df()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.process_new_df}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{process\_new\_df}}}{\emph{df1}, \emph{df2}, \emph{cols}, \emph{new\_cols}}{}
Process new dataframe given columns and new column names
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df1}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} first dataframe.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df2}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe to join or get columns from

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}) \textendash{} iterable of columns being targetted.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}) \textendash{} iterable of new column names.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{translate\_df() (in module dalio.util)@\spxentry{translate\_df()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{translate\_df}}}{\emph{translator}, \emph{df}, \emph{inplace=False}}{}
Translate dataframe column and index names in accordance to translator
dictionary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{translator}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} dictionary of \{original: translated\} key value
pairs.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} dataframe to have rows and columns translated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inplace}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to perform operation inplace or return a
translated copy. Optional. Defaults to False.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_efficient\_frontier() (in module dalio.util)@\spxentry{plot\_efficient\_frontier()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plot_efficient_frontier}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{plot\_efficient\_frontier}}}{\emph{cla}, \emph{points=100}, \emph{visible=25}, \emph{show\_assets=True}, \emph{ax=None}, \emph{**kwargs}}{}
Plot the efficient frontier based on a CLA object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of points to plot. Optional. Defaults to 100

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_assets}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether we should plot the asset risks/returns
also. Optional. Defaults to True.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} optional parameters for main graph.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_covariance() (in module dalio.util)@\spxentry{plot\_covariance()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plot_covariance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{plot\_covariance}}}{\emph{cov\_matrix}, \emph{plot\_correlation=False}, \emph{show\_tickers=True}, \emph{ax=None}}{}
Generate a basic plot of the covariance (or correlation) matrix,
given a covariance matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cov\_matrix}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} covariance matrix

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plot\_correlation}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to plot the correlation matrix
instead, defaults to False. Optional.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_tickers}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} whether to use tickers as labels (not
recommended for large portfolios). Optional. Defaults to True.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_weights() (in module dalio.util)@\spxentry{plot\_weights()}\spxextra{in module dalio.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dalio.util:dalio.util.plot_weights}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dalio.util.}}\sphinxbfcode{\sphinxupquote{plot\_weights}}}{\emph{weights}, \emph{ax=None}, \emph{**kwargs}}{}
Plot the portfolio weights as a horizontal bar chart
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} the weights outputted by any PyPortfolioOpt
optimiser.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplolib.axis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Axis to plot on. Optional. New axis will
be created if none is specified.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} optional parameters for main graph.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib axis

\end{description}\end{quote}

\end{fulllineitems}



\section{Understanding Graphs}
\label{\detokenize{beginners-guide:understanding-graphs}}\label{\detokenize{beginners-guide:beginners-guide}}\label{\detokenize{beginners-guide::doc}}

\subsection{What do I mean by “graphical structure”?}
\label{\detokenize{beginners-guide:what-do-i-mean-by-graphical-structure}}
In a graphical structures data is represented as nodes and operations as edges. Think of it as a way to represent many inter\sphinxhyphen{}connected transformations and their input and output data.


\subsection{Progressive Disclosure of Complexity}
\label{\detokenize{beginners-guide:progressive-disclosure-of-complexity}}
The main philosophy behind the graphical structure of Dal\sphinxhyphen{}io come from the Deep Learning library Keras. In their documentation, they state that “A core principle of Keras is \sphinxstylestrong{progressive disclosure of complexity}. You should always be able to get into lower\sphinxhyphen{}level workflows in a gradual way. You shouldn’t fall off a cliff if the high\sphinxhyphen{}level functionality doesn’t exactly match your use case. You should be able to gain more control over the small details while retaining a commensurate amount of high\sphinxhyphen{}level convenience.”

So you are familiar with Keras, you will understand that they provide users with a plethora of pre\sphinxhyphen{}implemented classes (layers and models) that fit into each other, though the user is also free to create subclasses of their own that can be integrated into the Deep Neural Network and interact with it as just another layer.

Likewise, all of the classes described below where made with the objective of being easily customized by more experienced users. After all, the great majority of objects you will be using where implemented like that! Once you feel like you got a hang of Dal\sphinxhyphen{}io and want to build your own pieces, check out the \sphinxhref{https://github.com/renatomatz/Dal-io}{source code} or the {\hyperref[\detokenize{developers-guide:developers-guide}]{\sphinxcrossref{\DUrole{std,std-ref}{Core Classes and Concepts}}}}.


\subsection{Why is a graphical structure optimal for financial modeling?}
\label{\detokenize{beginners-guide:why-is-a-graphical-structure-optimal-for-financial-modeling}}\begin{itemize}
\item {} 
Modern automated financial models retrieve data, clean and dirty, from various sources and through cleaning and integration are able to join them, further process this product and finally derive insights. The problem is that as these models utilize more and more data from various sources, created models tend to become confusing for both technical and non technical people. Also, as there is no unified workflow to deal with these, created models tend to become highly inflexible and lacking portability (onto other models or projects.) A graphical architecture offers an intuitive workflow for working with data, where inputs can have a unified translation, data can be constantly checked for validity and outputs can be used in flexible ways as parts of a bigger system or drive actions.

\item {} 
Utilizing large amounts of data can also end up being highly memory\sphinxhyphen{}inefficient when data sources are varied and outputs are as simple as a buy/sell command. As in the TensorFlow graphical architecture, using these constructs allow for automatic parallelization of models to better use modern hardware. Applications can also be built to fit multiple models, and updated independently from the rest of the system.

\item {} 
Graphs are easy to interpret visually, which is useful for understanding the flow of data and interpreting output or bugs. They are also highly flexible, allowing users to modify pieces or generate new connections while keeping an enforceable system of data integrity.

\item {} 
Perhaps most importantly, these graphs are extremely lightweight and portable, which is key for widespread distribution and access. While every piece can be accessed and tested on\sphinxhyphen{}the\sphinxhyphen{}go for better ease of development, they are ultimately just pieces of a bigger structure, where data flows continuously and leftover data is discarded automatically, keeping the memory and processing burden at a minimum when dealing with massive datasets.

\end{itemize}


\section{Base Classes}
\label{\detokenize{beginners-guide:base-classes}}
These are the classes you will use throughout an analysis, or rather a class that implements their functionality. Getting to know them is important as it makes it easier to identify one when you see one and make it easier to search for one when you don’t really remember where to find it.


\subsection{External \textless{}\_Node\textgreater{}}
\label{\detokenize{beginners-guide:external-node}}\label{\detokenize{beginners-guide:external}}
\sphinxstylestrong{Manage connections between your environment and an external source.}

Every model requires an origin to the data it uses, and often wants to send this data out again once it’s processed. Subclasses of \sphinxcode{\sphinxupquote{External}} will implement systems to manage the input and output of data to and from an external sources. An external source is any data or application located outside of your python environment. Two common examples are files and graphs. While these can be manipulated from the python environemt, the actual data is stored outside.

\sphinxcode{\sphinxupquote{External}} class instances will often be redundant with existing connection handlers, but at least subclasses will allow for more integrated connection handling and collection, so that you can have a single supplicant object for each external connection.

As a child class of \sphinxcode{\sphinxupquote{\_Node}},:code:\sphinxtitleref{External} implements the \sphinxcode{\sphinxupquote{.request(**kwargs)}} method, which takes in requests and executed valid ones on their external connections.

While this method is responsible for the main requests to and from the data, subclasses will often have other methods to perform more specific actions on it. Additionally, the \sphinxcode{\sphinxupquote{**kwargs}} parameter will rarely be the same as the one relayed through the \sphinxcode{\sphinxupquote{\_Transformer.run()}} as  \sphinxcode{\sphinxupquote{Translator}} and \sphinxcode{\sphinxupquote{Application}} instances will often curate these to be more generalizable to multiple \sphinxcode{\sphinxupquote{External}} implementations.

\sphinxstylestrong{What to Look For:}
\begin{itemize}
\item {} 
What the external source is.

\item {} 
Is it reliant on configuration? If so, what configuration parameters are required/considered?

\end{itemize}


\subsection{\_Transformer}
\label{\detokenize{beginners-guide:transformer}}
\sphinxstylestrong{Represent data transformations.}

\sphinxcode{\sphinxupquote{\_Transformer}} instances are defined by their inputs and outputs. IO can be limited to one or more sources and the source can be either internal or external (as defined in {\hyperref[\detokenize{beginners-guide:external}]{\sphinxcrossref{\DUrole{std,std-ref}{External \textless{}\_Node\textgreater{}}}}}).

All \sphinxcode{\sphinxupquote{\_Transformer}} instances implement the \sphinxcode{\sphinxupquote{.run(**kwargs)}} method to:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Request source data from a \sphinxcode{\sphinxupquote{\_Node}} instance.

\item {} 
Apply specific transformations to the sourced data.

\item {} 
Return the transformed data.

\end{enumerate}

This process will vary depending on the subclass, though the one thing to keep in mind is that the output of this method is what will be fed onto the next node on the graph, so it’s a powerful tool for debugging.

\sphinxcode{\sphinxupquote{\_Transformer}} instances also define each input in their initialization by using \sphinxcode{\sphinxupquote{Validator}} instances. You can find more about these in the \DUrole{xref,std,std-ref}{developers\sphinxhyphen{}guide} section on the {\hyperref[\detokenize{developers-guide:validator}]{\sphinxcrossref{\DUrole{std,std-ref}{Validator}}}} but for now, you can use the \sphinxcode{\sphinxupquote{\_Transformer.describe()}} method to get an idea of what kind of inputs this piece requires or prefers.

You won’t be using these directly in your analyses, but will definitely use one of its subclasses.

\sphinxstylestrong{What to Look For:}
\begin{itemize}
\item {} 
Number of input and outputs.

\item {} 
Sources/destinations of inputs and outputs.

\item {} 
Input descriptions.

\end{itemize}


\subsection{Translator \textless{}\_Transformer\textgreater{}}
\label{\detokenize{beginners-guide:translator-transformer}}
\sphinxstylestrong{Request and standardize external data.}

\sphinxstyleemphasis{One external input, one internal output}

While \sphinxcode{\sphinxupquote{External}} instances are the origin of all data, \sphinxcode{\sphinxupquote{Translator}} instances are the root of all \sphinxstyleemphasis{clean and standardized} data. Objects of this class have \sphinxcode{\sphinxupquote{External}} instances as their source and are tasked with creating requests understandable by that instance and standardize the response data into an acceptable format.

For more information on the Dal\sphinxhyphen{}io formatting standards, check out \DUrole{xref,std,std-ref}{formatting}.

All \sphinxcode{\sphinxupquote{Translator}} instances implement the \sphinxcode{\sphinxupquote{.run(**kwargs)}} method to:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Source data from an \sphinxcode{\sphinxupquote{External}} instance.

\item {} 
Translate the data into a format as specified by the formatting guide.

\item {} 
Return the translated data.

\end{enumerate}

These also tend to be the PipeLine stages where \sphinxcode{\sphinxupquote{kwargs}} source from.

\sphinxstylestrong{What to Look For:}
\begin{itemize}
\item {} 
Compatible \sphinxcode{\sphinxupquote{External}} instances.

\item {} 
What translation format is being used and how will the output contain.

\item {} 
What are the keyword arguments it can interpret.

\end{itemize}


\subsection{Pipe \textless{}\_Transformer\textgreater{}}
\label{\detokenize{beginners-guide:pipe-transformer}}
\sphinxstylestrong{Transform a single input into a single output.}

\sphinxstyleemphasis{One internal input, one internal output}

Pipes will compose the majority of data wranging and processing in your graphs, and are designed to be easily extendable by users.

All pipes must implement the \sphinxcode{\sphinxupquote{.transform(data, **kwargs)}} method, which takes in the output from sourced data and returns it transformed. This has three main purposes.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Subclasses can more objectively focus on transforming and outputting the \sphinxcode{\sphinxupquote{data}} parameter instead of having to deal with sourcing it.

\item {} 
It makes it possible to use \sphinxcode{\sphinxupquote{Pipe}} instances to transform data outside of the Dal\sphinxhyphen{}io library directly, which is useful for applications outside of the library’s scope or for testing the transformation.

\item {} 
More efficient compatibility with {\hyperref[\detokenize{beginners-guide:pipeline}]{\sphinxcrossref{\DUrole{std,std-ref}{PipeLine \textless{}Pipe\textgreater{}}}}} objects.

\end{enumerate}

All \sphinxcode{\sphinxupquote{Pipe}} instances implement the \sphinxcode{\sphinxupquote{.run(**kwargs)}} method to:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Define input requirements.

\item {} 
Source data from another \sphinxcode{\sphinxupquote{\_Transformer}} instance, applying integrity checks.

\item {} 
Pass it as the \sphinxcode{\sphinxupquote{data}} parameter to the \sphinxcode{\sphinxupquote{.transform()}} method.

\item {} 
Return the transformed data.

\end{enumerate}

While the default implementation of the \sphinxcode{\sphinxupquote{.run()}} method simply sources data and passes into \sphinxcode{\sphinxupquote{.transform}}, it is often changed to modify keyword arguments passed onto the source node and the .transform() call.

\sphinxstylestrong{What to Look For:}
\begin{itemize}
\item {} 
What are the input requirements.

\item {} 
What the \sphinxcode{\sphinxupquote{.transform}} method does.

\item {} 
What are changeable attributes that affect the data processing.

\end{itemize}


\subsection{Model \textless{}\_Transformer\textgreater{}}
\label{\detokenize{beginners-guide:model-transformer}}
\sphinxstylestrong{Utilize multiple input sources to get one output.}

\sphinxstyleemphasis{Multiple internal inputs, one internal output}

\sphinxcode{\sphinxupquote{Model}} instances are a lot like \sphinxcode{\sphinxupquote{Pipe}} instances as their main task it to transform inputs to get an output. Though taking in multiple inputs might not seem like enough to warrant a whole different class, the key differences come from all the extra considerations needed when creating a \sphinxcode{\sphinxupquote{Model}} instance.

There are two main uses for \sphinxcode{\sphinxupquote{Model}} instances:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Getting multiple inputs and joining them to form a single output.

\item {} 
Using the output of one of the inputs to format a request to another input.

\end{enumerate}

These objectives thus require a lot more flexibility when it comes to sourcing the inputs, which is why, unlike \sphinxcode{\sphinxupquote{Pipe}} instances, \sphinxcode{\sphinxupquote{Model}} instances do not have a \sphinxcode{\sphinxupquote{.transform()}} method, and instead rely solely on their \sphinxcode{\sphinxupquote{run()}} method to:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Source data from inputs.

\item {} 
Process and transform data.

\item {} 
(Possibly) source more data given the above transformations.

\item {} 
(Possibly) join all sourced data.

\item {} 
Return the final product.

\end{enumerate}

\sphinxstylestrong{What to Look For:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
All the input names and what they represent.

\item {} 
The requirements for each input.

\item {} 
How the \sphinxcode{\sphinxupquote{.run()}} method deals with each input piece.

\item {} 
What changeable attributes affect the data processing.

\end{enumerate}


\subsection{Application \textless{}Model\textgreater{}}
\label{\detokenize{beginners-guide:application-model}}
\sphinxstylestrong{Act on external sources}
\sphinxstyleemphasis{Multiple internal inputs, zero or more external or internal outputs}

While you might be using Dal\sphinxhyphen{}io mostly for processing data for further use in your python session, \sphinxcode{\sphinxupquote{Application}} instances offer methods of using this processed data to interact with external sources. These will be managed by \sphinxcode{\sphinxupquote{External}} instances which are called by the application with data it sources from its inputs. These interactions can take a broad range of forms, from simple printing to the console to graphing, executing trade orders or actively requesting more data from the inputs. Ultimately, \sphinxcode{\sphinxupquote{Application}} instances offer the greatest set of possibilities for users wanting to implement their own, as it is not bound by the scope of what the library can do.

All \sphinxcode{\sphinxupquote{Application}} instances implement the \sphinxcode{\sphinxupquote{.run(**kwargs)}} method to:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Source, validate, process and/or combine data from different inputs.

\item {} 
Use processed input data to send a request to an external source.

\item {} 
Get responses from external sources and further interactions.

\end{enumerate}

\sphinxstylestrong{What to Look For:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
All the input names and what they represent.

\item {} 
The requirements for each input.

\item {} 
All the output names and what they represent.

\item {} 
How the \sphinxcode{\sphinxupquote{.run()}} method deals with each input piece and how will it be transmitted to the output.

\end{enumerate}


\section{Extra Classes and Concepts}
\label{\detokenize{beginners-guide:extra-classes-and-concepts}}
Now that we’ve seen what will make your models work, lets jump into what will make your models \sphinxstylestrong{work incredibly.}


\subsection{PipeLine \textless{}Pipe\textgreater{}}
\label{\detokenize{beginners-guide:pipeline-pipe}}\label{\detokenize{beginners-guide:pipeline}}
As Pipe instances implement a normally small operation and have only one input and one output, you are able to join them together, through the \_\_add\_\_() internal method (which overrides the + operator) to create a sequence of transformations linked one after the other. These simply pass the output of one Pipe instance’s .transform() method as the input to another, which can be a significant speed boost, though you should be careful with data integrity here.

KEEP IN MIND that good alternatives to these is just linking Pipe instances together in order to validate the data at every stage of the pipeline. This will have the same output as a PipeLine, but compromise on speed and possibly aesthetics.


\subsection{Memory \textless{}\_Transformer\textgreater{}}
\label{\detokenize{beginners-guide:memory-transformer}}
When using APIs to fetch online data, there is often a delay that ranges from a few to a few dozen seconds. This might be completely fine if data will only pass through your model once to feed an application, for example, but will become a problem if you are also performing analyses on several pieces of the model or have several Model instances in your graph (which call on an input once for every source). The solution to this lies in Memory instances that temporarily save model inputs to some location and retrieves it when ran.

Notice that Memory inherits from a \_Transformer, which makes it compatible as input to any piece of your graph and behaves like any other input (most closely resembling a Pipe.)

Subclasses will implement different storage strategies for different locations. These will have their own data requirements and storage and retrieval logic \sphinxhyphen{} imagine the different in data structure, storage and retrieval required for storing data on a database vs on the local python session.

One thing to keep in mind is that these only store one piece of memory, so if you, for example, want to vary your .run() kwargs, this might not be the best option beyond building and debugging your model. If you still want the speed advantages of Memory while allowing for more runtime argument flexibility, check out the LazyRunner class below.


\subsection{LazyRunner \textless{}\_Transformer\textgreater{}}
\label{\detokenize{beginners-guide:lazyrunner-transformer}}
These objects are the solution to storing multiple Memory instances for different runtime kwargs that pass through the instance. These do not store the data itself, but rather the memory instances that do. This allows for more flexibility, as any single Memory subclass can be used to store the data. These are created when a new keyword argument is seen, and it does so by getting the data from a \_Transformer input and setting its result as the source of a new Memory instance. The Memory type and initialization arguments are all specified in the LazyRunner initialization.

KEEP IN MIND that these could mean a significant memory burden, if you are widely saving data from different inputs with several kwargs combinations passed on to them.

The solution to the memory problem comes in the buffer= initialization argument of the LazyRunner. These will limit the number of Memory instances that are saved at any point. This also comes with the update= initialization argument for whether or not stored Memory instances should be updated in FIFO order once the buffer is full or whether an error should be thrown.

KEEP IN MIND that this will not notice if its source data input has any sort of input changes itself (this could be a change in date range, for example or data source.) This will become a problem as changes will not be relayed if the runtime kwargs are the same as before a change. This happens as the LazyRunner will assume that nothing changed, see the kwarg and return the (old) saved version of the response. This can be solved by calling the .clear() method to reset the memory dictionary.


\subsection{Keyword Arguments}
\label{\detokenize{beginners-guide:keyword-arguments}}
Just like data propagates forward in the network through nodes and transformers, requests propagate backwards through \sphinxcode{\sphinxupquote{.run()}} and \sphinxcode{\sphinxupquote{request()}} keyword arguments. Though often you won’t need them (and much less often need to implement a new one), keyword arguments (aka kwargs) are a way on which a front piece of your graph can communicate with pieces before them at runtime. In essence, kwargs are passed from run to request over and over until they reach a node that can use them. These nodes can use these kwargs in different ways.They can:
\begin{itemize}
\item {} 
Use them to filter sourced data.

\item {} 
Use them to create another request, based on previously\sphinxhyphen{}unknown information.

\end{itemize}

Though they might seem like an amazing way of making your graph act more like a function, adding new kwarg requirements should be done very rarely and done with full knowledge of what are the taken kwarg names, as conflicting names will certainly cause several unforeseen bugs.


\section{Tips and Tricks}
\label{\detokenize{beginners-guide:tips-and-tricks}}

\subsection{Importing}
\label{\detokenize{beginners-guide:importing}}
As any other python (or any other programming language) workflow, we start with imports. Dal\sphinxhyphen{}io will often require several pieces to be used in a workflow, each of which is located within a submodule named after the base classes we have seen above. This means that importing the whole \sphinxcode{\sphinxupquote{dalio}} package and instantiating piece by piece will often create unappealing code, which is why the following techniques are preferred.

\sphinxstylestrong{Import submodules with an alias:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{external} \PYG{k}{as} \PYG{n+nn}{de}
\PYG{k+kn}{import} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{translator} \PYG{k}{as} \PYG{n+nn}{dt}
\PYG{k+kn}{import} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{pipe} \PYG{k}{as} \PYG{n+nn}{dp}
\PYG{k+kn}{import} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{model} \PYG{k}{as} \PYG{n+nn}{dm}
\PYG{k+kn}{import} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{application} \PYG{k}{as} \PYG{n+nn}{da}
\end{sphinxVerbatim}

This technique might not be the most standard or space efficient, but is very useful when you are still testing out models and architectures. For most worflows where you want to try out new paths and strategies, having these imports will give you all the core functionality you need while keeping your code clean.

\sphinxstylestrong{Import specific pieces from each submodule:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{external} \PYG{k+kn}{import} \PYG{n}{YahooDR}\PYG{p}{,} \PYG{n}{PyPlotGraph}

\PYG{k+kn}{from} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{translator} \PYG{k+kn}{import} \PYG{n}{YahooStockTranslator}

\PYG{k+kn}{from} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{pipe} \PYG{k+kn}{import} \PYG{p}{(}
    \PYG{n}{Change}\PYG{p}{,}
    \PYG{n}{ColSelect}\PYG{p}{,}
    \PYG{n}{Custom}\PYG{p}{,}
    \PYG{n}{DateSelect}\PYG{p}{,}
\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{model} \PYG{k+kn}{import} \PYG{p}{(}
    \PYG{n}{OptimumWeights}\PYG{p}{,}
    \PYG{n}{OptimumPortfolio}\PYG{p}{,}
\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{application} \PYG{k+kn}{import} \PYG{n}{Grapher}
\end{sphinxVerbatim}

This doing this is more standard to match common workflows like those in \sphinxcode{\sphinxupquote{keras}} and \sphinxcode{\sphinxupquote{sklearn}}  though can easily grow out of hand ind a Dal\sphinxhyphen{}io workflow, especially when trying to experiment with new inputs and pieces.

This is preferred once you have created a graph you are happy with and is ready for use. Importing all pieces explicitly not only makes your code more readable, it also makes the used pieces more explicit to the ones reading your implementation.

\sphinxstylestrong{A use hybrid approach:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{external} \PYG{k+kn}{import} \PYG{n}{YahooDR}\PYG{p}{,} \PYG{n}{PyPlotGraph}
\PYG{k+kn}{from} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{translator} \PYG{k+kn}{import} \PYG{n}{YahooStockTranslator}

\PYG{k+kn}{import} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{pipe} \PYG{k}{as} \PYG{n+nn}{dp}
\PYG{k+kn}{import} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{model} \PYG{k}{as} \PYG{n+nn}{dm}

\PYG{k+kn}{from} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{application} \PYG{k+kn}{import} \PYG{n}{Grapher}
\end{sphinxVerbatim}

This approach is a great way of reconciling both importing workflows, as it keeps the most relevant pieces of the graph explicit (the original input, the application and the final output) while giving you flexibility of accessing all \sphinxcode{\sphinxupquote{Pipe}} and \sphinxcode{\sphinxupquote{Model}} pieces available for testing.


\subsection{The Basic Workflow}
\label{\detokenize{beginners-guide:the-basic-workflow}}
Now that you are familiar with the most common parent classes used in the Dal\sphinxhyphen{}io system and ways of importing them, we can start talking about how a basic workflow with them will tend to look like.

We will separate our basic workflow into the following steps.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Set up imports.

\item {} 
Set up core data sources.

\item {} 
Data wrangling and processing.

\item {} 
Application set\sphinxhyphen{}up.

\end{enumerate}

\sphinxstylestrong{Set up imports:}

This is the stage where you use set up and configure any \sphinxcode{\sphinxupquote{External}} object instances and set them as inputs to a Translator. This defines the core of the data that will be sent to the rest of your graph, so it is always positive to have test runs of this raw input.

\sphinxstylestrong{Set up core data sources:}

Now that you have your inputs, perform any sort of transformations which will further standardize it to your specific needs. These can be selecting specific columns (like only the “close” column if your source gets OCHLV data) or joining sources.

This is an optional, yet often relevant step, and you should see this as a preparation to the data that will feed every step following this.

If we were to picture a graph with various nodes and edges which source data from a single node, this step is setting up a few nodes between the source and the actual first node that other pieces often get data from. In other words, no other pieces but the ones used in this step will be interacting with the pieces that come before it.

\sphinxstylestrong{Data wrangling and processing:}

This is the most general step and is all about setting up processing pipelines for your data. This might involve performing transformations, joining sources into models and maybe even setting up different diagnostic applications midway. Theres no overwhelming structure to these other than setting up the inputs that will feed your last nodes.

\sphinxstylestrong{Application set\sphinxhyphen{}up:}

While applications are not a requirement for a graph, they are often the very last nodes in one. Above that, \sphinxcode{\sphinxupquote{Application}} instances often have the largest burden of setup, so deciding all of their pieces and putting together inputs is a common last step.

Once applications are set up, the following analysis will be for the most part a process of actually using it or optimizing your results by tweaking some of the steps done previously.


\subsection{When Reading the Docs}
\label{\detokenize{beginners-guide:when-reading-the-docs}}
I find it that reading the docs can be a completely different experience depending on the package I am researching. Whether you want to find out whether a specific process currently exists in the Dal\sphinxhyphen{}io library or if you just want to get more specifications on a single piece you know exists, there are a couple of breadcrumbs left as part of the documentation structure that where placed to guide you there.

\sphinxstylestrong{Know how your piece fits:}

As you have seen throughout the beginners guide, every Dal\sphinxhyphen{}io piece inherits from a base class, which represents a certain state of data or transformation. Knowing well what you are looking for in terms of these states or transformations can go a long way on trying to find the submodule to look for the piece.

You can ask questions like:
\begin{itemize}
\item {} 
Is this a transformation on data or a representation of data?

\item {} 
How many inputs does this transformation have?

\item {} 
Are there any external inputs or outputs involved in this specific piece?

\end{itemize}

Beyond the base class submodules, these are further organized into different script folders to ensure there is further separation of what the base class implementations do. Definitely see what are the current available submodule “categories” to further narrow your search. The good thing is that while there are separated into links in the \DUrole{xref,std,std-ref}{user\sphinxhyphen{}modules} page, they are all joined together into the same specific submodule page.

\sphinxstylestrong{Know how to explore your piece:}

Once you have pinpointed your piece, explore its definition or source code to know how to fully utilize it in your specific case. While one could argue that only by going through the source could one fully understand an implementation’s full potential, this is often a tedious approach and definitely not beginner\sphinxhyphen{}friendly.

If you want to cut to the chase when it comes to knowing a function, look for the things specified under the “What to look for” sessions on each of the base class descriptions above.


\subsection{Must\sphinxhyphen{}Know Classes}
\label{\detokenize{beginners-guide:must-know-classes}}
Now that you are fully armed with the knowledge needed to venture into the package, let’s get you introduced to a couple of pieces the development team (currently composed of one) has used with frequently.
\index{Custom (class in dalio.pipe.col\_generation)@\spxentry{Custom}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.col_generation.Custom}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{Custom}}}{\emph{func}, \emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{strategy=\textquotesingle{}apply\textquotesingle{}}, \emph{axis=0}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Apply custom function.
\index{strategy (dalio.pipe.col\_generation.Custom attribute)@\spxentry{strategy}\spxextra{dalio.pipe.col\_generation.Custom attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.col_generation.Custom.strategy}}\pysigline{\sphinxbfcode{\sphinxupquote{strategy}}}
strategy for applying value function.
One of {[}“apply”, “transform”, “agg”, “pipe”{]}
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, default “pipe”

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}\PYG{p}{;} \PYG{k+kn}{from} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{pipe} \PYG{k+kn}{import} \PYG{n}{Custom}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2143}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{1321}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1255}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{years}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{avg\PYGZus{}revenue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{total\PYGZus{}rev} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{row}\PYG{p}{:} \PYG{n}{row}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{years}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{n}{row}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{avg\PYGZus{}revenue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{add\PYGZus{}total\PYGZus{}rev} \PYG{o}{=} \PYG{n}{Custom}\PYG{p}{(}\PYG{n}{total\PYGZus{}rev}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{total\PYGZus{}revenue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{add\PYGZus{}total\PYGZus{}rev}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   years  avg\PYGZus{}revenue  total\PYGZus{}revenue}
\PYG{g+go}{1      3         2143           6429}
\PYG{g+go}{2     10         1321          13210}
\PYG{g+go}{3      7         1255           8785}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{halfer}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{new} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{year/2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{row}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{years}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}
\PYG{g+gp}{... }           \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rev/2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{row}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{avg\PYGZus{}revenue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{new}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{half\PYGZus{}cols} \PYG{o}{=} \PYG{n}{Custom}\PYG{p}{(}\PYG{n}{halfer}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{half\PYGZus{}cols}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   years  avg\PYGZus{}revenue   rev/2  year/2}
\PYG{g+go}{1      3         2143  1071.5     1.5}
\PYG{g+go}{2     10         1321   660.5     5.0}
\PYG{g+go}{3      7         1255   627.5     3.5}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{func} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{df}\PYG{p}{:} \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{add\PYGZus{}equal} \PYG{o}{=} \PYG{n}{Custom}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A==B}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{strategy}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pipe}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{add\PYGZus{}equal}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{g+go}{   A  B   A==B}
\PYG{g+go}{1  3  3   True}
\PYG{g+go}{2  2  4  False}
\PYG{g+go}{3  1  5  False}
\end{sphinxVerbatim}
\index{\_\_init\_\_() (dalio.pipe.col\_generation.Custom method)@\spxentry{\_\_init\_\_()}\spxextra{dalio.pipe.col\_generation.Custom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.col_generation.Custom.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{func}, \emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{strategy=\textquotesingle{}apply\textquotesingle{}}, \emph{axis=0}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Initialize instance and set up input DataDef.

In Pipe instance initializations, data definitions are described
and attributes are checked.

\end{fulllineitems}


\end{fulllineitems}


The \sphinxcode{\sphinxupquote{Custom}} pipe does what the name implies: it applies a custom transformation to an input \sphinxcode{\sphinxupquote{pandas.DataFrame}} instance. It inherits most of its functionality from the :code”\sphinxtitleref{\_ColGeneration} abstract class, so reading its description will help you understand how flexible your transformations can be when it comes to reintegrating it back into the original dataframe while keeping its column structure intact.
\index{\_ColGeneration (class in dalio.pipe.col\_generation)@\spxentry{\_ColGeneration}\spxextra{class in dalio.pipe.col\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.col\_generation.}}\sphinxbfcode{\sphinxupquote{\_ColGeneration}}}{\emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{axis=0}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Generate column based on a selection from a dataframe.

These are very useful for simple operations or for testing, as no
additional class definitions or understanding of the documentation is
requred.
.. attribute:: columns
\begin{quote}

Column labels in the DataFrame
to be mapped.
\begin{quote}\begin{description}
\item[{type}] \leavevmode
single label or list\sphinxhyphen{}like

\end{description}\end{quote}
\end{quote}
\index{func (dalio.pipe.col\_generation.\_ColGeneration attribute)@\spxentry{func}\spxextra{dalio.pipe.col\_generation.\_ColGeneration attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration.func}}\pysigline{\sphinxbfcode{\sphinxupquote{func}}}
The function to be applied to each row of the
processed DataFrame.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
callable

\end{description}\end{quote}

\end{fulllineitems}

\index{result\_columns (dalio.pipe.col\_generation.\_ColGeneration attribute)@\spxentry{result\_columns}\spxextra{dalio.pipe.col\_generation.\_ColGeneration attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration.result_columns}}\pysigline{\sphinxbfcode{\sphinxupquote{result\_columns}}}
If list\sphinxhyphen{}like, labels
for the new columns resulting from the mapping operation. Must be
of the same length as columns. If str, the suffix mapped columns
gain if no new column labels are given. If None, behavior depends
on the replace parameter.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str or list\sphinxhyphen{}like, default None

\end{description}\end{quote}

\end{fulllineitems}

\index{axis (dalio.pipe.col\_generation.\_ColGeneration attribute)@\spxentry{axis}\spxextra{dalio.pipe.col\_generation.\_ColGeneration attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration.axis}}\pysigline{\sphinxbfcode{\sphinxupquote{axis}}}
axis to apply value funciton to. Irrelevant if
strategy = “pipe”.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int, default 1

\end{description}\end{quote}

\end{fulllineitems}

\index{drop (dalio.pipe.col\_generation.\_ColGeneration attribute)@\spxentry{drop}\spxextra{dalio.pipe.col\_generation.\_ColGeneration attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration.drop}}\pysigline{\sphinxbfcode{\sphinxupquote{drop}}}
If set to True, source columns are dropped
after being mapped.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool, default True

\end{description}\end{quote}

\end{fulllineitems}

\index{reintegrate (dalio.pipe.col\_generation.\_ColGeneration attribute)@\spxentry{reintegrate}\spxextra{dalio.pipe.col\_generation.\_ColGeneration attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration.reintegrate}}\pysigline{\sphinxbfcode{\sphinxupquote{reintegrate}}}
If set to False, modified version is
returned without being placed back into original dataframe. If set
to True, an insertion is attemtped; if the transformation changes
the data’s shape, a RuntimeError will be raised.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool, default False

\end{description}\end{quote}

\end{fulllineitems}

\index{\_args (dalio.pipe.col\_generation.\_ColGeneration attribute)@\spxentry{\_args}\spxextra{dalio.pipe.col\_generation.\_ColGeneration attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration._args}}\pysigline{\sphinxbfcode{\sphinxupquote{\_args}}}
arguments to be passed onto the function at execution time.

\end{fulllineitems}

\index{\_kwargs (dalio.pipe.col\_generation.\_ColGeneration attribute)@\spxentry{\_kwargs}\spxextra{dalio.pipe.col\_generation.\_ColGeneration attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration._kwargs}}\pysigline{\sphinxbfcode{\sphinxupquote{\_kwargs}}}
keyword arguments to be passed onto the function at
execution time.

\end{fulllineitems}

\index{\_\_init\_\_() (dalio.pipe.col\_generation.\_ColGeneration method)@\spxentry{\_\_init\_\_()}\spxextra{dalio.pipe.col\_generation.\_ColGeneration method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{*args}, \emph{columns=None}, \emph{new\_cols=None}, \emph{axis=0}, \emph{drop=True}, \emph{reintegrate=False}, \emph{**kwargs}}{}
Initialize instance and set up input DataDef.

In Pipe instance initializations, data definitions are described
and attributes are checked.

\end{fulllineitems}

\index{transform() (dalio.pipe.col\_generation.\_ColGeneration method)@\spxentry{transform()}\spxextra{dalio.pipe.col\_generation.\_ColGeneration method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.col_generation._ColGeneration.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}, \emph{**kwargs}}{}
Apply custom transformation and insert back as specified

This applies the transformation in three main steps:
1. Extract specified columns
2. Apply modification
3. Insert columns if needed or return modified dataframe

These steps have further details for dealing with levels.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{RuntimeError}} \textendash{} if transformed data is to be reintegrated but has a
    different shape than data being reintegrated on the dataframe.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


This class is extremely important as it essentially the user’s first point of entry into creating their custom transformations. \sphinxcode{\sphinxupquote{Custom}} pipes work by applying your specified function to either the dataframe’s rows or columns (specified through the :code”\sphinxtitleref{axis} parameter).

The application itself is divided into different pandas strategies (specified through the :code”\sphinxtitleref{strategy} parameter, set to \sphinxcode{\sphinxupquote{\textbackslash{}"apply\textbackslash{}"}} by default.) The strategies correspond to \sphinxcode{\sphinxupquote{pandas.DataFrame}} methods, really, so if you want to get to the specifics of its, just read the \sphinxhref{https://pandas.pydata.org/pandas-docs/stable/reference/index.html}{pandas documentaion} for the \sphinxcode{\sphinxupquote{\textbackslash{}"apply\textbackslash{}"}}, \sphinxcode{\sphinxupquote{\textbackslash{}"transform\textbackslash{}"}}, \sphinxcode{\sphinxupquote{\textbackslash{}"agg\textbackslash{}"}} and \sphinxcode{\sphinxupquote{\textbackslash{}"pipe\textbackslash{}"}} descriptions. But for most cases, you will be using two strategies.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}"apply\textbackslash{}"}}: here, each row or column is passed onto the custom function as \sphinxcode{\sphinxupquote{pd.Series}} instances. This is the most generic strategy and should used the most often.

\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}"pipe\textbackslash{}"}}: unlike \sphinxcode{\sphinxupquote{\textbackslash{}"apply\textbackslash{}"}}, here the whole dataframe is passed onto your custom function at once, which can be useful for experimenting with specific functions you might want to implement as a piece later.

\end{itemize}
\index{DateSelect (class in dalio.pipe.select)@\spxentry{DateSelect}\spxextra{class in dalio.pipe.select}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.select.DateSelect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{dalio.pipe.select.}}\sphinxbfcode{\sphinxupquote{DateSelect}}}{\emph{start=None}, \emph{end=None}}{}
Select a date range.

This is commonly left as a local variable to control date range being
used at a piece of a graph.
\index{\_start (dalio.pipe.select.DateSelect attribute)@\spxentry{\_start}\spxextra{dalio.pipe.select.DateSelect attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.select.DateSelect._start}}\pysigline{\sphinxbfcode{\sphinxupquote{\_start}}}
start date.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pd.Timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{\_end (dalio.pipe.select.DateSelect attribute)@\spxentry{\_end}\spxextra{dalio.pipe.select.DateSelect attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.select.DateSelect._end}}\pysigline{\sphinxbfcode{\sphinxupquote{\_end}}}
end date.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pd.Timestamp

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_end() (dalio.pipe.select.DateSelect method)@\spxentry{set\_end()}\spxextra{dalio.pipe.select.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.select.DateSelect.set_end}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_end}}}{\emph{end}}{}
Set the \_end attribute

\end{fulllineitems}

\index{set\_start() (dalio.pipe.select.DateSelect method)@\spxentry{set\_start()}\spxextra{dalio.pipe.select.DateSelect method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{beginners-guide:dalio.pipe.select.DateSelect.set_start}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_start}}}{\emph{start}}{}
Set the \_start attribute

\end{fulllineitems}


\end{fulllineitems}


This piece also has a name as intuitive as what it does. It essentially takes in a time series \sphinxcode{\sphinxupquote{pandas.DataFrame}} (one which has a \sphinxcode{\sphinxupquote{pandas.DatetimeIndex}} as its index) and returns a subset of its dates. What makes it so powerful is its use as a “remote control” for your input time interval.

This effectively gives you an adjustable “filter” that can be adjusted at any point of your analysis to decide what section of the data to perform it on, which is crucial in various kinds of time series analyses.

For an interesting use case of this, check out the backtesting cookbook!


\section{Core Classes and Concepts}
\label{\detokenize{developers-guide:core-classes-and-concepts}}\label{\detokenize{developers-guide:developers-guide}}\label{\detokenize{developers-guide::doc}}

\subsection{Validator}
\label{\detokenize{developers-guide:validator}}\label{\detokenize{developers-guide:id1}}
Validators are the building blocks of data integrity in the graph. As modularity is key, validators ensure that data sourced from a \sphinxcode{\sphinxupquote{\_DataDef}} is what it is mean to be or that errors are targeted to make debugging easier. Validators can have any attribute needed, but functionality is stored in the .validate function, which either passes warning data on or stops execution with an error. These can and should be reused with multiple \sphinxcode{\sphinxupquote{\_DataDef}} instances.


\subsection{\_Node}
\label{\detokenize{developers-guide:node}}
Node instances represent data. They have a connection to some data input, internal or external, and make requests to this data as well as ensure their integrity. These form the basis for External and \sphinxcode{\sphinxupquote{\_DataDef}} classes.


\subsection{\_DataDef \textless{}Node\textgreater{}}
\label{\detokenize{developers-guide:datadef-node}}
\sphinxcode{\sphinxupquote{\_DataDef}} instances are sources of data and implement mechanisms to ensure the integrity of that data, as input from sources is uncertain.

KEEP IN MIND that this is a tool only used by developers while creating new transformations, actual users do not enter in contact with neither \sphinxcode{\sphinxupquote{Validator}} nor \sphinxcode{\sphinxupquote{\_DataDef}} instances.

\sphinxstylestrong{Validation:} In order to hold descriptions true, the data is validated by a chain of \sphinxcode{\sphinxupquote{Validator}} functions before returning any actual data, in order to ensure that if data is actually returned, it is accurate to its descriptions and won’t break the subsequent transformation. These are referred to as descriptions inside \sphinxcode{\sphinxupquote{\_DataDef}} instances and are added to them upon initialization of a Transformer instance.

\sphinxstylestrong{Speed Concerns:} While it’s understandable that these might pose a significant speed burden to applications, they are designed to reduce these by as much as possible. Firstly, validations are not dependent on each other and can thus be parallelized. Also, they can be turned off as needed, though this must be done with caution.


\subsection{\_Builder}
\label{\detokenize{developers-guide:builder}}
Builders are a solution to the problem of standardizing several package workflows into something more consistent to the inexperienced user.

Take the \sphinxcode{\sphinxupquote{MakeARCH}} builder as an example. In the arch package, users have to assemble an ARCH model starting with an arch.mean model initialized \_with\_ the data, followed by setting arch.variance and arch.distribution objects, each with their own respective parameters. Keeping this interface would have been highly inflexible and required the user to essentially learn how to use the package from scratch. Inheriting from \sphinxcode{\sphinxupquote{\_Builder}} allowed the \sphinxcode{\sphinxupquote{MakeARCH}} pipe to maintain this flexibility of setting different pieces as well as creating the model’s structure before actually having any data (which wouldn’t be possible with the original package).


\section{Development Notes on Base Classes}
\label{\detokenize{developers-guide:development-notes-on-base-classes}}

\subsection{External \textless{}\_Node\textgreater{}}
\label{\detokenize{developers-guide:external-node}}
\sphinxstylestrong{Configuration:} Sources often require additional ids, secrets or paths in order to access their data. The .config attribute aims to summarize all key configuration details and data needed to access a resource. Additional functions can be added as needed to facilitate one\sphinxhyphen{}time connection needs.

\sphinxstylestrong{Factories:} Sources, typically web APIs, will give users various functionalities with the same base configurations. The .make() method can be implemented to return subclasses that inherit parent processing and configuration.


\subsection{Translator \textless{}\_Transformer\textgreater{}}
\label{\detokenize{developers-guide:translator-transformer}}

\subsection{Pipe \textless{}\_Transformer\textgreater{}}
\label{\detokenize{developers-guide:pipe-transformer}}

\subsection{Model \textless{}\_Transformer\textgreater{}}
\label{\detokenize{developers-guide:model-transformer}}

\subsection{Applications \textless{}Model\textgreater{}}
\label{\detokenize{developers-guide:applications-model}}

\section{Key Concepts, Differences and Philosophy}
\label{\detokenize{developers-guide:key-concepts-differences-and-philosophy}}

\subsection{running vs requesting}
\label{\detokenize{developers-guide:running-vs-requesting}}
You might have notices that classes that inherit from \textless{}Pipe\textgreater{} have .run() methods, classes that inherit from \textless{}Node\textgreater{} have .request() methods, both of which return some form of data. While these two essentially have the same output functionality, they differ in implementation, where .run() methods get data from a source and modifies is while .request() methods get data, also from some source, and validates it. Thus, the idea of a \sphinxcode{\sphinxupquote{\_DataDef}} compared to a Pipe becomes clearer.


\subsection{describing vs tagging}
\label{\detokenize{developers-guide:describing-vs-tagging}}
The \sphinxcode{\sphinxupquote{.tags}} and \sphinxcode{\sphinxupquote{.desc}} attributes might seem to be redundant, as both are used to describe some sort of data passing by them and both can be used to search for nodes in the graph. Firstly, and most importantly, the \sphinxcode{\sphinxupquote{.desc}} attribute is common to all \sphinxcode{\sphinxupquote{\_DataDef}} instances that inherit from another \sphinxcode{\sphinxupquote{\_DataDef}}, while the .tag attribute is unique to that node, unless it is also present on the parent \sphinxcode{\sphinxupquote{\_DataDef}} or shared with other DataDefs upon instantiation.

They also do defer in “strictness,” as tags will not be checked for truthfulness, while descriptions will be tested on the data, unless, of course, users turn checking off. Tags are included as a feature to allow more flexible, personalizeable descriptions that describe groups or structures within the graph rather than a certain functionality.


\chapter{Table of Contents}
\label{\detokenize{index:table-of-contents}}

\chapter{Introduction}
\label{\detokenize{index:introduction}}\label{\detokenize{index:id1}}
Dal\sphinxhyphen{}io is a financial modeling package for python aiming to facilitate the gathering, wrangling and analysis of financial data. The library uses \sphinxstylestrong{graphical object structures} and \sphinxstylestrong{progressive display of complexity} to make workflows suit the user’s specific proficiency in python without making efficiency
sacrifices.

The core library implements common workflows from well\sphinxhyphen{}supported packages and the means to flexibly interlink them, and aims to continue adding relevant features. However, the user is not constrained by these features, and is free to extend pieces through inheritance in order to implement extra functionality that can be used with the rest of the package. See {\hyperref[\detokenize{developers-guide:developers-guide}]{\sphinxcrossref{\DUrole{std,std-ref}{Core Classes and Concepts}}}} for more information on extending core features.


\chapter{Installation}
\label{\detokenize{index:installation}}\label{\detokenize{index:instalation}}
You can clone this repository from git using

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone https://github.com/renatomatz/Dal\PYGZhy{}io
\end{sphinxVerbatim}

If you are using Windows, make sure you are in the package folder to use the functionality and that you run the following command before importing the modules.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/path\PYGZhy{}to\PYGZhy{}dalio/Dal\PYGZhy{}io}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

For Linux and Mac, you can access the package contents from your python environment anywhere with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export PYTHONPATH=\PYGZdl{}PYTHONPATH:\PYGZdq{}path/to/Dal\PYGZhy{}io\PYGZdq{}
\end{sphinxVerbatim}


\chapter{A Guided Example}
\label{\detokenize{index:a-guided-example}}\label{\detokenize{index:id2}}
Let’s go through a quick example of what Dal\sphinxhyphen{}io can do. We’ll build a simple portfolio optimization workflow and test it out with some sample stocks.

This example will be fairly dry, so if you want to jump right into it with some understanding of the Dal\sphinxhyphen{}io mechanics, you can go through the {\hyperref[\detokenize{beginners-guide:beginners-guide}]{\sphinxcrossref{\DUrole{std,std-ref}{Understanding Graphs}}}} first. If you just want to see what the library is capable of, let’s get right to it.

We’ll start off by importing the Dal\sphinxhyphen{}io pieces

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k+kn}{import} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{external} \PYG{k}{as} \PYG{n+nn}{de}
\PYG{k+kn}{import} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{translator} \PYG{k}{as} \PYG{n+nn}{dt}
\PYG{k+kn}{import} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{pipe} \PYG{k}{as} \PYG{n+nn}{dp}
\PYG{k+kn}{import} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{model} \PYG{k}{as} \PYG{n+nn}{dm}
\PYG{k+kn}{import} \PYG{n+nn}{dalio}\PYG{n+nn}{.}\PYG{n+nn}{application} \PYG{k}{as} \PYG{n+nn}{da}
\end{sphinxVerbatim}

Specific pieces can also be imported individually, though for testing this sub\sphinxhyphen{}module import structure is preferred.

Now lets set up our stock data input from Yahoo! Finance.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tickers} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GOOG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MSFT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ATVI}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TTWO}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GM}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FORD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SPY}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}

\PYG{n}{stocks} \PYG{o}{=} \PYG{n}{dt}\PYG{o}{.}\PYG{n}{YahooStockTranslator}\PYG{p}{(}\PYG{p}{)}\PYGZbs{}
    \PYG{o}{.}\PYG{n}{set\PYGZus{}input}\PYG{p}{(}\PYG{n}{de}\PYG{o}{.}\PYG{n}{YahooDR}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Easy right? Notice that the stock input is composed of one external source (in this case \sphinxcode{\sphinxupquote{de.YahooDR}}) and one translator (\sphinxcode{\sphinxupquote{dt.YahooStockTranslator}}). This is the case for any input, with one piece getting raw data from an external source and another one translating it to a format friendly to Dal\sphinxhyphen{}io pieces. For more on formatting, go to \DUrole{xref,std,std-ref}{formatting}.

Notice the \sphinxcode{\sphinxupquote{.set\_input}} call that took in the YahooDR object. Every all translators, pipes, models and applications share this method that allows them to plug the output of another object as their own input. This idea of connecting different objects like nodes in a graph is at the core of the \sphinxstylestrong{graphical object design}.

At this point you can try out running the model with \sphinxcode{\sphinxupquote{stocks.run(ticker=tickers)}} which will get the OHLCV data for the ticker symbols assigned to :code”\sphinxtitleref{tickers}, though you can specify any ticker available in Yahoo! Finance. Notice that the column names where standardized to be all lower\sphinxhyphen{}case with underscores (\_) instead of spaces. This is performed as part of the translation step to ensure all imported data can be referenced with common string representations.

Now lets create a data processing pipeline for our input data.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{time\PYGZus{}conf} \PYG{o}{=} \PYG{n}{dp}\PYG{o}{.}\PYG{n}{DateSelect}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{close} \PYG{o}{=} \PYG{n}{dp}\PYG{o}{.}\PYG{n}{PipeLine}\PYG{p}{(}
    \PYG{n}{dp}\PYG{o}{.}\PYG{n}{ColSelect}\PYG{p}{(}\PYG{n}{columns}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{close}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{time\PYGZus{}conf}
\PYG{p}{)}\PYG{p}{(}\PYG{n}{stocks}\PYG{p}{)}

\PYG{n}{annual\PYGZus{}rets} \PYG{o}{=} \PYG{n}{close} \PYG{o}{+} \PYGZbs{}
    \PYG{n}{dp}\PYG{o}{.}\PYG{n}{Period}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{agg\PYGZus{}func}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
    \PYG{n}{dp}\PYG{o}{.}\PYG{n}{Change}\PYG{p}{(}\PYG{n}{strategy}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pct\PYGZus{}change}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{cov} \PYG{o}{=} \PYG{n}{dp}\PYG{o}{.}\PYG{n}{Custom}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{df}\PYG{p}{:} \PYG{n}{df}\PYG{o}{.}\PYG{n}{cov}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{strategy}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pipe}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYGZbs{}
    \PYG{o}{.}\PYG{n}{with\PYGZus{}input}\PYG{p}{(}\PYG{n}{annual\PYGZus{}rets}\PYG{p}{)}

\PYG{n}{exp\PYGZus{}rets} \PYG{o}{=} \PYG{n}{annual\PYGZus{}rets} \PYG{o}{+} \PYG{n}{dp}\PYG{o}{.}\PYG{n}{Custom}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{)}
\end{sphinxVerbatim}

That was a bit more challenging! Let’s take it step by step.

We started off defining a \sphinxcode{\sphinxupquote{DateSelect}} pipe (which we will use later) and passing it into a pipeline with other pipes to get a company’s annual returns. Pipelines aggregate zero or more Pipe objects and pass in a common input through all of their transformations. This skips data integrity checking while still allowing users to control pipes inside the pipeline from the outside (as we will with :code”\sphinxtitleref{time\_conf})

We then added a custom pipe that applies the np.mean function to the annual returns to get the expected returns for each stock.

Finally, we did the exact same thing but with a lambda that calls the pd.DataFrame internal method .cov() to get the dataframe’s covariance. As we will be passing the whole dataframe to the function at once, we set the Custom strategy to “pipe”.

Notice how we didn’t use \sphinxcode{\sphinxupquote{.set\_input()}} as we did before, that’s because we utilized alternative ways of establishing this same node\sphinxhyphen{}to\sphinxhyphen{}node connection.

We can connect nodes with:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxcode{\sphinxupquote{p1.set\_input(p2)}} set p1’s input to p2.

\item {} 
\sphinxcode{\sphinxupquote{p1.with\_input(p2)}} create a copy of p1 and set its input to p2.

\item {} 
\sphinxcode{\sphinxupquote{p1(p2)}} same as \sphinxcode{\sphinxupquote{p1.with\_input(p2)}}.

\item {} 
\sphinxcode{\sphinxupquote{pL + p2}} set p2 as the last transformation in the PipeLine pL.

\end{enumerate}

Now let’s set up our efficient frontier model, get the optimal weights and finally create our optimal portfolio model.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ef} \PYG{o}{=} \PYG{n}{dm}\PYG{o}{.}\PYG{n}{MakeEfficientFrontier}\PYG{p}{(}\PYG{n}{weight\PYGZus{}bounds}\PYG{o}{=}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYGZbs{}
    \PYG{o}{.}\PYG{n}{set\PYGZus{}input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sample\PYGZus{}covariance}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{cov}\PYG{p}{)}\PYGZbs{}
    \PYG{o}{.}\PYG{n}{set\PYGZus{}input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{expected\PYGZus{}returns}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{exp\PYGZus{}rets}\PYG{p}{)}\PYGZbs{}

\PYG{n}{weights} \PYG{o}{=} \PYG{n}{dp}\PYG{o}{.}\PYG{n}{OptimumWeights}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ef}\PYG{p}{)}\PYGZbs{}
    \PYG{o}{.}\PYG{n}{set\PYGZus{}piece}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{strategy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}sharpe}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{risk\PYGZus{}free\PYGZus{}rate}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}

\PYG{n}{opt\PYGZus{}port} \PYG{o}{=} \PYG{n}{dm}\PYG{o}{.}\PYG{n}{OptimumPortfolio}\PYG{p}{(}\PYG{p}{)}\PYGZbs{}
    \PYG{o}{.}\PYG{n}{set\PYGZus{}input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weights\PYGZus{}in}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{weights}\PYG{p}{)}\PYGZbs{}
    \PYG{o}{.}\PYG{n}{set\PYGZus{}input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{data\PYGZus{}in}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{close}\PYG{p}{)}
\end{sphinxVerbatim}

And those are two examples of Dal\sphinxhyphen{}io Models! As you can see, models can have multiple named inputs, which can be set the same way as you would in a pipe but also having to specify their name. You also saw an example of a Builder, which has pieces (that can be set with the \sphinxcode{\sphinxupquote{.set\_piece()}}) method which allow for more modular flexibility when deciding characteristics of certain pipes or models.We could go into what each source and pieces represents, but that can be better done through the documentation.

Now, as a final step, lets graph the performance of the optimal portfolio.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{graph} \PYG{o}{=} \PYG{n}{da}\PYG{o}{.}\PYG{n}{PandasXYGrapher}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{close}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{legend}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{upper\PYGZus{}right}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYGZbs{}
    \PYG{o}{.}\PYG{n}{set\PYGZus{}input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{data\PYGZus{}in}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{.}\PYG{n}{Index}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{(}\PYG{n}{opt\PYGZus{}port}\PYG{p}{)}\PYG{p}{)}\PYGZbs{}
    \PYG{o}{.}\PYG{n}{set\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{data\PYGZus{}out}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{de}\PYG{o}{.}\PYG{n}{PyPlotGraph}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Additionally, you can change the time range of the whole model at any point using the \sphinxcode{\sphinxupquote{time\_conf}} object we created all the way in the beginning. Below is an example of setting the dates from 2016 to 2020.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{time\PYGZus{}conf}\PYG{o}{.}\PYG{n}{set\PYGZus{}start}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2016\PYGZhy{}01\PYGZhy{}01}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{time\PYGZus{}conf}\PYG{o}{.}\PYG{n}{set\PYGZus{}end}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2019\PYGZhy{}12\PYGZhy{}31}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

And that’s it!

All that you have to do now is run the model with \sphinxcode{\sphinxupquote{graph.run(ticker=tickers)}} to
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Get stock data from Yahoo! Finance

\item {} 
Process data

\item {} 
Optimize portfolio weights

\item {} 
Get an optimum portfolio

\item {} 
Graph optimum portfolio

\end{enumerate}

Which yields this figure:

\noindent\sphinxincludegraphics{{port_opt_cook_graph}.png}

Notice how this \sphinxcode{\sphinxupquote{.run()}} call was the same as you did all the way back when you only had your imported data. This method is also common to all translators, pipes, models and applications, and it gives you the piece’s output.

This means you can get information of any of the stages you created like this, and for any stock that you’d like. For example, we can run the \sphinxcode{\sphinxupquote{weights}} object we created to get the weights associated with the portfolio we just plotted.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{weights}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{ticker}\PYG{o}{=}\PYG{n}{tickers}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}GOOG\PYGZsq{}: 0.45514,
 \PYGZsq{}MSFT\PYGZsq{}: 0.82602,
 \PYGZsq{}ATVI\PYGZsq{}: \PYGZhy{}0.49995,
 \PYGZsq{}TTWO\PYGZsq{}: 0.29241,
 \PYGZsq{}GM\PYGZsq{}: \PYGZhy{}0.43788,
 \PYGZsq{}FORD\PYGZsq{}: 0.38413,
 \PYGZsq{}SPY\PYGZsq{}: \PYGZhy{}0.01986\PYGZcb{}
\end{sphinxVerbatim}

Also, every time you run a set of stocks or time intervals, the new run will be automatically layered with the old one and indexed at 100, which can be great for comparing how multiple portfolios would have fared! To clear this, just re\sphinxhyphen{}define the graph.

Hope this example was enough to show how you can create clean and powerful models using just a few lines of code!


\chapter{Next Steps}
\label{\detokenize{index:next-steps}}\label{\detokenize{index:id3}}
If you read and enjoyed the example above, that’s great! Now comes the part where you get to understand its various pieces, workflows and internal logic for you to start creating your own models with Dal\sphinxhyphen{}io.

A good first step, if you haven’t already is reading the {\hyperref[\detokenize{beginners-guide:beginners-guide}]{\sphinxcrossref{\DUrole{std,std-ref}{Understanding Graphs}}}}.

If you understood these core concepts well and are ready for some more examples, check out the cookbook.

For those who want to adventure into creating your own pieces (and hopefully contributing to the library) can read the {\hyperref[\detokenize{developers-guide:developers-guide}]{\sphinxcrossref{\DUrole{std,std-ref}{Core Classes and Concepts}}}} as well as the \DUrole{xref,std,std-ref}{formatting}.

And as always, you can check the full breakdown of the modules with the ol’ reliable {\hyperref[\detokenize{modules:modules}]{\sphinxcrossref{\DUrole{std,std-ref}{User Modules}}}}.


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\label{\detokenize{index:id4}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{d}
\item\relax\sphinxstyleindexentry{dalio.application}\sphinxstyleindexpageref{dalio.application:\detokenize{module-dalio.application}}
\item\relax\sphinxstyleindexentry{dalio.application.application}\sphinxstyleindexpageref{dalio.application:\detokenize{module-dalio.application.application}}
\item\relax\sphinxstyleindexentry{dalio.application.graphers}\sphinxstyleindexpageref{dalio.application:\detokenize{module-dalio.application.graphers}}
\item\relax\sphinxstyleindexentry{dalio.application.printers}\sphinxstyleindexpageref{dalio.application:\detokenize{module-dalio.application.printers}}
\item\relax\sphinxstyleindexentry{dalio.base}\sphinxstyleindexpageref{dalio.base:\detokenize{module-dalio.base}}
\item\relax\sphinxstyleindexentry{dalio.base.builder}\sphinxstyleindexpageref{dalio.base:\detokenize{module-dalio.base.builder}}
\item\relax\sphinxstyleindexentry{dalio.base.constants}\sphinxstyleindexpageref{dalio.base:\detokenize{module-dalio.base.constants}}
\item\relax\sphinxstyleindexentry{dalio.base.datadef}\sphinxstyleindexpageref{dalio.base:\detokenize{module-dalio.base.datadef}}
\item\relax\sphinxstyleindexentry{dalio.base.memory}\sphinxstyleindexpageref{dalio.base:\detokenize{module-dalio.base.memory}}
\item\relax\sphinxstyleindexentry{dalio.base.node}\sphinxstyleindexpageref{dalio.base:\detokenize{module-dalio.base.node}}
\item\relax\sphinxstyleindexentry{dalio.base.transformer}\sphinxstyleindexpageref{dalio.base:\detokenize{module-dalio.base.transformer}}
\item\relax\sphinxstyleindexentry{dalio.external}\sphinxstyleindexpageref{dalio.external:\detokenize{module-dalio.external}}
\item\relax\sphinxstyleindexentry{dalio.external.external}\sphinxstyleindexpageref{dalio.external:\detokenize{module-dalio.external.external}}
\item\relax\sphinxstyleindexentry{dalio.external.file}\sphinxstyleindexpageref{dalio.external:\detokenize{module-dalio.external.file}}
\item\relax\sphinxstyleindexentry{dalio.external.image}\sphinxstyleindexpageref{dalio.external:\detokenize{module-dalio.external.image}}
\item\relax\sphinxstyleindexentry{dalio.external.web}\sphinxstyleindexpageref{dalio.external:\detokenize{module-dalio.external.web}}
\item\relax\sphinxstyleindexentry{dalio.model}\sphinxstyleindexpageref{dalio.model:\detokenize{module-dalio.model}}
\item\relax\sphinxstyleindexentry{dalio.model.basic}\sphinxstyleindexpageref{dalio.model:\detokenize{module-dalio.model.basic}}
\item\relax\sphinxstyleindexentry{dalio.model.financial}\sphinxstyleindexpageref{dalio.model:\detokenize{module-dalio.model.financial}}
\item\relax\sphinxstyleindexentry{dalio.model.model}\sphinxstyleindexpageref{dalio.model:\detokenize{module-dalio.model.model}}
\item\relax\sphinxstyleindexentry{dalio.model.statistical}\sphinxstyleindexpageref{dalio.model:\detokenize{module-dalio.model.statistical}}
\item\relax\sphinxstyleindexentry{dalio.ops}\sphinxstyleindexpageref{dalio.ops:\detokenize{module-dalio.ops}}
\item\relax\sphinxstyleindexentry{dalio.pipe}\sphinxstyleindexpageref{dalio.pipe:\detokenize{module-dalio.pipe}}
\item\relax\sphinxstyleindexentry{dalio.pipe.builders}\sphinxstyleindexpageref{dalio.pipe:\detokenize{module-dalio.pipe.builders}}
\item\relax\sphinxstyleindexentry{dalio.pipe.col\_generation}\sphinxstyleindexpageref{dalio.pipe:\detokenize{module-dalio.pipe.col_generation}}
\item\relax\sphinxstyleindexentry{dalio.pipe.forecast}\sphinxstyleindexpageref{dalio.pipe:\detokenize{module-dalio.pipe.forecast}}
\item\relax\sphinxstyleindexentry{dalio.pipe.pipe}\sphinxstyleindexpageref{dalio.pipe:\detokenize{module-dalio.pipe.pipe}}
\item\relax\sphinxstyleindexentry{dalio.pipe.select}\sphinxstyleindexpageref{dalio.pipe:\detokenize{module-dalio.pipe.select}}
\item\relax\sphinxstyleindexentry{dalio.translator}\sphinxstyleindexpageref{dalio.translator:\detokenize{module-dalio.translator}}
\item\relax\sphinxstyleindexentry{dalio.translator.file}\sphinxstyleindexpageref{dalio.translator:\detokenize{module-dalio.translator.file}}
\item\relax\sphinxstyleindexentry{dalio.translator.pdr}\sphinxstyleindexpageref{dalio.translator:\detokenize{module-dalio.translator.pdr}}
\item\relax\sphinxstyleindexentry{dalio.translator.quandl}\sphinxstyleindexpageref{dalio.translator:\detokenize{module-dalio.translator.quandl}}
\item\relax\sphinxstyleindexentry{dalio.translator.translator}\sphinxstyleindexpageref{dalio.translator:\detokenize{module-dalio.translator.translator}}
\item\relax\sphinxstyleindexentry{dalio.util}\sphinxstyleindexpageref{dalio.util:\detokenize{module-dalio.util}}
\item\relax\sphinxstyleindexentry{dalio.util.level\_utils}\sphinxstyleindexpageref{dalio.util:\detokenize{module-dalio.util.level_utils}}
\item\relax\sphinxstyleindexentry{dalio.util.plotting\_utils}\sphinxstyleindexpageref{dalio.util:\detokenize{module-dalio.util.plotting_utils}}
\item\relax\sphinxstyleindexentry{dalio.util.processing\_utils}\sphinxstyleindexpageref{dalio.util:\detokenize{module-dalio.util.processing_utils}}
\item\relax\sphinxstyleindexentry{dalio.util.transformation\_utils}\sphinxstyleindexpageref{dalio.util:\detokenize{module-dalio.util.transformation_utils}}
\item\relax\sphinxstyleindexentry{dalio.util.translation\_utils}\sphinxstyleindexpageref{dalio.util:\detokenize{module-dalio.util.translation_utils}}
\item\relax\sphinxstyleindexentry{dalio.validator}\sphinxstyleindexpageref{dalio.validator:\detokenize{module-dalio.validator}}
\item\relax\sphinxstyleindexentry{dalio.validator.array\_val}\sphinxstyleindexpageref{dalio.validator:\detokenize{module-dalio.validator.array_val}}
\item\relax\sphinxstyleindexentry{dalio.validator.base\_val}\sphinxstyleindexpageref{dalio.validator:\detokenize{module-dalio.validator.base_val}}
\item\relax\sphinxstyleindexentry{dalio.validator.pandas\_val}\sphinxstyleindexpageref{dalio.validator:\detokenize{module-dalio.validator.pandas_val}}
\item\relax\sphinxstyleindexentry{dalio.validator.presets}\sphinxstyleindexpageref{dalio.validator:\detokenize{module-dalio.validator.presets}}
\item\relax\sphinxstyleindexentry{dalio.validator.validator}\sphinxstyleindexpageref{dalio.validator:\detokenize{module-dalio.validator.validator}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}