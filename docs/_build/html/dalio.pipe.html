
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dalio.pipe package &#8212; Dal.io 0.0.1 documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="dalio.model package" href="dalio.model.html" />
    <link rel="prev" title="dalio.translator package" href="dalio.translator.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dalio.model.html" title="dalio.model package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dalio.translator.html" title="dalio.translator package"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Dal.io 0.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modules.html" accesskey="U">User Modules</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">dalio.pipe package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-dalio.pipe.builders">dalio.pipe.builders module</a></li>
<li><a class="reference internal" href="#module-dalio.pipe.col_generation">dalio.pipe.col_generation module</a></li>
<li><a class="reference internal" href="#module-dalio.pipe.forecast">dalio.pipe.forecast module</a></li>
<li><a class="reference internal" href="#module-dalio.pipe.pipe">dalio.pipe.pipe module</a></li>
<li><a class="reference internal" href="#module-dalio.pipe.select">dalio.pipe.select module</a></li>
<li><a class="reference internal" href="#module-dalio.pipe">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="dalio.translator.html"
                        title="previous chapter">dalio.translator package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dalio.model.html"
                        title="next chapter">dalio.model package</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/dalio.pipe.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="dalio-pipe-package">
<h1>dalio.pipe package<a class="headerlink" href="#dalio-pipe-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-dalio.pipe.builders">
<span id="dalio-pipe-builders-module"></span><h2>dalio.pipe.builders module<a class="headerlink" href="#module-dalio.pipe.builders" title="Permalink to this headline">¶</a></h2>
<p>Builder Pipes</p>
<dl class="class">
<dt id="dalio.pipe.builders.CovShrink">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.builders.</code><code class="sig-name descname">CovShrink</code><span class="sig-paren">(</span><em class="sig-param">frequency=252</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.CovShrink" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.PipeBuilder" title="dalio.pipe.pipe.PipeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.PipeBuilder</span></code></a></p>
<p>Perform Covariance Shrinkage on data</p>
<p>Builder with a single piece: shirnkage. Shrinkage defines what kind of
shrinkage to apply on a resultant covariance matrix. If none is set,
covariance will not be shrunk.</p>
<dl class="attribute">
<dt id="dalio.pipe.builders.CovShrink.frequency">
<code class="sig-name descname">frequency</code><a class="headerlink" href="#dalio.pipe.builders.CovShrink.frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>data time period frequency</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.CovShrink.build_model">
<code class="sig-name descname">build_model</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.CovShrink.build_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds Covariance Srhinkage object and returns selected shrinkage
strategy</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Function fitted on the data.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.CovShrink.check_name">
<code class="sig-name descname">check_name</code><span class="sig-paren">(</span><em class="sig-param">param</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.CovShrink.check_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if name and parameter combination is valid.</p>
<p>This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
_Builder. This also can be called from outside of a _Builder instance
to check for the validity of settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>piece</strong> (<em>str</em>) – name of the key in the piece dictionary.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – name option to be set to the piece.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.CovShrink.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.CovShrink.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt>
<code class="sig-name descname">frequency</code><em class="property">: int</em><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.CovShrink.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.CovShrink.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Build model using data get results.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A covariance matrix</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.builders.ExpectedReturns">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.builders.</code><code class="sig-name descname">ExpectedReturns</code><a class="headerlink" href="#dalio.pipe.builders.ExpectedReturns" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.PipeBuilder" title="dalio.pipe.pipe.PipeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.PipeBuilder</span></code></a></p>
<p>Get stock’s time series expected returns.</p>
<p>Builder with a single piece: return_model. return_model is what model to
get the expected returns from.</p>
<dl class="method">
<dt id="dalio.pipe.builders.ExpectedReturns.build_model">
<code class="sig-name descname">build_model</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.ExpectedReturns.build_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble pieces into a model given some data</p>
<p>The data will opten be optional, but several builder models will
require it to be fitted on initialization. Which further shows why
builders are necessary for context-agnostic graphs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – data that might be used to build the model.</p></li>
<li><p><strong>**kwargs</strong> – any additional argument used in building</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.ExpectedReturns.check_name">
<code class="sig-name descname">check_name</code><span class="sig-paren">(</span><em class="sig-param">param</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.ExpectedReturns.check_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if name and parameter combination is valid.</p>
<p>This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
_Builder. This also can be called from outside of a _Builder instance
to check for the validity of settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>piece</strong> (<em>str</em>) – name of the key in the piece dictionary.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – name option to be set to the piece.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.ExpectedReturns.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.ExpectedReturns.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds model using data and gets expected returns from it</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.builders.ExpectedShortfall">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.builders.</code><code class="sig-name descname">ExpectedShortfall</code><span class="sig-paren">(</span><em class="sig-param">quantiles=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.ExpectedShortfall" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.builders.ValueAtRisk" title="dalio.pipe.builders.ValueAtRisk"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.builders.ValueAtRisk</span></code></a></p>
<p>Get expected shortfal for given quantiles</p>
<p>See base class for more in depth explanation.</p>
<dl class="method">
<dt id="dalio.pipe.builders.ExpectedShortfall.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.ExpectedShortfall.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value at risk given by an arch model and calculate the
expected shortfall at given quantiles.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.builders.MakeARCH">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.builders.</code><code class="sig-name descname">MakeARCH</code><a class="headerlink" href="#dalio.pipe.builders.MakeARCH" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.PipeBuilder" title="dalio.pipe.pipe.PipeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.PipeBuilder</span></code></a></p>
<p>Build arch model and make it based on input data.</p>
<p>This class allows for the creation of arch models by configuring three
pieces: the mean, volatility and distribution. These are set after
initialization through the _Builder interface.</p>
<dl class="attribute">
<dt id="dalio.pipe.builders.MakeARCH._piece">
<code class="sig-name descname">_piece</code><a class="headerlink" href="#dalio.pipe.builders.MakeARCH._piece" title="Permalink to this definition">¶</a></dt>
<dd><p>see _Builder class.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.MakeARCH.assimilate">
<code class="sig-name descname">assimilate</code><span class="sig-paren">(</span><em class="sig-param">model</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.MakeARCH.assimilate" title="Permalink to this definition">¶</a></dt>
<dd><p>Assimilate core pieces of an existent ARCH Model.</p>
<p>Assimilation means setting this model’s’ pieces in accordance to an
existing model’s pieces. Assimilation is shallow, so only the main
pieces are assimilated, not their parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> (<em>ARCHModel</em>) – Existing ARCH Model.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.MakeARCH.build_model">
<code class="sig-name descname">build_model</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.MakeARCH.build_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Build ARCH Model using data, set pieces and their arguments</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A built arch model from the arch package.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.MakeARCH.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.MakeARCH.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Build model with sourced data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.builders.OptimumWeights">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.builders.</code><code class="sig-name descname">OptimumWeights</code><a class="headerlink" href="#dalio.pipe.builders.OptimumWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.PipeBuilder" title="dalio.pipe.pipe.PipeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.PipeBuilder</span></code></a></p>
<p>Get optimum portfolio weights from an efficient frontier or CLA.
This is also a builder with one piece: strategy. The strategy piece
refers to the optimization strategy.</p>
<dl class="method">
<dt id="dalio.pipe.builders.OptimumWeights.build_model">
<code class="sig-name descname">build_model</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.OptimumWeights.build_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble pieces into a model given some data</p>
<p>The data will opten be optional, but several builder models will
require it to be fitted on initialization. Which further shows why
builders are necessary for context-agnostic graphs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – data that might be used to build the model.</p></li>
<li><p><strong>**kwargs</strong> – any additional argument used in building</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.OptimumWeights.check_name">
<code class="sig-name descname">check_name</code><span class="sig-paren">(</span><em class="sig-param">param</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.OptimumWeights.check_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if name and parameter combination is valid.</p>
<p>This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
_Builder. This also can be called from outside of a _Builder instance
to check for the validity of settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>piece</strong> (<em>str</em>) – name of the key in the piece dictionary.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – name option to be set to the piece.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.OptimumWeights.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.OptimumWeights.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Get efficient frontier, fit it to model and get weights</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.builders.PandasLinearModel">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.builders.</code><code class="sig-name descname">PandasLinearModel</code><a class="headerlink" href="#dalio.pipe.builders.PandasLinearModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.PipeBuilder" title="dalio.pipe.pipe.PipeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.PipeBuilder</span></code></a></p>
<p>Create a linear model from input pandas dataframe, using its index
as the X value.</p>
<p>This builder is made up of a single piece: strategy. This piece sets
which linear model should be used to fit the data.</p>
<dl class="method">
<dt id="dalio.pipe.builders.PandasLinearModel.build_model">
<code class="sig-name descname">build_model</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.PandasLinearModel.build_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Build model by returning the chosen model and initialization
parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Unfitted linear model</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.PandasLinearModel.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.PandasLinearModel.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up fitting parameters and fit built model.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Fitted linear model</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.builders.StockComps">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.builders.</code><code class="sig-name descname">StockComps</code><span class="sig-paren">(</span><em class="sig-param">strategy='sic_code'</em>, <em class="sig-param">max_ticks=6</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.StockComps" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a></p>
<p>Get a list of a ticker’s comparable stocks</p>
<p>This can utilize any strategy of getting stock comparative companies and
return up to a certain ammount of comps.</p>
<dl class="attribute">
<dt id="dalio.pipe.builders.StockComps._strategy">
<code class="sig-name descname">_strategy</code><a class="headerlink" href="#dalio.pipe.builders.StockComps._strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>comparisson strategy name or function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str, callable</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dalio.pipe.builders.StockComps.max_ticks">
<code class="sig-name descname">max_ticks</code><a class="headerlink" href="#dalio.pipe.builders.StockComps.max_ticks" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum number of tickers to return.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.StockComps.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.StockComps.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt>
<code class="sig-name descname">max_ticks</code><em class="property">: int</em><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.StockComps.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.StockComps.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets ticker argument and passes an empty ticker request to
transform.</p>
<p>Empty ticker requests are supposed to return all tickers available in
a source, so this allows the compariisson to be made in all stocks
from a certain source.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if ticker is more than a single symbol.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.StockComps.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.StockComps.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Get comps according to the set strategy</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.builders.ValueAtRisk">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.builders.</code><code class="sig-name descname">ValueAtRisk</code><span class="sig-paren">(</span><em class="sig-param">quantiles=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.ValueAtRisk" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a></p>
<p>Get the value at risk for data based on an ARHC Model</p>
<p>This takes in an ARCH Model maker, not data, which might be unintuitive,
yet necessary, as this allows users to modify the ARCH model generating
these values separately. A useful strategy that allows for this
is using a pipeline with an arch model as its first input and a
ValueAtRisk instance as its second layer. This allows us to treat the
PipeLine as a data input with VaR output and still have control over the
ARCH Model pieces (given you left a local variable for it behind.)</p>
<dl class="attribute">
<dt id="dalio.pipe.builders.ValueAtRisk._quantiles">
<code class="sig-name descname">_quantiles</code><a class="headerlink" href="#dalio.pipe.builders.ValueAtRisk._quantiles" title="Permalink to this definition">¶</a></dt>
<dd><p>list of quantiles to check the value at risk for.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.ValueAtRisk.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.ValueAtRisk.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.builders.ValueAtRisk.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.builders.ValueAtRisk.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Get values at risk at each quantile and each results maximum
exedence from the mean.</p>
<p>The maximum exedence columns tells which quantile the loss is placed
on. The word “maximum” might be misleading as it is compared to the
minimum quantile, however, this definition is accurate as the column
essentially answers the question: “what quantile furthest away from
the mean does the data exeed?”</p>
<p>Thank you for the creators of the arch package for the beautiful
visualizations and ideas!</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – if ARCH model does not have returns. This is often
    the case for unfitted models. Ensure your graph is complete.</p></li>
<li><p><strong>TypeError</strong> – if ARCH model has unsuported distribution parameter.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-dalio.pipe.col_generation">
<span id="dalio-pipe-col-generation-module"></span><h2>dalio.pipe.col_generation module<a class="headerlink" href="#module-dalio.pipe.col_generation" title="Permalink to this headline">¶</a></h2>
<p>Implement transformations that generates new colums from exising ones</p>
<dl class="class">
<dt id="dalio.pipe.col_generation.Bin">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.col_generation.</code><code class="sig-name descname">Bin</code><span class="sig-paren">(</span><em class="sig-param">bin_map</em>, <em class="sig-param">*args</em>, <em class="sig-param">bin_strat='normal'</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.Bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.col_generation.Custom" title="dalio.pipe.col_generation.Custom"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation.Custom</span></code></a></p>
<p>A pipeline stage that adds a binned version of a column or columns.</p>
<p>If drop is set to True the new columns retain the names of the source
columns; otherwise, the resulting column gain the suffix ‘_bin’</p>
<dl class="attribute">
<dt id="dalio.pipe.col_generation.Bin.bin_map">
<code class="sig-name descname">bin_map</code><a class="headerlink" href="#dalio.pipe.col_generation.Bin.bin_map" title="Permalink to this definition">¶</a></dt>
<dd><p>implicitly projects a left-most bin containing
all elements smaller than the left-most end point and a right-most
bin containing all elements larger that the right-most end point.
For example, the list [0, 5, 8] is interpreted as
the bins (-∞, 0), [0-5), [5-8) and [8, ∞).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dalio.pipe.col_generation.Bin.bin_strat">
<code class="sig-name descname">bin_strat</code><a class="headerlink" href="#dalio.pipe.col_generation.Bin.bin_strat" title="Permalink to this definition">¶</a></dt>
<dd><p>binning strategy to use. “normal”
uses the default binning strategy per a list of value separations
or number of bins. “quantile” uses a list of quantiles or a
preset quantile range (4 for quartiles and 10 for deciles).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str, default “normal”</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;speed&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">Bin</span><span class="p">({</span><span class="s1">&#39;speed&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]},</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   speed speed_bin</span>
<span class="go">1     -3        &lt;5</span>
<span class="go">2      4        &lt;5</span>
<span class="go">3      5        5≤</span>
<span class="go">4      9        5≤</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">Bin</span><span class="p">({</span><span class="s1">&#39;speed&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">]},</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   speed speed_bin</span>
<span class="go">1     -3        &lt;0</span>
<span class="go">2      4       0-5</span>
<span class="go">3      5       5-8</span>
<span class="go">4      9        8≤</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="dalio.pipe.col_generation.BoxCox">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.col_generation.</code><code class="sig-name descname">BoxCox</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">non_neg=False</em>, <em class="sig-param">const_shift=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.BoxCox" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.col_generation.Custom" title="dalio.pipe.col_generation.Custom"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation.Custom</span></code></a></p>
<p>A pipeline stage that applies the BoxCox transformation on data.</p>
<dl class="attribute">
<dt id="dalio.pipe.col_generation.BoxCox.const_shift">
<code class="sig-name descname">const_shift</code><a class="headerlink" href="#dalio.pipe.col_generation.BoxCox.const_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>If given, each transformed column is
first shifted by this constant. If non_neg is True then that
transformation is applied first, and only then is the column
shifted by this constant.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.col_generation.Change">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.col_generation.</code><code class="sig-name descname">Change</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">strategy='diff'</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.Change" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="beginners-guide.html#dalio.pipe.col_generation._ColGeneration" title="dalio.pipe.col_generation._ColGeneration"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation._ColGeneration</span></code></a></p>
<p>Perform item-by-item change</p>
<p>This has two main forms, percentage change and absolute change
(difference).</p>
<dl class="attribute">
<dt id="dalio.pipe.col_generation.Change._strategy">
<code class="sig-name descname">_strategy</code><a class="headerlink" href="#dalio.pipe.col_generation.Change._strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>change strategy.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str, callable</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.col_generation.Change.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.Change.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.col_generation.Custom">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.col_generation.</code><code class="sig-name descname">Custom</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">strategy='apply'</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.Custom" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="beginners-guide.html#dalio.pipe.col_generation._ColGeneration" title="dalio.pipe.col_generation._ColGeneration"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation._ColGeneration</span></code></a></p>
<p>Apply custom function.</p>
<dl class="attribute">
<dt id="dalio.pipe.col_generation.Custom.strategy">
<code class="sig-name descname">strategy</code><a class="headerlink" href="#dalio.pipe.col_generation.Custom.strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>strategy for applying value function.
One of [“apply”, “transform”, “agg”, “pipe”]</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str, default “pipe”</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">from</span> <span class="nn">dalio.pipe</span> <span class="kn">import</span> <span class="n">Custom</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2143</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1321</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1255</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;years&#39;</span><span class="p">,</span> <span class="s1">&#39;avg_revenue&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">total_rev</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;years&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;avg_revenue&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add_total_rev</span> <span class="o">=</span> <span class="n">Custom</span><span class="p">(</span><span class="n">total_rev</span><span class="p">,</span> <span class="s1">&#39;total_revenue&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add_total_rev</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   years  avg_revenue  total_revenue</span>
<span class="go">1      3         2143           6429</span>
<span class="go">2     10         1321          13210</span>
<span class="go">3      7         1255           8785</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">halfer</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">new</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;year/2&#39;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;years&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>           <span class="s1">&#39;rev/2&#39;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;avg_revenue&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">}</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">half_cols</span> <span class="o">=</span> <span class="n">Custom</span><span class="p">(</span><span class="n">halfer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">half_cols</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   years  avg_revenue   rev/2  year/2</span>
<span class="go">1      3         2143  1071.5     1.5</span>
<span class="go">2     10         1321   660.5     5.0</span>
<span class="go">3      7         1255   627.5     3.5</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;B&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add_equal</span> <span class="o">=</span> <span class="n">Custom</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;A==B&quot;</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;pipe&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add_equal</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   A  B   A==B</span>
<span class="go">1  3  3   True</span>
<span class="go">2  2  4  False</span>
<span class="go">3  1  5  False</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.col_generation.Custom.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.Custom.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.col_generation.CustomByCols">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.col_generation.</code><code class="sig-name descname">CustomByCols</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">strategy='apply'</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.CustomByCols" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.col_generation.Custom" title="dalio.pipe.col_generation.Custom"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation.Custom</span></code></a></p>
<p>A pipeline stage applying a function to individual columns iteratively.</p>
<dl class="attribute">
<dt id="dalio.pipe.col_generation.CustomByCols.func">
<code class="sig-name descname">func</code><a class="headerlink" href="#dalio.pipe.col_generation.CustomByCols.func" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to be applied to each element of the
given columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>function</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dalio.pipe.col_generation.CustomByCols.strategy">
<code class="sig-name descname">strategy</code><a class="headerlink" href="#dalio.pipe.col_generation.CustomByCols.strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Application strategy. Different from Custom class’
strategy parameter (which here is kept at “apply”) as this will
now be done on a series (each column). Extra care should be taken
to ensure resulting column lengths match.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">math</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">3.2</span><span class="p">,</span> <span class="s2">&quot;acd&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mf">7.2</span><span class="p">,</span> <span class="s2">&quot;alk&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mf">12.1</span><span class="p">,</span> <span class="s2">&quot;alk&quot;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;ph&quot;</span><span class="p">,</span><span class="s2">&quot;lbl&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">round_ph</span> <span class="o">=</span> <span class="n">pdp</span><span class="o">.</span><span class="n">ApplyByCols</span><span class="p">(</span><span class="s2">&quot;ph&quot;</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">round_ph</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   ph  lbl</span>
<span class="go">1   4  acd</span>
<span class="go">2   8  alk</span>
<span class="go">3  13  alk</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="dalio.pipe.col_generation.Index">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.col_generation.</code><code class="sig-name descname">Index</code><span class="sig-paren">(</span><em class="sig-param">index_at</em>, <em class="sig-param">*args</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="beginners-guide.html#dalio.pipe.col_generation._ColGeneration" title="dalio.pipe.col_generation._ColGeneration"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation._ColGeneration</span></code></a></p>
<dl class="method">
<dt id="dalio.pipe.col_generation.Index.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.Index.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.col_generation.Log">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.col_generation.</code><code class="sig-name descname">Log</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">non_neg=False</em>, <em class="sig-param">const_shift=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.Log" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.col_generation.Custom" title="dalio.pipe.col_generation.Custom"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation.Custom</span></code></a></p>
<p>A pipeline stage that log-transforms numeric data.</p>
<dl class="attribute">
<dt id="dalio.pipe.col_generation.Log.non_neg">
<code class="sig-name descname">non_neg</code><a class="headerlink" href="#dalio.pipe.col_generation.Log.non_neg" title="Permalink to this definition">¶</a></dt>
<dd><p>If True, each transformed column is
first shifted by smallest negative value it includes
(non-negative columns are thus not shifted).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool, default False</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dalio.pipe.col_generation.Log.const_shift">
<code class="sig-name descname">const_shift</code><a class="headerlink" href="#dalio.pipe.col_generation.Log.const_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>If given, each transformed column is
first shifted by this constant. If non_neg is True then that
transformation is applied first, and only then is the column
shifted by this constant.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">3.2</span><span class="p">,</span> <span class="s2">&quot;acd&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mf">7.2</span><span class="p">,</span> <span class="s2">&quot;alk&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mf">12.1</span><span class="p">,</span> <span class="s2">&quot;alk&quot;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;ph&quot;</span><span class="p">,</span><span class="s2">&quot;lbl&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log_stage</span> <span class="o">=</span> <span class="n">pdp</span><span class="o">.</span><span class="n">Log</span><span class="p">(</span><span class="s2">&quot;ph&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log_stage</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">         ph  lbl</span>
<span class="go">1  1.163151  acd</span>
<span class="go">2  1.974081  alk</span>
<span class="go">3  2.493205  alk</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="dalio.pipe.col_generation.MapColVals">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.col_generation.</code><code class="sig-name descname">MapColVals</code><span class="sig-paren">(</span><em class="sig-param">value_map</em>, <em class="sig-param">*args</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.MapColVals" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.col_generation.Custom" title="dalio.pipe.col_generation.Custom"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation.Custom</span></code></a></p>
<p>A pipeline stage that reintegrates the values of a column by a map.</p>
<dl class="attribute">
<dt id="dalio.pipe.col_generation.MapColVals.value_map">
<code class="sig-name descname">value_map</code><a class="headerlink" href="#dalio.pipe.col_generation.MapColVals.value_map" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary mapping
existing values to new ones. Values not in the dictionary as keys
will be converted to NaN. If a function is given, it is applied
element-wise to given columns. If a Series is given, values are
mapped by its index to its values.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict, function or pandas.Series</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="s1">&#39;UK&#39;</span><span class="p">,</span> <span class="s1">&#39;USSR&#39;</span><span class="p">,</span> <span class="s1">&#39;US&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Medal&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value_map</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;Gold&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;Silver&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;Bronze&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">MapColVals</span><span class="p">(</span><span class="s1">&#39;Medal&#39;</span><span class="p">,</span> <span class="n">value_map</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">       Medal</span>
<span class="go">UK      Gold</span>
<span class="go">USSR  Bronze</span>
<span class="go">US    Silver</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="dalio.pipe.col_generation.Period">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.col_generation.</code><code class="sig-name descname">Period</code><span class="sig-paren">(</span><em class="sig-param">period</em>, <em class="sig-param">*args</em>, <em class="sig-param">agg_func=&lt;function mean&gt;</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.Period" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="beginners-guide.html#dalio.pipe.col_generation._ColGeneration" title="dalio.pipe.col_generation._ColGeneration"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation._ColGeneration</span></code></a></p>
<p>Resample input time series data to a different period</p>
<blockquote>
<div><dl class="simple">
<dt>Attributes:</dt><dd><p>agg_func (callable): function to aggregate data to one period.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt># Quandl Input</dt><dd><blockquote>
<div><p>Default set to np.mean.</p>
</div></blockquote>
<dl class="simple">
<dt>_period (str): period to resample data to. Can be either daily,</dt><dd><p>monthly, quarterly or yearly.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="attribute">
<dt id="dalio.pipe.col_generation.Period.agg_func">
<code class="sig-name descname">agg_func</code><em class="property">: Callable[[Iterable], Any]</em><em class="property"> = None</em><a class="headerlink" href="#dalio.pipe.col_generation.Period.agg_func" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dalio.pipe.col_generation.Period.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.Period.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.col_generation.Rolling">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.col_generation.</code><code class="sig-name descname">Rolling</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">rolling_window=2</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.Rolling" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="beginners-guide.html#dalio.pipe.col_generation._ColGeneration" title="dalio.pipe.col_generation._ColGeneration"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation._ColGeneration</span></code></a></p>
<p>Apply rolling function</p>
<dl class="attribute">
<dt id="dalio.pipe.col_generation.Rolling.rolling_window">
<code class="sig-name descname">rolling_window</code><a class="headerlink" href="#dalio.pipe.col_generation.Rolling.rolling_window" title="Permalink to this definition">¶</a></dt>
<dd><p>rolling window to apply
function. If none, no rolling window is applied.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int, defailt None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.col_generation.Rolling.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.Rolling.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.col_generation.StockReturns">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.col_generation.</code><code class="sig-name descname">StockReturns</code><span class="sig-paren">(</span><em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.col_generation.StockReturns" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="beginners-guide.html#dalio.pipe.col_generation._ColGeneration" title="dalio.pipe.col_generation._ColGeneration"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation._ColGeneration</span></code></a></p>
<p>Perform percent change and minor aesthetic changes to data</p>
</dd></dl>

</div>
<div class="section" id="module-dalio.pipe.forecast">
<span id="dalio-pipe-forecast-module"></span><h2>dalio.pipe.forecast module<a class="headerlink" href="#module-dalio.pipe.forecast" title="Permalink to this headline">¶</a></h2>
<p>Transformations makes forecasts based on data</p>
<dl class="class">
<dt id="dalio.pipe.forecast.Forecast">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.forecast.</code><code class="sig-name descname">Forecast</code><span class="sig-paren">(</span><em class="sig-param">horizon=10</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.forecast.Forecast" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a></p>
<p>Generalized forecasting class.</p>
<p>This should be used mostly for subclassing or very generic forecasting
interfaces.</p>
<dl class="attribute">
<dt id="dalio.pipe.forecast.Forecast.horizon">
<code class="sig-name descname">horizon</code><a class="headerlink" href="#dalio.pipe.forecast.Forecast.horizon" title="Permalink to this definition">¶</a></dt>
<dd><p>how many steps ahead to forecast</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt>
<code class="sig-name descname">horizon</code><em class="property">: int</em><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dalio.pipe.forecast.Forecast.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.forecast.Forecast.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return forecast of data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.forecast.GARCHForecast">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.forecast.</code><code class="sig-name descname">GARCHForecast</code><span class="sig-paren">(</span><em class="sig-param">start=None</em>, <em class="sig-param">horizon=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.forecast.GARCHForecast" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.forecast.Forecast" title="dalio.pipe.forecast.Forecast"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.forecast.Forecast</span></code></a></p>
<p>Forecast data based on a fitted GARCH model</p>
<dl class="attribute">
<dt id="dalio.pipe.forecast.GARCHForecast._start">
<code class="sig-name descname">_start</code><a class="headerlink" href="#dalio.pipe.forecast.GARCHForecast._start" title="Permalink to this definition">¶</a></dt>
<dd><p>forecast start time and date.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>pd.Timestamp</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.forecast.GARCHForecast.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.forecast.GARCHForecast.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a mean, variance and residual variance forecast.</p>
<p>Forecast will be made for the specified horizon starting at the
specified time. This means that will only get data for the steps
starting at the specified start date and the steps after it.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A DataFrame with the columns MEAN, VARIANCE and RESIDUAL_VARIANCE
for the time horizon after the start date.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-dalio.pipe.pipe">
<span id="dalio-pipe-pipe-module"></span><h2>dalio.pipe.pipe module<a class="headerlink" href="#module-dalio.pipe.pipe" title="Permalink to this headline">¶</a></h2>
<p>Defines the Pipe and PipeLine classes</p>
<p>Pipes are perhaps the most common classes in graphs and represent any
transformation with one input and one output. Pipes` main functionality
revolves around the .transform() method, which actually applies a
transformation to data retrieved from a source. Pipes must also implement
propper data checks by adding descriptions to their source.</p>
<dl class="class">
<dt id="dalio.pipe.pipe.Pipe">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.pipe.</code><code class="sig-name descname">Pipe</code><a class="headerlink" href="#dalio.pipe.pipe.Pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.base.transformer._Transformer</span></code></p>
<p>Pipes represend data modifications with one internal input and one
internal output.</p>
<dl class="attribute">
<dt id="dalio.pipe.pipe.Pipe._source">
<code class="sig-name descname">_source</code><a class="headerlink" href="#dalio.pipe.pipe.Pipe._source" title="Permalink to this definition">¶</a></dt>
<dd><p>input data definition</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>_DataDef</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.pipe.Pipe.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.pipe.Pipe.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.pipe.Pipe.get_input">
<code class="sig-name descname">get_input</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.pipe.Pipe.get_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the input transformer</p>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.pipe.Pipe.pipeline">
<code class="sig-name descname">pipeline</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.pipe.Pipe.pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a PipeLine instance with self as the input source and any
other Pipe instances as part of its pipeline.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*args</strong> – any additional Pipe to be added to the pipeline, in that
order.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.pipe.Pipe.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.pipe.Pipe.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data from source, transform it, and return it</p>
<p>This will often be left alone unless there are specific keyword
arguments or checks done in addition to the actual transformation.
Keep in mind this is rare, as keyword arguments are often required
by Translators, and checks are performed by DataDefs.</p>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.pipe.Pipe.set_input">
<code class="sig-name descname">set_input</code><span class="sig-paren">(</span><em class="sig-param">new_input</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.pipe.Pipe.set_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the input data source in place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>new_input</strong> (<em>_Transformer</em>) – new transformer to be set as input to
source connection.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>TypeError</strong> – if new_input is not an instance of _Transformer.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.pipe.Pipe.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.pipe.Pipe.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.pipe.Pipe.with_input">
<code class="sig-name descname">with_input</code><span class="sig-paren">(</span><em class="sig-param">new_input</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.pipe.Pipe.with_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy of this transformer with the new data source.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.pipe.PipeBuilder">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.pipe.</code><code class="sig-name descname">PipeBuilder</code><a class="headerlink" href="#dalio.pipe.pipe.PipeBuilder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.base.builder._Builder</span></code></p>
<p>Hybrid builder type for complementing _Transformer instances.</p>
<p>These specify extra methods implemented by _Transformer instances.</p>
<dl class="method">
<dt id="dalio.pipe.pipe.PipeBuilder.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.pipe.PipeBuilder.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.pipe.PipeBuilder.with_piece">
<code class="sig-name descname">with_piece</code><span class="sig-paren">(</span><em class="sig-param">param</em>, <em class="sig-param">name</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.pipe.PipeBuilder.with_piece" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy self and return with a new piece set</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.pipe.PipeLine">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.pipe.</code><code class="sig-name descname">PipeLine</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.pipe.PipeLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a></p>
<p>Collection of Pipe transformations.</p>
<p>PipeLine instances represent multiple Pipe transformations being
performed consecutively. Pipelines essentially execute multiple
transformations one after the other, and thus do not check for data
integrity in between them; so keep in mind that order matters and only
the first data definition will be enforced.</p>
<dl class="attribute">
<dt id="dalio.pipe.pipe.PipeLine.pipeline">
<code class="sig-name descname">pipeline</code><a class="headerlink" href="#dalio.pipe.pipe.PipeLine.pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>list of Pipe instaces this pipeline is composed of</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.pipe.PipeLine.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.pipe.PipeLine.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of this Pipeline</p>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.pipe.PipeLine.extend">
<code class="sig-name descname">extend</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">deep=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.pipe.PipeLine.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend existing pipeline with one or more Pipe instances</p>
<p>Keep in mind that this will not mean that</p>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.pipe.PipeLine.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.pipe.PipeLine.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass data sourced from first pipe through every Pipe`s
.transform() method in order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data sourced and checked from first source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-dalio.pipe.select">
<span id="dalio-pipe-select-module"></span><h2>dalio.pipe.select module<a class="headerlink" href="#module-dalio.pipe.select" title="Permalink to this headline">¶</a></h2>
<p>Defines various ways of getting a subset of data based on some condition</p>
<dl class="class">
<dt id="dalio.pipe.select.ColDrop">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.select.</code><code class="sig-name descname">ColDrop</code><span class="sig-paren">(</span><em class="sig-param">columns</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ColDrop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColSelection</span></code></p>
<p>A pipeline stage that drops columns by name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>columns</strong> (<em>str</em><em>, </em><em>iterable</em><em> or </em><em>callable</em>) – The label, or an iterable of labels, of columns to drop. Alternatively,
columns can be assigned a callable returning bool values for
pandas.Series objects; if this is the case, every column for which it
return True will be dropped.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">8</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;char&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ColDrop</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">  char</span>
<span class="go">1    a</span>
<span class="go">2    b</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.select.ColDrop.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ColDrop.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.select.ColRename">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.select.</code><code class="sig-name descname">ColRename</code><span class="sig-paren">(</span><em class="sig-param">map_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ColRename" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a></p>
<p>A pipeline stage that renames a column or columns.</p>
<dl class="attribute">
<dt id="dalio.pipe.select.ColRename.rename_map">
<code class="sig-name descname">rename_map</code><a class="headerlink" href="#dalio.pipe.select.ColRename.rename_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps old column names to new ones.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl>
<dt>Example</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">8</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;char&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ColRename</span><span class="p">({</span><span class="s1">&#39;num&#39;</span><span class="p">:</span> <span class="s1">&#39;len&#39;</span><span class="p">,</span> <span class="s1">&#39;char&#39;</span><span class="p">:</span> <span class="s1">&#39;initial&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   len initial</span>
<span class="go">1    8       a</span>
<span class="go">2    5       b</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="dalio.pipe.select.ColRename.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ColRename.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.select.ColRename.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ColRename.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.select.ColReorder">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.select.</code><code class="sig-name descname">ColReorder</code><span class="sig-paren">(</span><em class="sig-param">map_dict</em>, <em class="sig-param">level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ColReorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColSelection</span></code></p>
<p>A pipeline stage that reorders columns.</p>
<dl class="attribute">
<dt id="dalio.pipe.select.ColReorder.positions">
<code class="sig-name descname">positions</code><a class="headerlink" href="#dalio.pipe.select.ColReorder.positions" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping of column names to their desired positions
after reordering Columns not included in the mapping will maintain
their relative positions over the non-mapped colums.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">]],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ColReorder</span><span class="p">({</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   b  a  d  c</span>
<span class="go">0  4  8  7  3</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.select.ColReorder.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ColReorder.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.select.ColReorder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ColReorder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.select.ColSelect">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.select.</code><code class="sig-name descname">ColSelect</code><span class="sig-paren">(</span><em class="sig-param">columns</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ColSelect" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColSelection</span></code></p>
<p>Select columns</p>
<dl class="method">
<dt id="dalio.pipe.select.ColSelect.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ColSelect.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects the specified columns or returns data as is if no column
was specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Data of the same format as before but only only containing the
specified columns.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.select.DateSelect">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.select.</code><code class="sig-name descname">DateSelect</code><span class="sig-paren">(</span><em class="sig-param">start=None</em>, <em class="sig-param">end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.DateSelect" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a></p>
<p>Select a date range.</p>
<p>This is commonly left as a local variable to control date range being
used at a piece of a graph.</p>
<dl class="attribute">
<dt id="dalio.pipe.select.DateSelect._start">
<code class="sig-name descname">_start</code><a class="headerlink" href="#dalio.pipe.select.DateSelect._start" title="Permalink to this definition">¶</a></dt>
<dd><p>start date.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>pd.Timestamp</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dalio.pipe.select.DateSelect._end">
<code class="sig-name descname">_end</code><a class="headerlink" href="#dalio.pipe.select.DateSelect._end" title="Permalink to this definition">¶</a></dt>
<dd><p>end date.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>pd.Timestamp</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.select.DateSelect.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.DateSelect.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.select.DateSelect.set_end">
<code class="sig-name descname">set_end</code><span class="sig-paren">(</span><em class="sig-param">end</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.DateSelect.set_end" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the _end attribute</p>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.select.DateSelect.set_start">
<code class="sig-name descname">set_start</code><span class="sig-paren">(</span><em class="sig-param">start</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.DateSelect.set_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the _start attribute</p>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.select.DateSelect.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.DateSelect.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Slices time series into selected date range.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Time series of the same format as input containing a subset of
the original dates.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.select.DropNa">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.select.</code><code class="sig-name descname">DropNa</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.DropNa" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a></p>
<p>A pipeline stage that drops null values.</p>
<p>Supports all parameter supported by pandas.dropna function.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="kc">None</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">DropNa</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a     b</span>
<span class="go">1  1   4.0</span>
<span class="go">3  1  11.0</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.select.DropNa.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.DropNa.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.select.FreqDrop">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.select.</code><code class="sig-name descname">FreqDrop</code><span class="sig-paren">(</span><em class="sig-param">values</em>, <em class="sig-param">columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.FreqDrop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColValSelection</span></code></p>
<p>A pipeline stage that drops rows by value frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold</strong> (<em>int</em>) – The minimum frequency required for a value to be kept.</p></li>
<li><p><strong>column</strong> (<em>str</em>) – The name of the colums to check for the given value frequency.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">FreqDrop</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a   b</span>
<span class="go">1  1   4</span>
<span class="go">3  1  11</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.select.FreqDrop.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.FreqDrop.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.select.RowDrop">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.select.</code><code class="sig-name descname">RowDrop</code><span class="sig-paren">(</span><em class="sig-param">conditions</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">reduce_strat=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.RowDrop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColSelection</span></code></p>
<p>A pipeline stage that drop rows by callable conditions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conditions</strong> (<em>list-like</em><em> or </em><em>dict</em>) – The list of conditions that make a row eligible to be dropped. Each
condition must be a callable that take a cell value and return a bool
value. If a list of callables is given, the conditions are checked for
each column value of each row. If a dict mapping column labels to
callables is given, then each condition is only checked for the column
values of the designated column.</p></li>
<li><p><strong>reduce</strong> (<em>'any'</em><em>, </em><em>'all'</em><em> or </em><em>'xor'</em><em>, </em><em>default 'any'</em>) – Determines how row conditions are reduced. If set to ‘all’, a row must
satisfy all given conditions to be dropped. If set to ‘any’, rows
satisfying at least one of the conditions are dropped. If set to ‘xor’,
rows satisfying exactly one of the conditions will be dropped. Set to
‘any’ by default.</p></li>
<li><p><strong>columns</strong> (<em>str</em><em> or </em><em>iterable</em><em>, </em><em>optional</em>) – The label, or an iterable of labels, of columns. Optional. If given,
input conditions will be applied to the sub-dataframe made up of
these columns to determine which rows to drop.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">11</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">RowDrop</span><span class="p">([</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a   b</span>
<span class="go">2  4   5</span>
<span class="go">3  5  11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">RowDrop</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">4</span><span class="p">})</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a   b</span>
<span class="go">1  1   4</span>
<span class="go">3  5  11</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.select.RowDrop.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.RowDrop.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.select.ValDrop">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.select.</code><code class="sig-name descname">ValDrop</code><span class="sig-paren">(</span><em class="sig-param">values</em>, <em class="sig-param">columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ValDrop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColValSelection</span></code></p>
<p>A pipeline stage that drops rows by value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>list-like</em>) – A list of the values to drop.</p></li>
<li><p><strong>columns</strong> (<em>str</em><em> or </em><em>list-like</em><em>, </em><em>default None</em>) – The name, or an iterable of names, of columns to check for the given
values. If set to None, all columns are checked.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">18</span><span class="p">,</span><span class="mi">11</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ValDrop</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">    a   b</span>
<span class="go">1   1   4</span>
<span class="go">3  18  11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ValDrop</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">    a   b</span>
<span class="go">3  18  11</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.select.ValDrop.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ValDrop.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.select.ValKeep">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.select.</code><code class="sig-name descname">ValKeep</code><span class="sig-paren">(</span><em class="sig-param">values</em>, <em class="sig-param">columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ValKeep" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColValSelection</span></code></p>
<p>A pipeline stage that keeps rows by value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>list-like</em>) – A list of the values to keep.</p></li>
<li><p><strong>columns</strong> (<em>str</em><em> or </em><em>list-like</em><em>, </em><em>default None</em>) – The name, or an iterable of names, of columns to check for the given
values. If set to None, all columns are checked.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">11</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ValKeep</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a   b</span>
<span class="go">2  4   5</span>
<span class="go">3  5  11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ValKeep</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a  b</span>
<span class="go">2  4  5</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.select.ValKeep.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.select.ValKeep.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-dalio.pipe">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-dalio.pipe" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dalio.pipe.PipeLine">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">PipeLine</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.PipeLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a></p>
<p>Collection of Pipe transformations.</p>
<p>PipeLine instances represent multiple Pipe transformations being
performed consecutively. Pipelines essentially execute multiple
transformations one after the other, and thus do not check for data
integrity in between them; so keep in mind that order matters and only
the first data definition will be enforced.</p>
<dl class="attribute">
<dt id="dalio.pipe.PipeLine.pipeline">
<code class="sig-name descname">pipeline</code><a class="headerlink" href="#dalio.pipe.PipeLine.pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>list of Pipe instaces this pipeline is composed of</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.PipeLine.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.PipeLine.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of this Pipeline</p>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.PipeLine.extend">
<code class="sig-name descname">extend</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">deep=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.PipeLine.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend existing pipeline with one or more Pipe instances</p>
<p>Keep in mind that this will not mean that</p>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.PipeLine.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.PipeLine.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass data sourced from first pipe through every Pipe`s
.transform() method in order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data sourced and checked from first source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.Custom">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">Custom</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">strategy='apply'</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.Custom" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="beginners-guide.html#dalio.pipe.col_generation._ColGeneration" title="dalio.pipe.col_generation._ColGeneration"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation._ColGeneration</span></code></a></p>
<p>Apply custom function.</p>
<dl class="attribute">
<dt id="dalio.pipe.Custom.strategy">
<code class="sig-name descname">strategy</code><a class="headerlink" href="#dalio.pipe.Custom.strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>strategy for applying value function.
One of [“apply”, “transform”, “agg”, “pipe”]</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str, default “pipe”</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">from</span> <span class="nn">dalio.pipe</span> <span class="kn">import</span> <span class="n">Custom</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2143</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1321</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1255</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;years&#39;</span><span class="p">,</span> <span class="s1">&#39;avg_revenue&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">total_rev</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;years&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;avg_revenue&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add_total_rev</span> <span class="o">=</span> <span class="n">Custom</span><span class="p">(</span><span class="n">total_rev</span><span class="p">,</span> <span class="s1">&#39;total_revenue&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add_total_rev</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   years  avg_revenue  total_revenue</span>
<span class="go">1      3         2143           6429</span>
<span class="go">2     10         1321          13210</span>
<span class="go">3      7         1255           8785</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">halfer</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">new</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;year/2&#39;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;years&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>           <span class="s1">&#39;rev/2&#39;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;avg_revenue&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">}</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">half_cols</span> <span class="o">=</span> <span class="n">Custom</span><span class="p">(</span><span class="n">halfer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">half_cols</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   years  avg_revenue   rev/2  year/2</span>
<span class="go">1      3         2143  1071.5     1.5</span>
<span class="go">2     10         1321   660.5     5.0</span>
<span class="go">3      7         1255   627.5     3.5</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;B&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add_equal</span> <span class="o">=</span> <span class="n">Custom</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;A==B&quot;</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;pipe&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add_equal</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   A  B   A==B</span>
<span class="go">1  3  3   True</span>
<span class="go">2  2  4  False</span>
<span class="go">3  1  5  False</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.Custom.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.Custom.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.Rolling">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">Rolling</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">rolling_window=2</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.Rolling" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="beginners-guide.html#dalio.pipe.col_generation._ColGeneration" title="dalio.pipe.col_generation._ColGeneration"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation._ColGeneration</span></code></a></p>
<p>Apply rolling function</p>
<dl class="attribute">
<dt id="dalio.pipe.Rolling.rolling_window">
<code class="sig-name descname">rolling_window</code><a class="headerlink" href="#dalio.pipe.Rolling.rolling_window" title="Permalink to this definition">¶</a></dt>
<dd><p>rolling window to apply
function. If none, no rolling window is applied.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int, defailt None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.Rolling.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.Rolling.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.ColSelect">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">ColSelect</code><span class="sig-paren">(</span><em class="sig-param">columns</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ColSelect" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColSelection</span></code></p>
<p>Select columns</p>
<dl class="method">
<dt id="dalio.pipe.ColSelect.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ColSelect.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects the specified columns or returns data as is if no column
was specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Data of the same format as before but only only containing the
specified columns.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.DateSelect">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">DateSelect</code><span class="sig-paren">(</span><em class="sig-param">start=None</em>, <em class="sig-param">end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.DateSelect" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a></p>
<p>Select a date range.</p>
<p>This is commonly left as a local variable to control date range being
used at a piece of a graph.</p>
<dl class="attribute">
<dt id="dalio.pipe.DateSelect._start">
<code class="sig-name descname">_start</code><a class="headerlink" href="#dalio.pipe.DateSelect._start" title="Permalink to this definition">¶</a></dt>
<dd><p>start date.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>pd.Timestamp</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dalio.pipe.DateSelect._end">
<code class="sig-name descname">_end</code><a class="headerlink" href="#dalio.pipe.DateSelect._end" title="Permalink to this definition">¶</a></dt>
<dd><p>end date.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>pd.Timestamp</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.DateSelect.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.DateSelect.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.DateSelect.set_end">
<code class="sig-name descname">set_end</code><span class="sig-paren">(</span><em class="sig-param">end</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.DateSelect.set_end" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the _end attribute</p>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.DateSelect.set_start">
<code class="sig-name descname">set_start</code><span class="sig-paren">(</span><em class="sig-param">start</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.DateSelect.set_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the _start attribute</p>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.DateSelect.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.DateSelect.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Slices time series into selected date range.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Time series of the same format as input containing a subset of
the original dates.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.ColDrop">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">ColDrop</code><span class="sig-paren">(</span><em class="sig-param">columns</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ColDrop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColSelection</span></code></p>
<p>A pipeline stage that drops columns by name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>columns</strong> (<em>str</em><em>, </em><em>iterable</em><em> or </em><em>callable</em>) – The label, or an iterable of labels, of columns to drop. Alternatively,
columns can be assigned a callable returning bool values for
pandas.Series objects; if this is the case, every column for which it
return True will be dropped.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">8</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;char&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ColDrop</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">  char</span>
<span class="go">1    a</span>
<span class="go">2    b</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.ColDrop.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ColDrop.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.ValDrop">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">ValDrop</code><span class="sig-paren">(</span><em class="sig-param">values</em>, <em class="sig-param">columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ValDrop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColValSelection</span></code></p>
<p>A pipeline stage that drops rows by value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>list-like</em>) – A list of the values to drop.</p></li>
<li><p><strong>columns</strong> (<em>str</em><em> or </em><em>list-like</em><em>, </em><em>default None</em>) – The name, or an iterable of names, of columns to check for the given
values. If set to None, all columns are checked.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">18</span><span class="p">,</span><span class="mi">11</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ValDrop</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">    a   b</span>
<span class="go">1   1   4</span>
<span class="go">3  18  11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ValDrop</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">    a   b</span>
<span class="go">3  18  11</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.ValDrop.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ValDrop.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.ValKeep">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">ValKeep</code><span class="sig-paren">(</span><em class="sig-param">values</em>, <em class="sig-param">columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ValKeep" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColValSelection</span></code></p>
<p>A pipeline stage that keeps rows by value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>list-like</em>) – A list of the values to keep.</p></li>
<li><p><strong>columns</strong> (<em>str</em><em> or </em><em>list-like</em><em>, </em><em>default None</em>) – The name, or an iterable of names, of columns to check for the given
values. If set to None, all columns are checked.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">11</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ValKeep</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a   b</span>
<span class="go">2  4   5</span>
<span class="go">3  5  11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ValKeep</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a  b</span>
<span class="go">2  4  5</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.ValKeep.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ValKeep.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.ColRename">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">ColRename</code><span class="sig-paren">(</span><em class="sig-param">map_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ColRename" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a></p>
<p>A pipeline stage that renames a column or columns.</p>
<dl class="attribute">
<dt id="dalio.pipe.ColRename.rename_map">
<code class="sig-name descname">rename_map</code><a class="headerlink" href="#dalio.pipe.ColRename.rename_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps old column names to new ones.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl>
<dt>Example</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">8</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;char&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ColRename</span><span class="p">({</span><span class="s1">&#39;num&#39;</span><span class="p">:</span> <span class="s1">&#39;len&#39;</span><span class="p">,</span> <span class="s1">&#39;char&#39;</span><span class="p">:</span> <span class="s1">&#39;initial&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   len initial</span>
<span class="go">1    8       a</span>
<span class="go">2    5       b</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="dalio.pipe.ColRename.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ColRename.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.ColRename.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ColRename.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.DropNa">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">DropNa</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.DropNa" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a></p>
<p>A pipeline stage that drops null values.</p>
<p>Supports all parameter supported by pandas.dropna function.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="kc">None</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">DropNa</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a     b</span>
<span class="go">1  1   4.0</span>
<span class="go">3  1  11.0</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.DropNa.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.DropNa.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.FreqDrop">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">FreqDrop</code><span class="sig-paren">(</span><em class="sig-param">values</em>, <em class="sig-param">columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.FreqDrop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColValSelection</span></code></p>
<p>A pipeline stage that drops rows by value frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold</strong> (<em>int</em>) – The minimum frequency required for a value to be kept.</p></li>
<li><p><strong>column</strong> (<em>str</em>) – The name of the colums to check for the given value frequency.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">FreqDrop</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a   b</span>
<span class="go">1  1   4</span>
<span class="go">3  1  11</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.FreqDrop.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.FreqDrop.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.ColReorder">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">ColReorder</code><span class="sig-paren">(</span><em class="sig-param">map_dict</em>, <em class="sig-param">level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ColReorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColSelection</span></code></p>
<p>A pipeline stage that reorders columns.</p>
<dl class="attribute">
<dt id="dalio.pipe.ColReorder.positions">
<code class="sig-name descname">positions</code><a class="headerlink" href="#dalio.pipe.ColReorder.positions" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping of column names to their desired positions
after reordering Columns not included in the mapping will maintain
their relative positions over the non-mapped colums.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">]],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">ColReorder</span><span class="p">({</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   b  a  d  c</span>
<span class="go">0  4  8  7  3</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.ColReorder.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ColReorder.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.ColReorder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ColReorder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.RowDrop">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">RowDrop</code><span class="sig-paren">(</span><em class="sig-param">conditions</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">reduce_strat=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.RowDrop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.select._ColSelection</span></code></p>
<p>A pipeline stage that drop rows by callable conditions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conditions</strong> (<em>list-like</em><em> or </em><em>dict</em>) – The list of conditions that make a row eligible to be dropped. Each
condition must be a callable that take a cell value and return a bool
value. If a list of callables is given, the conditions are checked for
each column value of each row. If a dict mapping column labels to
callables is given, then each condition is only checked for the column
values of the designated column.</p></li>
<li><p><strong>reduce</strong> (<em>'any'</em><em>, </em><em>'all'</em><em> or </em><em>'xor'</em><em>, </em><em>default 'any'</em>) – Determines how row conditions are reduced. If set to ‘all’, a row must
satisfy all given conditions to be dropped. If set to ‘any’, rows
satisfying at least one of the conditions are dropped. If set to ‘xor’,
rows satisfying exactly one of the conditions will be dropped. Set to
‘any’ by default.</p></li>
<li><p><strong>columns</strong> (<em>str</em><em> or </em><em>iterable</em><em>, </em><em>optional</em>) – The label, or an iterable of labels, of columns. Optional. If given,
input conditions will be applied to the sub-dataframe made up of
these columns to determine which rows to drop.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">11</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">RowDrop</span><span class="p">([</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a   b</span>
<span class="go">2  4   5</span>
<span class="go">3  5  11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">RowDrop</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">4</span><span class="p">})</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a   b</span>
<span class="go">1  1   4</span>
<span class="go">3  5  11</span>
</pre></div>
</div>
<dl class="method">
<dt id="dalio.pipe.RowDrop.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.RowDrop.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to data returned from source.</p>
<p>This is where the bulk of funtionality in a Pipe lies. And allows it
to be highly customizable. This will often be the only method needed
to be overwriten in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – data returned by source.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.Change">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">Change</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">strategy='diff'</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.Change" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="beginners-guide.html#dalio.pipe.col_generation._ColGeneration" title="dalio.pipe.col_generation._ColGeneration"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation._ColGeneration</span></code></a></p>
<p>Perform item-by-item change</p>
<p>This has two main forms, percentage change and absolute change
(difference).</p>
<dl class="attribute">
<dt id="dalio.pipe.Change._strategy">
<code class="sig-name descname">_strategy</code><a class="headerlink" href="#dalio.pipe.Change._strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>change strategy.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str, callable</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.Change.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.Change.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.StockReturns">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">StockReturns</code><span class="sig-paren">(</span><em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.StockReturns" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="beginners-guide.html#dalio.pipe.col_generation._ColGeneration" title="dalio.pipe.col_generation._ColGeneration"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation._ColGeneration</span></code></a></p>
<p>Perform percent change and minor aesthetic changes to data</p>
</dd></dl>

<dl class="class">
<dt id="dalio.pipe.Period">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">Period</code><span class="sig-paren">(</span><em class="sig-param">period</em>, <em class="sig-param">*args</em>, <em class="sig-param">agg_func=&lt;function mean&gt;</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.Period" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="beginners-guide.html#dalio.pipe.col_generation._ColGeneration" title="dalio.pipe.col_generation._ColGeneration"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation._ColGeneration</span></code></a></p>
<p>Resample input time series data to a different period</p>
<blockquote>
<div><dl class="simple">
<dt>Attributes:</dt><dd><p>agg_func (callable): function to aggregate data to one period.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt># Quandl Input</dt><dd><blockquote>
<div><p>Default set to np.mean.</p>
</div></blockquote>
<dl class="simple">
<dt>_period (str): period to resample data to. Can be either daily,</dt><dd><p>monthly, quarterly or yearly.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="attribute">
<dt id="dalio.pipe.Period.agg_func">
<code class="sig-name descname">agg_func</code><em class="property">: Callable[[Iterable], Any]</em><em class="property"> = None</em><a class="headerlink" href="#dalio.pipe.Period.agg_func" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dalio.pipe.Period.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.Period.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.Index">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">Index</code><span class="sig-paren">(</span><em class="sig-param">index_at</em>, <em class="sig-param">*args</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="beginners-guide.html#dalio.pipe.col_generation._ColGeneration" title="dalio.pipe.col_generation._ColGeneration"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation._ColGeneration</span></code></a></p>
<dl class="method">
<dt id="dalio.pipe.Index.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.Index.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.Bin">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">Bin</code><span class="sig-paren">(</span><em class="sig-param">bin_map</em>, <em class="sig-param">*args</em>, <em class="sig-param">bin_strat='normal'</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.Bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.col_generation.Custom" title="dalio.pipe.col_generation.Custom"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation.Custom</span></code></a></p>
<p>A pipeline stage that adds a binned version of a column or columns.</p>
<p>If drop is set to True the new columns retain the names of the source
columns; otherwise, the resulting column gain the suffix ‘_bin’</p>
<dl class="attribute">
<dt id="dalio.pipe.Bin.bin_map">
<code class="sig-name descname">bin_map</code><a class="headerlink" href="#dalio.pipe.Bin.bin_map" title="Permalink to this definition">¶</a></dt>
<dd><p>implicitly projects a left-most bin containing
all elements smaller than the left-most end point and a right-most
bin containing all elements larger that the right-most end point.
For example, the list [0, 5, 8] is interpreted as
the bins (-∞, 0), [0-5), [5-8) and [8, ∞).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dalio.pipe.Bin.bin_strat">
<code class="sig-name descname">bin_strat</code><a class="headerlink" href="#dalio.pipe.Bin.bin_strat" title="Permalink to this definition">¶</a></dt>
<dd><p>binning strategy to use. “normal”
uses the default binning strategy per a list of value separations
or number of bins. “quantile” uses a list of quantiles or a
preset quantile range (4 for quartiles and 10 for deciles).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str, default “normal”</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;speed&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">Bin</span><span class="p">({</span><span class="s1">&#39;speed&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]},</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   speed speed_bin</span>
<span class="go">1     -3        &lt;5</span>
<span class="go">2      4        &lt;5</span>
<span class="go">3      5        5≤</span>
<span class="go">4      9        5≤</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">Bin</span><span class="p">({</span><span class="s1">&#39;speed&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">]},</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   speed speed_bin</span>
<span class="go">1     -3        &lt;0</span>
<span class="go">2      4       0-5</span>
<span class="go">3      5       5-8</span>
<span class="go">4      9        8≤</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="dalio.pipe.MapColVals">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">MapColVals</code><span class="sig-paren">(</span><em class="sig-param">value_map</em>, <em class="sig-param">*args</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.MapColVals" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.col_generation.Custom" title="dalio.pipe.col_generation.Custom"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation.Custom</span></code></a></p>
<p>A pipeline stage that reintegrates the values of a column by a map.</p>
<dl class="attribute">
<dt id="dalio.pipe.MapColVals.value_map">
<code class="sig-name descname">value_map</code><a class="headerlink" href="#dalio.pipe.MapColVals.value_map" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary mapping
existing values to new ones. Values not in the dictionary as keys
will be converted to NaN. If a function is given, it is applied
element-wise to given columns. If a Series is given, values are
mapped by its index to its values.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict, function or pandas.Series</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="s1">&#39;UK&#39;</span><span class="p">,</span> <span class="s1">&#39;USSR&#39;</span><span class="p">,</span> <span class="s1">&#39;US&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Medal&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value_map</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;Gold&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;Silver&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;Bronze&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdp</span><span class="o">.</span><span class="n">MapColVals</span><span class="p">(</span><span class="s1">&#39;Medal&#39;</span><span class="p">,</span> <span class="n">value_map</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">       Medal</span>
<span class="go">UK      Gold</span>
<span class="go">USSR  Bronze</span>
<span class="go">US    Silver</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="dalio.pipe.CustomByCols">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">CustomByCols</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">strategy='apply'</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.CustomByCols" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.col_generation.Custom" title="dalio.pipe.col_generation.Custom"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation.Custom</span></code></a></p>
<p>A pipeline stage applying a function to individual columns iteratively.</p>
<dl class="attribute">
<dt id="dalio.pipe.CustomByCols.func">
<code class="sig-name descname">func</code><a class="headerlink" href="#dalio.pipe.CustomByCols.func" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to be applied to each element of the
given columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>function</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dalio.pipe.CustomByCols.strategy">
<code class="sig-name descname">strategy</code><a class="headerlink" href="#dalio.pipe.CustomByCols.strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Application strategy. Different from Custom class’
strategy parameter (which here is kept at “apply”) as this will
now be done on a series (each column). Extra care should be taken
to ensure resulting column lengths match.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">math</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">3.2</span><span class="p">,</span> <span class="s2">&quot;acd&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mf">7.2</span><span class="p">,</span> <span class="s2">&quot;alk&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mf">12.1</span><span class="p">,</span> <span class="s2">&quot;alk&quot;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;ph&quot;</span><span class="p">,</span><span class="s2">&quot;lbl&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">round_ph</span> <span class="o">=</span> <span class="n">pdp</span><span class="o">.</span><span class="n">ApplyByCols</span><span class="p">(</span><span class="s2">&quot;ph&quot;</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">round_ph</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   ph  lbl</span>
<span class="go">1   4  acd</span>
<span class="go">2   8  alk</span>
<span class="go">3  13  alk</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="dalio.pipe.Log">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">Log</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">non_neg=False</em>, <em class="sig-param">const_shift=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.Log" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.col_generation.Custom" title="dalio.pipe.col_generation.Custom"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation.Custom</span></code></a></p>
<p>A pipeline stage that log-transforms numeric data.</p>
<dl class="attribute">
<dt id="dalio.pipe.Log.non_neg">
<code class="sig-name descname">non_neg</code><a class="headerlink" href="#dalio.pipe.Log.non_neg" title="Permalink to this definition">¶</a></dt>
<dd><p>If True, each transformed column is
first shifted by smallest negative value it includes
(non-negative columns are thus not shifted).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool, default False</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dalio.pipe.Log.const_shift">
<code class="sig-name descname">const_shift</code><a class="headerlink" href="#dalio.pipe.Log.const_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>If given, each transformed column is
first shifted by this constant. If non_neg is True then that
transformation is applied first, and only then is the column
shifted by this constant.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">pdpipe</span> <span class="k">as</span> <span class="nn">pdp</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">3.2</span><span class="p">,</span> <span class="s2">&quot;acd&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mf">7.2</span><span class="p">,</span> <span class="s2">&quot;alk&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mf">12.1</span><span class="p">,</span> <span class="s2">&quot;alk&quot;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;ph&quot;</span><span class="p">,</span><span class="s2">&quot;lbl&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log_stage</span> <span class="o">=</span> <span class="n">pdp</span><span class="o">.</span><span class="n">Log</span><span class="p">(</span><span class="s2">&quot;ph&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log_stage</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">         ph  lbl</span>
<span class="go">1  1.163151  acd</span>
<span class="go">2  1.974081  alk</span>
<span class="go">3  2.493205  alk</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="dalio.pipe.BoxCox">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">BoxCox</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">new_cols=None</em>, <em class="sig-param">non_neg=False</em>, <em class="sig-param">const_shift=None</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">reintegrate=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.BoxCox" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.col_generation.Custom" title="dalio.pipe.col_generation.Custom"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.col_generation.Custom</span></code></a></p>
<p>A pipeline stage that applies the BoxCox transformation on data.</p>
<dl class="attribute">
<dt id="dalio.pipe.BoxCox.const_shift">
<code class="sig-name descname">const_shift</code><a class="headerlink" href="#dalio.pipe.BoxCox.const_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>If given, each transformed column is
first shifted by this constant. If non_neg is True then that
transformation is applied first, and only then is the column
shifted by this constant.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.StockComps">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">StockComps</code><span class="sig-paren">(</span><em class="sig-param">strategy='sic_code'</em>, <em class="sig-param">max_ticks=6</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.StockComps" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a></p>
<p>Get a list of a ticker’s comparable stocks</p>
<p>This can utilize any strategy of getting stock comparative companies and
return up to a certain ammount of comps.</p>
<dl class="attribute">
<dt id="dalio.pipe.StockComps._strategy">
<code class="sig-name descname">_strategy</code><a class="headerlink" href="#dalio.pipe.StockComps._strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>comparisson strategy name or function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str, callable</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dalio.pipe.StockComps.max_ticks">
<code class="sig-name descname">max_ticks</code><a class="headerlink" href="#dalio.pipe.StockComps.max_ticks" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum number of tickers to return.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.StockComps.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.StockComps.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt>
<code class="sig-name descname">max_ticks</code><em class="property">: int</em><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dalio.pipe.StockComps.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.StockComps.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets ticker argument and passes an empty ticker request to
transform.</p>
<p>Empty ticker requests are supposed to return all tickers available in
a source, so this allows the compariisson to be made in all stocks
from a certain source.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if ticker is more than a single symbol.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.StockComps.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.StockComps.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Get comps according to the set strategy</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.CovShrink">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">CovShrink</code><span class="sig-paren">(</span><em class="sig-param">frequency=252</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.CovShrink" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.PipeBuilder" title="dalio.pipe.pipe.PipeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.PipeBuilder</span></code></a></p>
<p>Perform Covariance Shrinkage on data</p>
<p>Builder with a single piece: shirnkage. Shrinkage defines what kind of
shrinkage to apply on a resultant covariance matrix. If none is set,
covariance will not be shrunk.</p>
<dl class="attribute">
<dt id="dalio.pipe.CovShrink.frequency">
<code class="sig-name descname">frequency</code><a class="headerlink" href="#dalio.pipe.CovShrink.frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>data time period frequency</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.CovShrink.build_model">
<code class="sig-name descname">build_model</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.CovShrink.build_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds Covariance Srhinkage object and returns selected shrinkage
strategy</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Function fitted on the data.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.CovShrink.check_name">
<code class="sig-name descname">check_name</code><span class="sig-paren">(</span><em class="sig-param">param</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.CovShrink.check_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if name and parameter combination is valid.</p>
<p>This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
_Builder. This also can be called from outside of a _Builder instance
to check for the validity of settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>piece</strong> (<em>str</em>) – name of the key in the piece dictionary.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – name option to be set to the piece.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.CovShrink.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.CovShrink.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt>
<code class="sig-name descname">frequency</code><em class="property">: int</em><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dalio.pipe.CovShrink.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.CovShrink.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Build model using data get results.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A covariance matrix</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.ExpectedReturns">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">ExpectedReturns</code><a class="headerlink" href="#dalio.pipe.ExpectedReturns" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.PipeBuilder" title="dalio.pipe.pipe.PipeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.PipeBuilder</span></code></a></p>
<p>Get stock’s time series expected returns.</p>
<p>Builder with a single piece: return_model. return_model is what model to
get the expected returns from.</p>
<dl class="method">
<dt id="dalio.pipe.ExpectedReturns.build_model">
<code class="sig-name descname">build_model</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ExpectedReturns.build_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble pieces into a model given some data</p>
<p>The data will opten be optional, but several builder models will
require it to be fitted on initialization. Which further shows why
builders are necessary for context-agnostic graphs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – data that might be used to build the model.</p></li>
<li><p><strong>**kwargs</strong> – any additional argument used in building</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.ExpectedReturns.check_name">
<code class="sig-name descname">check_name</code><span class="sig-paren">(</span><em class="sig-param">param</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ExpectedReturns.check_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if name and parameter combination is valid.</p>
<p>This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
_Builder. This also can be called from outside of a _Builder instance
to check for the validity of settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>piece</strong> (<em>str</em>) – name of the key in the piece dictionary.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – name option to be set to the piece.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.ExpectedReturns.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ExpectedReturns.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds model using data and gets expected returns from it</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.MakeARCH">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">MakeARCH</code><a class="headerlink" href="#dalio.pipe.MakeARCH" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.PipeBuilder" title="dalio.pipe.pipe.PipeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.PipeBuilder</span></code></a></p>
<p>Build arch model and make it based on input data.</p>
<p>This class allows for the creation of arch models by configuring three
pieces: the mean, volatility and distribution. These are set after
initialization through the _Builder interface.</p>
<dl class="attribute">
<dt id="dalio.pipe.MakeARCH._piece">
<code class="sig-name descname">_piece</code><a class="headerlink" href="#dalio.pipe.MakeARCH._piece" title="Permalink to this definition">¶</a></dt>
<dd><p>see _Builder class.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.MakeARCH.assimilate">
<code class="sig-name descname">assimilate</code><span class="sig-paren">(</span><em class="sig-param">model</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.MakeARCH.assimilate" title="Permalink to this definition">¶</a></dt>
<dd><p>Assimilate core pieces of an existent ARCH Model.</p>
<p>Assimilation means setting this model’s’ pieces in accordance to an
existing model’s pieces. Assimilation is shallow, so only the main
pieces are assimilated, not their parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> (<em>ARCHModel</em>) – Existing ARCH Model.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.MakeARCH.build_model">
<code class="sig-name descname">build_model</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.MakeARCH.build_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Build ARCH Model using data, set pieces and their arguments</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A built arch model from the arch package.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.MakeARCH.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.MakeARCH.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Build model with sourced data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.ValueAtRisk">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">ValueAtRisk</code><span class="sig-paren">(</span><em class="sig-param">quantiles=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ValueAtRisk" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.Pipe" title="dalio.pipe.pipe.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.Pipe</span></code></a></p>
<p>Get the value at risk for data based on an ARHC Model</p>
<p>This takes in an ARCH Model maker, not data, which might be unintuitive,
yet necessary, as this allows users to modify the ARCH model generating
these values separately. A useful strategy that allows for this
is using a pipeline with an arch model as its first input and a
ValueAtRisk instance as its second layer. This allows us to treat the
PipeLine as a data input with VaR output and still have control over the
ARCH Model pieces (given you left a local variable for it behind.)</p>
<dl class="attribute">
<dt id="dalio.pipe.ValueAtRisk._quantiles">
<code class="sig-name descname">_quantiles</code><a class="headerlink" href="#dalio.pipe.ValueAtRisk._quantiles" title="Permalink to this definition">¶</a></dt>
<dd><p>list of quantiles to check the value at risk for.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.ValueAtRisk.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ValueAtRisk.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of transformer, copying its attributes to a new
instance.</p>
<p>This copy should essentially create a new transformation node, not an
entire new graph, so the _source attribute of the returned instance
should be assigned without being copied. This is also made to be built
upon by subclasses, such that only new attributes need to be added to
a class’ copy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Positional arguments to be passed to initialize copy</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to be passed to initialize copy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of this _Transformer instance with copies of necessary
attributes and empty input.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.ValueAtRisk.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ValueAtRisk.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Get values at risk at each quantile and each results maximum
exedence from the mean.</p>
<p>The maximum exedence columns tells which quantile the loss is placed
on. The word “maximum” might be misleading as it is compared to the
minimum quantile, however, this definition is accurate as the column
essentially answers the question: “what quantile furthest away from
the mean does the data exeed?”</p>
<p>Thank you for the creators of the arch package for the beautiful
visualizations and ideas!</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – if ARCH model does not have returns. This is often
    the case for unfitted models. Ensure your graph is complete.</p></li>
<li><p><strong>TypeError</strong> – if ARCH model has unsuported distribution parameter.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.ExpectedShortfall">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">ExpectedShortfall</code><span class="sig-paren">(</span><em class="sig-param">quantiles=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ExpectedShortfall" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.builders.ValueAtRisk" title="dalio.pipe.builders.ValueAtRisk"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.builders.ValueAtRisk</span></code></a></p>
<p>Get expected shortfal for given quantiles</p>
<p>See base class for more in depth explanation.</p>
<dl class="method">
<dt id="dalio.pipe.ExpectedShortfall.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.ExpectedShortfall.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value at risk given by an arch model and calculate the
expected shortfall at given quantiles.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.PandasLinearModel">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">PandasLinearModel</code><a class="headerlink" href="#dalio.pipe.PandasLinearModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.PipeBuilder" title="dalio.pipe.pipe.PipeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.PipeBuilder</span></code></a></p>
<p>Create a linear model from input pandas dataframe, using its index
as the X value.</p>
<p>This builder is made up of a single piece: strategy. This piece sets
which linear model should be used to fit the data.</p>
<dl class="method">
<dt id="dalio.pipe.PandasLinearModel.build_model">
<code class="sig-name descname">build_model</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.PandasLinearModel.build_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Build model by returning the chosen model and initialization
parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Unfitted linear model</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.PandasLinearModel.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.PandasLinearModel.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up fitting parameters and fit built model.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Fitted linear model</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dalio.pipe.OptimumWeights">
<em class="property">class </em><code class="sig-prename descclassname">dalio.pipe.</code><code class="sig-name descname">OptimumWeights</code><a class="headerlink" href="#dalio.pipe.OptimumWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dalio.pipe.pipe.PipeBuilder" title="dalio.pipe.pipe.PipeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">dalio.pipe.pipe.PipeBuilder</span></code></a></p>
<p>Get optimum portfolio weights from an efficient frontier or CLA.
This is also a builder with one piece: strategy. The strategy piece
refers to the optimization strategy.</p>
<dl class="method">
<dt id="dalio.pipe.OptimumWeights.build_model">
<code class="sig-name descname">build_model</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.OptimumWeights.build_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble pieces into a model given some data</p>
<p>The data will opten be optional, but several builder models will
require it to be fitted on initialization. Which further shows why
builders are necessary for context-agnostic graphs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – data that might be used to build the model.</p></li>
<li><p><strong>**kwargs</strong> – any additional argument used in building</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.OptimumWeights.check_name">
<code class="sig-name descname">check_name</code><span class="sig-paren">(</span><em class="sig-param">param</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.OptimumWeights.check_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if name and parameter combination is valid.</p>
<p>This will always be called upon setting a new piece to ensure this
piece is present dictionary and that the name is valid. Subclasses
will often override this method to implement the name checks in
accordance to their specific name parameter combination options.
Notice that checks cannot be done on arguments before running the
_Builder. This also can be called from outside of a _Builder instance
to check for the validity of settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>piece</strong> (<em>str</em>) – name of the key in the piece dictionary.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – name option to be set to the piece.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dalio.pipe.OptimumWeights.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dalio.pipe.OptimumWeights.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Get efficient frontier, fit it to model and get weights</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dalio.model.html" title="dalio.model package"
             >next</a> |</li>
        <li class="right" >
          <a href="dalio.translator.html" title="dalio.translator package"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Dal.io 0.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modules.html" >User Modules</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Renato Zimmermann.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.0.
    </div>
  </body>
</html>